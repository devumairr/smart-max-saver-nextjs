/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sweetalert2";
exports.ids = ["vendor-chunks/sweetalert2"];
exports.modules = {

/***/ "(ssr)/./node_modules/sweetalert2/dist/sweetalert2.all.js":
/*!**********************************************************!*\
  !*** ./node_modules/sweetalert2/dist/sweetalert2.all.js ***!
  \**********************************************************/
/***/ (function(module) {

eval("/*!\n* sweetalert2 v11.6.13\n* Released under the MIT License.\n*/ (function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(this, function() {\n    \"use strict\";\n    /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */ var privateProps = {\n        awaitingPromise: new WeakMap(),\n        promise: new WeakMap(),\n        innerParams: new WeakMap(),\n        domCache: new WeakMap()\n    };\n    const swalPrefix = \"swal2-\";\n    /**\n   * @param {string[]} items\n   * @returns {object}\n   */ const prefix = (items)=>{\n        const result = {};\n        for(const i in items){\n            result[items[i]] = swalPrefix + items[i];\n        }\n        return result;\n    };\n    const swalClasses = prefix([\n        \"container\",\n        \"shown\",\n        \"height-auto\",\n        \"iosfix\",\n        \"popup\",\n        \"modal\",\n        \"no-backdrop\",\n        \"no-transition\",\n        \"toast\",\n        \"toast-shown\",\n        \"show\",\n        \"hide\",\n        \"close\",\n        \"title\",\n        \"html-container\",\n        \"actions\",\n        \"confirm\",\n        \"deny\",\n        \"cancel\",\n        \"default-outline\",\n        \"footer\",\n        \"icon\",\n        \"icon-content\",\n        \"image\",\n        \"input\",\n        \"file\",\n        \"range\",\n        \"select\",\n        \"radio\",\n        \"checkbox\",\n        \"label\",\n        \"textarea\",\n        \"inputerror\",\n        \"input-label\",\n        \"validation-message\",\n        \"progress-steps\",\n        \"active-progress-step\",\n        \"progress-step\",\n        \"progress-step-line\",\n        \"loader\",\n        \"loading\",\n        \"styled\",\n        \"top\",\n        \"top-start\",\n        \"top-end\",\n        \"top-left\",\n        \"top-right\",\n        \"center\",\n        \"center-start\",\n        \"center-end\",\n        \"center-left\",\n        \"center-right\",\n        \"bottom\",\n        \"bottom-start\",\n        \"bottom-end\",\n        \"bottom-left\",\n        \"bottom-right\",\n        \"grow-row\",\n        \"grow-column\",\n        \"grow-fullscreen\",\n        \"rtl\",\n        \"timer-progress-bar\",\n        \"timer-progress-bar-container\",\n        \"scrollbar-measure\",\n        \"icon-success\",\n        \"icon-warning\",\n        \"icon-info\",\n        \"icon-question\",\n        \"icon-error\"\n    ]);\n    const iconTypes = prefix([\n        \"success\",\n        \"warning\",\n        \"info\",\n        \"question\",\n        \"error\"\n    ]);\n    const consolePrefix = \"SweetAlert2:\";\n    /**\n   * Filter the unique values into a new array\n   *\n   * @param {Array} arr\n   * @returns {Array}\n   */ const uniqueArray = (arr)=>{\n        const result = [];\n        for(let i = 0; i < arr.length; i++){\n            if (result.indexOf(arr[i]) === -1) {\n                result.push(arr[i]);\n            }\n        }\n        return result;\n    };\n    /**\n   * Capitalize the first letter of a string\n   *\n   * @param {string} str\n   * @returns {string}\n   */ const capitalizeFirstLetter = (str)=>str.charAt(0).toUpperCase() + str.slice(1);\n    /**\n   * Standardize console warnings\n   *\n   * @param {string | Array} message\n   */ const warn = (message)=>{\n        console.warn(`${consolePrefix} ${typeof message === \"object\" ? message.join(\" \") : message}`);\n    };\n    /**\n   * Standardize console errors\n   *\n   * @param {string} message\n   */ const error = (message)=>{\n        console.error(`${consolePrefix} ${message}`);\n    };\n    /**\n   * Private global state for `warnOnce`\n   *\n   * @type {Array}\n   * @private\n   */ const previousWarnOnceMessages = [];\n    /**\n   * Show a console warning, but only if it hasn't already been shown\n   *\n   * @param {string} message\n   */ const warnOnce = (message)=>{\n        if (!previousWarnOnceMessages.includes(message)) {\n            previousWarnOnceMessages.push(message);\n            warn(message);\n        }\n    };\n    /**\n   * Show a one-time console warning about deprecated params/methods\n   *\n   * @param {string} deprecatedParam\n   * @param {string} useInstead\n   */ const warnAboutDeprecation = (deprecatedParam, useInstead)=>{\n        warnOnce(`\"${deprecatedParam}\" is deprecated and will be removed in the next major release. Please use \"${useInstead}\" instead.`);\n    };\n    /**\n   * If `arg` is a function, call it (with no arguments or context) and return the result.\n   * Otherwise, just pass the value through\n   *\n   * @param {Function | any} arg\n   * @returns {any}\n   */ const callIfFunction = (arg)=>typeof arg === \"function\" ? arg() : arg;\n    /**\n   * @param {any} arg\n   * @returns {boolean}\n   */ const hasToPromiseFn = (arg)=>arg && typeof arg.toPromise === \"function\";\n    /**\n   * @param {any} arg\n   * @returns {Promise}\n   */ const asPromise = (arg)=>hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n    /**\n   * @param {any} arg\n   * @returns {boolean}\n   */ const isPromise = (arg)=>arg && Promise.resolve(arg) === arg;\n    /**\n   * Gets the popup container which contains the backdrop and the popup itself.\n   *\n   * @returns {HTMLElement | null}\n   */ const getContainer = ()=>document.body.querySelector(`.${swalClasses.container}`);\n    /**\n   * @param {string} selectorString\n   * @returns {HTMLElement | null}\n   */ const elementBySelector = (selectorString)=>{\n        const container = getContainer();\n        return container ? container.querySelector(selectorString) : null;\n    };\n    /**\n   * @param {string} className\n   * @returns {HTMLElement | null}\n   */ const elementByClass = (className)=>{\n        return elementBySelector(`.${className}`);\n    };\n    /**\n   * @returns {HTMLElement | null}\n   */ const getPopup = ()=>elementByClass(swalClasses.popup);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getIcon = ()=>elementByClass(swalClasses.icon);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getIconContent = ()=>elementByClass(swalClasses[\"icon-content\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getTitle = ()=>elementByClass(swalClasses.title);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getHtmlContainer = ()=>elementByClass(swalClasses[\"html-container\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getImage = ()=>elementByClass(swalClasses.image);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getProgressSteps = ()=>elementByClass(swalClasses[\"progress-steps\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getValidationMessage = ()=>elementByClass(swalClasses[\"validation-message\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getConfirmButton = ()=>elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getDenyButton = ()=>elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getInputLabel = ()=>elementByClass(swalClasses[\"input-label\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getLoader = ()=>elementBySelector(`.${swalClasses.loader}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getCancelButton = ()=>elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getActions = ()=>elementByClass(swalClasses.actions);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getFooter = ()=>elementByClass(swalClasses.footer);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getTimerProgressBar = ()=>elementByClass(swalClasses[\"timer-progress-bar\"]);\n    /**\n   * @returns {HTMLElement | null}\n   */ const getCloseButton = ()=>elementByClass(swalClasses.close);\n    // https://github.com/jkup/focusable/blob/master/index.js\n    const focusable = `\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex=\"0\"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n`;\n    /**\n   * @returns {HTMLElement[]}\n   */ const getFocusableElements = ()=>{\n        const focusableElementsWithTabindex = Array.from(getPopup().querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])'))// sort according to tabindex\n        .sort((a, b)=>{\n            const tabindexA = parseInt(a.getAttribute(\"tabindex\"));\n            const tabindexB = parseInt(b.getAttribute(\"tabindex\"));\n            if (tabindexA > tabindexB) {\n                return 1;\n            } else if (tabindexA < tabindexB) {\n                return -1;\n            }\n            return 0;\n        });\n        const otherFocusableElements = Array.from(getPopup().querySelectorAll(focusable)).filter((el)=>el.getAttribute(\"tabindex\") !== \"-1\");\n        return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter((el)=>isVisible$1(el));\n    };\n    /**\n   * @returns {boolean}\n   */ const isModal = ()=>{\n        return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n    };\n    /**\n   * @returns {boolean}\n   */ const isToast = ()=>{\n        return getPopup() && hasClass(getPopup(), swalClasses.toast);\n    };\n    /**\n   * @returns {boolean}\n   */ const isLoading = ()=>{\n        return getPopup().hasAttribute(\"data-loading\");\n    };\n    // Remember state in cases where opening and handling a modal will fiddle with it.\n    const states = {\n        previousBodyPadding: null\n    };\n    /**\n   * Securely set innerHTML of an element\n   * https://github.com/sweetalert2/sweetalert2/issues/1926\n   *\n   * @param {HTMLElement} elem\n   * @param {string} html\n   */ const setInnerHtml = (elem, html)=>{\n        elem.textContent = \"\";\n        if (html) {\n            const parser = new DOMParser();\n            const parsed = parser.parseFromString(html, `text/html`);\n            Array.from(parsed.querySelector(\"head\").childNodes).forEach((child)=>{\n                elem.appendChild(child);\n            });\n            Array.from(parsed.querySelector(\"body\").childNodes).forEach((child)=>{\n                if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {\n                    elem.appendChild(child.cloneNode(true)); // https://github.com/sweetalert2/sweetalert2/issues/2507\n                } else {\n                    elem.appendChild(child);\n                }\n            });\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {boolean}\n   */ const hasClass = (elem, className)=>{\n        if (!className) {\n            return false;\n        }\n        const classList = className.split(/\\s+/);\n        for(let i = 0; i < classList.length; i++){\n            if (!elem.classList.contains(classList[i])) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   */ const removeCustomClasses = (elem, params)=>{\n        Array.from(elem.classList).forEach((className)=>{\n            if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {\n                elem.classList.remove(className);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {SweetAlertOptions} params\n   * @param {string} className\n   */ const applyCustomClass = (elem, params, className)=>{\n        removeCustomClasses(elem, params);\n        if (params.customClass && params.customClass[className]) {\n            if (typeof params.customClass[className] !== \"string\" && !params.customClass[className].forEach) {\n                warn(`Invalid type of customClass.${className}! Expected string or iterable object, got \"${typeof params.customClass[className]}\"`);\n                return;\n            }\n            addClass(elem, params.customClass[className]);\n        }\n    };\n    /**\n   * @param {HTMLElement} popup\n   * @param {import('./renderers/renderInput').InputClass} inputClass\n   * @returns {HTMLInputElement | null}\n   */ const getInput$1 = (popup, inputClass)=>{\n        if (!inputClass) {\n            return null;\n        }\n        switch(inputClass){\n            case \"select\":\n            case \"textarea\":\n            case \"file\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);\n            case \"checkbox\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);\n            case \"radio\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);\n            case \"range\":\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);\n            default:\n                return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);\n        }\n    };\n    /**\n   * @param {HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement} input\n   */ const focusInput = (input)=>{\n        input.focus();\n        // place cursor at end of text in text input\n        if (input.type !== \"file\") {\n            // http://stackoverflow.com/a/2345915\n            const val = input.value;\n            input.value = \"\";\n            input.value = val;\n        }\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   * @param {boolean} condition\n   */ const toggleClass = (target, classList, condition)=>{\n        if (!target || !classList) {\n            return;\n        }\n        if (typeof classList === \"string\") {\n            classList = classList.split(/\\s+/).filter(Boolean);\n        }\n        classList.forEach((className)=>{\n            if (Array.isArray(target)) {\n                target.forEach((elem)=>{\n                    condition ? elem.classList.add(className) : elem.classList.remove(className);\n                });\n            } else {\n                condition ? target.classList.add(className) : target.classList.remove(className);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */ const addClass = (target, classList)=>{\n        toggleClass(target, classList, true);\n    };\n    /**\n   * @param {HTMLElement | HTMLElement[] | null} target\n   * @param {string | string[] | readonly string[]} classList\n   */ const removeClass = (target, classList)=>{\n        toggleClass(target, classList, false);\n    };\n    /**\n   * Get direct child of an element by class name\n   *\n   * @param {HTMLElement} elem\n   * @param {string} className\n   * @returns {HTMLElement | undefined}\n   */ const getDirectChildByClass = (elem, className)=>{\n        const children = Array.from(elem.children);\n        for(let i = 0; i < children.length; i++){\n            const child = children[i];\n            if (child instanceof HTMLElement && hasClass(child, className)) {\n                return child;\n            }\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} property\n   * @param {*} value\n   */ const applyNumericalStyle = (elem, property, value)=>{\n        if (value === `${parseInt(value)}`) {\n            value = parseInt(value);\n        }\n        if (value || parseInt(value) === 0) {\n            elem.style[property] = typeof value === \"number\" ? `${value}px` : value;\n        } else {\n            elem.style.removeProperty(property);\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {string} display\n   */ const show = function(elem) {\n        let display = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"flex\";\n        elem.style.display = display;\n    };\n    /**\n   * @param {HTMLElement} elem\n   */ const hide = (elem)=>{\n        elem.style.display = \"none\";\n    };\n    /**\n   * @param {HTMLElement} parent\n   * @param {string} selector\n   * @param {string} property\n   * @param {string} value\n   */ const setStyle = (parent, selector, property, value)=>{\n        /** @type {HTMLElement} */ const el = parent.querySelector(selector);\n        if (el) {\n            el.style[property] = value;\n        }\n    };\n    /**\n   * @param {HTMLElement} elem\n   * @param {any} condition\n   * @param {string} display\n   */ const toggle = function(elem, condition) {\n        let display = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"flex\";\n        condition ? show(elem, display) : hide(elem);\n    };\n    /**\n   * borrowed from jquery $(elem).is(':visible') implementation\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const isVisible$1 = (elem)=>!!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n    /**\n   * @returns {boolean}\n   */ const allButtonsAreHidden = ()=>!isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());\n    /**\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const isScrollable = (elem)=>!!(elem.scrollHeight > elem.clientHeight);\n    /**\n   * borrowed from https://stackoverflow.com/a/46352119\n   *\n   * @param {HTMLElement} elem\n   * @returns {boolean}\n   */ const hasCssAnimation = (elem)=>{\n        const style = window.getComputedStyle(elem);\n        const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n        const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n        return animDuration > 0 || transDuration > 0;\n    };\n    /**\n   * @param {number} timer\n   * @param {boolean} reset\n   */ const animateTimerProgressBar = function(timer) {\n        let reset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        const timerProgressBar = getTimerProgressBar();\n        if (isVisible$1(timerProgressBar)) {\n            if (reset) {\n                timerProgressBar.style.transition = \"none\";\n                timerProgressBar.style.width = \"100%\";\n            }\n            setTimeout(()=>{\n                timerProgressBar.style.transition = `width ${timer / 1000}s linear`;\n                timerProgressBar.style.width = \"0%\";\n            }, 10);\n        }\n    };\n    const stopTimerProgressBar = ()=>{\n        const timerProgressBar = getTimerProgressBar();\n        const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n        timerProgressBar.style.removeProperty(\"transition\");\n        timerProgressBar.style.width = \"100%\";\n        const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n        const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n        timerProgressBar.style.removeProperty(\"transition\");\n        timerProgressBar.style.width = `${timerProgressBarPercent}%`;\n    };\n    const RESTORE_FOCUS_TIMEOUT = 100;\n    /** @type {GlobalState} */ const globalState = {};\n    const focusPreviousActiveElement = ()=>{\n        if (globalState.previousActiveElement instanceof HTMLElement) {\n            globalState.previousActiveElement.focus();\n            globalState.previousActiveElement = null;\n        } else if (document.body) {\n            document.body.focus();\n        }\n    };\n    /**\n   * Restore previous active (focused) element\n   *\n   * @param {boolean} returnFocus\n   * @returns {Promise}\n   */ const restoreActiveElement = (returnFocus)=>{\n        return new Promise((resolve)=>{\n            if (!returnFocus) {\n                return resolve();\n            }\n            const x = window.scrollX;\n            const y = window.scrollY;\n            globalState.restoreFocusTimeout = setTimeout(()=>{\n                focusPreviousActiveElement();\n                resolve();\n            }, RESTORE_FOCUS_TIMEOUT); // issues/900\n            window.scrollTo(x, y);\n        });\n    };\n    /**\n   * Detect Node env\n   *\n   * @returns {boolean}\n   */ const isNodeEnv = ()=> true || 0;\n    const sweetHTML = `\n <div aria-labelledby=\"${swalClasses.title}\" aria-describedby=\"${swalClasses[\"html-container\"]}\" class=\"${swalClasses.popup}\" tabindex=\"-1\">\n   <button type=\"button\" class=\"${swalClasses.close}\"></button>\n   <ul class=\"${swalClasses[\"progress-steps\"]}\"></ul>\n   <div class=\"${swalClasses.icon}\"></div>\n   <img class=\"${swalClasses.image}\" />\n   <h2 class=\"${swalClasses.title}\" id=\"${swalClasses.title}\"></h2>\n   <div class=\"${swalClasses[\"html-container\"]}\" id=\"${swalClasses[\"html-container\"]}\"></div>\n   <input class=\"${swalClasses.input}\" />\n   <input type=\"file\" class=\"${swalClasses.file}\" />\n   <div class=\"${swalClasses.range}\">\n     <input type=\"range\" />\n     <output></output>\n   </div>\n   <select class=\"${swalClasses.select}\"></select>\n   <div class=\"${swalClasses.radio}\"></div>\n   <label for=\"${swalClasses.checkbox}\" class=\"${swalClasses.checkbox}\">\n     <input type=\"checkbox\" />\n     <span class=\"${swalClasses.label}\"></span>\n   </label>\n   <textarea class=\"${swalClasses.textarea}\"></textarea>\n   <div class=\"${swalClasses[\"validation-message\"]}\" id=\"${swalClasses[\"validation-message\"]}\"></div>\n   <div class=\"${swalClasses.actions}\">\n     <div class=\"${swalClasses.loader}\"></div>\n     <button type=\"button\" class=\"${swalClasses.confirm}\"></button>\n     <button type=\"button\" class=\"${swalClasses.deny}\"></button>\n     <button type=\"button\" class=\"${swalClasses.cancel}\"></button>\n   </div>\n   <div class=\"${swalClasses.footer}\"></div>\n   <div class=\"${swalClasses[\"timer-progress-bar-container\"]}\">\n     <div class=\"${swalClasses[\"timer-progress-bar\"]}\"></div>\n   </div>\n </div>\n`.replace(/(^|\\n)\\s*/g, \"\");\n    /**\n   * @returns {boolean}\n   */ const resetOldContainer = ()=>{\n        const oldContainer = getContainer();\n        if (!oldContainer) {\n            return false;\n        }\n        oldContainer.remove();\n        removeClass([\n            document.documentElement,\n            document.body\n        ], [\n            swalClasses[\"no-backdrop\"],\n            swalClasses[\"toast-shown\"],\n            swalClasses[\"has-column\"]\n        ]);\n        return true;\n    };\n    const resetValidationMessage$1 = ()=>{\n        globalState.currentInstance.resetValidationMessage();\n    };\n    const addInputChangeListeners = ()=>{\n        const popup = getPopup();\n        const input = getDirectChildByClass(popup, swalClasses.input);\n        const file = getDirectChildByClass(popup, swalClasses.file);\n        /** @type {HTMLInputElement} */ const range = popup.querySelector(`.${swalClasses.range} input`);\n        /** @type {HTMLOutputElement} */ const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);\n        const select = getDirectChildByClass(popup, swalClasses.select);\n        /** @type {HTMLInputElement} */ const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);\n        const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n        input.oninput = resetValidationMessage$1;\n        file.onchange = resetValidationMessage$1;\n        select.onchange = resetValidationMessage$1;\n        checkbox.onchange = resetValidationMessage$1;\n        textarea.oninput = resetValidationMessage$1;\n        range.oninput = ()=>{\n            resetValidationMessage$1();\n            rangeOutput.value = range.value;\n        };\n        range.onchange = ()=>{\n            resetValidationMessage$1();\n            rangeOutput.value = range.value;\n        };\n    };\n    /**\n   * @param {string | HTMLElement} target\n   * @returns {HTMLElement}\n   */ const getTarget = (target)=>typeof target === \"string\" ? document.querySelector(target) : target;\n    /**\n   * @param {SweetAlertOptions} params\n   */ const setupAccessibility = (params)=>{\n        const popup = getPopup();\n        popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n        popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n        if (!params.toast) {\n            popup.setAttribute(\"aria-modal\", \"true\");\n        }\n    };\n    /**\n   * @param {HTMLElement} targetElement\n   */ const setupRTL = (targetElement)=>{\n        if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n            addClass(getContainer(), swalClasses.rtl);\n        }\n    };\n    /**\n   * Add modal + backdrop + no-war message for Russians to DOM\n   *\n   * @param {SweetAlertOptions} params\n   */ const init = (params)=>{\n        // Clean up the old popup container if it exists\n        const oldContainerExisted = resetOldContainer();\n        /* istanbul ignore if */ if (isNodeEnv()) {\n            error(\"SweetAlert2 requires document to initialize\");\n            return;\n        }\n        const container = document.createElement(\"div\");\n        container.className = swalClasses.container;\n        if (oldContainerExisted) {\n            addClass(container, swalClasses[\"no-transition\"]);\n        }\n        setInnerHtml(container, sweetHTML);\n        const targetElement = getTarget(params.target);\n        targetElement.appendChild(container);\n        setupAccessibility(params);\n        setupRTL(targetElement);\n        addInputChangeListeners();\n    };\n    /**\n   * @param {HTMLElement | object | string} param\n   * @param {HTMLElement} target\n   */ const parseHtmlToContainer = (param, target)=>{\n        // DOM element\n        if (param instanceof HTMLElement) {\n            target.appendChild(param);\n        } else if (typeof param === \"object\") {\n            handleObject(param, target);\n        } else if (param) {\n            setInnerHtml(target, param);\n        }\n    };\n    /**\n   * @param {object} param\n   * @param {HTMLElement} target\n   */ const handleObject = (param, target)=>{\n        // JQuery element(s)\n        if (param.jquery) {\n            handleJqueryElem(target, param);\n        } else {\n            setInnerHtml(target, param.toString());\n        }\n    };\n    /**\n   * @param {HTMLElement} target\n   * @param {HTMLElement} elem\n   */ const handleJqueryElem = (target, elem)=>{\n        target.textContent = \"\";\n        if (0 in elem) {\n            for(let i = 0; (i in elem); i++){\n                target.appendChild(elem[i].cloneNode(true));\n            }\n        } else {\n            target.appendChild(elem.cloneNode(true));\n        }\n    };\n    /**\n   * @returns {'webkitAnimationEnd' | 'animationend' | false}\n   */ const animationEndEvent = (()=>{\n        // Prevent run in Node env\n        /* istanbul ignore if */ if (isNodeEnv()) {\n            return false;\n        }\n        const testEl = document.createElement(\"div\");\n        const transEndEventNames = {\n            WebkitAnimation: \"webkitAnimationEnd\",\n            // Chrome, Safari and Opera\n            animation: \"animationend\" // Standard syntax\n        };\n        for(const i in transEndEventNames){\n            if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== \"undefined\") {\n                return transEndEventNames[i];\n            }\n        }\n        return false;\n    })();\n    /**\n   * Measure scrollbar width for padding body during modal show/hide\n   * https://github.com/twbs/bootstrap/blob/master/js/src/modal.js\n   *\n   * @returns {number}\n   */ const measureScrollbar = ()=>{\n        const scrollDiv = document.createElement(\"div\");\n        scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n        document.body.appendChild(scrollDiv);\n        const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n        document.body.removeChild(scrollDiv);\n        return scrollbarWidth;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderActions = (instance, params)=>{\n        const actions = getActions();\n        const loader = getLoader();\n        // Actions (buttons) wrapper\n        if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n            hide(actions);\n        } else {\n            show(actions);\n        }\n        // Custom class\n        applyCustomClass(actions, params, \"actions\");\n        // Render all the buttons\n        renderButtons(actions, loader, params);\n        // Loader\n        setInnerHtml(loader, params.loaderHtml);\n        applyCustomClass(loader, params, \"loader\");\n    };\n    /**\n   * @param {HTMLElement} actions\n   * @param {HTMLElement} loader\n   * @param {SweetAlertOptions} params\n   */ function renderButtons(actions, loader, params) {\n        const confirmButton = getConfirmButton();\n        const denyButton = getDenyButton();\n        const cancelButton = getCancelButton();\n        // Render buttons\n        renderButton(confirmButton, \"confirm\", params);\n        renderButton(denyButton, \"deny\", params);\n        renderButton(cancelButton, \"cancel\", params);\n        handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n        if (params.reverseButtons) {\n            if (params.toast) {\n                actions.insertBefore(cancelButton, confirmButton);\n                actions.insertBefore(denyButton, confirmButton);\n            } else {\n                actions.insertBefore(cancelButton, loader);\n                actions.insertBefore(denyButton, loader);\n                actions.insertBefore(confirmButton, loader);\n            }\n        }\n    }\n    /**\n   * @param {HTMLElement} confirmButton\n   * @param {HTMLElement} denyButton\n   * @param {HTMLElement} cancelButton\n   * @param {SweetAlertOptions} params\n   */ function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n        if (!params.buttonsStyling) {\n            removeClass([\n                confirmButton,\n                denyButton,\n                cancelButton\n            ], swalClasses.styled);\n            return;\n        }\n        addClass([\n            confirmButton,\n            denyButton,\n            cancelButton\n        ], swalClasses.styled);\n        // Buttons background colors\n        if (params.confirmButtonColor) {\n            confirmButton.style.backgroundColor = params.confirmButtonColor;\n            addClass(confirmButton, swalClasses[\"default-outline\"]);\n        }\n        if (params.denyButtonColor) {\n            denyButton.style.backgroundColor = params.denyButtonColor;\n            addClass(denyButton, swalClasses[\"default-outline\"]);\n        }\n        if (params.cancelButtonColor) {\n            cancelButton.style.backgroundColor = params.cancelButtonColor;\n            addClass(cancelButton, swalClasses[\"default-outline\"]);\n        }\n    }\n    /**\n   * @param {HTMLElement} button\n   * @param {'confirm' | 'deny' | 'cancel'} buttonType\n   * @param {SweetAlertOptions} params\n   */ function renderButton(button, buttonType, params) {\n        toggle(button, params[`show${capitalizeFirstLetter(buttonType)}Button`], \"inline-block\");\n        setInnerHtml(button, params[`${buttonType}ButtonText`]); // Set caption text\n        button.setAttribute(\"aria-label\", params[`${buttonType}ButtonAriaLabel`]); // ARIA label\n        // Add buttons custom classes\n        button.className = swalClasses[buttonType];\n        applyCustomClass(button, params, `${buttonType}Button`);\n        addClass(button, params[`${buttonType}ButtonClass`]);\n    }\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderCloseButton = (instance, params)=>{\n        const closeButton = getCloseButton();\n        setInnerHtml(closeButton, params.closeButtonHtml);\n        // Custom class\n        applyCustomClass(closeButton, params, \"closeButton\");\n        toggle(closeButton, params.showCloseButton);\n        closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderContainer = (instance, params)=>{\n        const container = getContainer();\n        if (!container) {\n            return;\n        }\n        handleBackdropParam(container, params.backdrop);\n        handlePositionParam(container, params.position);\n        handleGrowParam(container, params.grow);\n        // Custom class\n        applyCustomClass(container, params, \"container\");\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['backdrop']} backdrop\n   */ function handleBackdropParam(container, backdrop) {\n        if (typeof backdrop === \"string\") {\n            container.style.background = backdrop;\n        } else if (!backdrop) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"no-backdrop\"]);\n        }\n    }\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['position']} position\n   */ function handlePositionParam(container, position) {\n        if (position in swalClasses) {\n            addClass(container, swalClasses[position]);\n        } else {\n            warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n            addClass(container, swalClasses.center);\n        }\n    }\n    /**\n   * @param {HTMLElement} container\n   * @param {SweetAlertOptions['grow']} grow\n   */ function handleGrowParam(container, grow) {\n        if (grow && typeof grow === \"string\") {\n            const growClass = `grow-${grow}`;\n            if (growClass in swalClasses) {\n                addClass(container, swalClasses[growClass]);\n            }\n        }\n    }\n    /// <reference path=\"../../../../sweetalert2.d.ts\"/>\n    /** @type {InputClass[]} */ const inputClasses = [\n        \"input\",\n        \"file\",\n        \"range\",\n        \"select\",\n        \"radio\",\n        \"checkbox\",\n        \"textarea\"\n    ];\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderInput = (instance, params)=>{\n        const popup = getPopup();\n        const innerParams = privateProps.innerParams.get(instance);\n        const rerender = !innerParams || params.input !== innerParams.input;\n        inputClasses.forEach((inputClass)=>{\n            const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);\n            // set attributes\n            setAttributes(inputClass, params.inputAttributes);\n            // set class\n            inputContainer.className = swalClasses[inputClass];\n            if (rerender) {\n                hide(inputContainer);\n            }\n        });\n        if (params.input) {\n            if (rerender) {\n                showInput(params);\n            }\n            // set custom class\n            setCustomClass(params);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ const showInput = (params)=>{\n        if (!renderInputType[params.input]) {\n            error(`Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"${params.input}\"`);\n            return;\n        }\n        const inputContainer = getInputContainer(params.input);\n        const input = renderInputType[params.input](inputContainer, params);\n        show(inputContainer);\n        // input autofocus\n        setTimeout(()=>{\n            focusInput(input);\n        });\n    };\n    /**\n   * @param {HTMLInputElement} input\n   */ const removeAttributes = (input)=>{\n        for(let i = 0; i < input.attributes.length; i++){\n            const attrName = input.attributes[i].name;\n            if (![\n                \"type\",\n                \"value\",\n                \"style\"\n            ].includes(attrName)) {\n                input.removeAttribute(attrName);\n            }\n        }\n    };\n    /**\n   * @param {InputClass} inputClass\n   * @param {SweetAlertOptions['inputAttributes']} inputAttributes\n   */ const setAttributes = (inputClass, inputAttributes)=>{\n        const input = getInput$1(getPopup(), inputClass);\n        if (!input) {\n            return;\n        }\n        removeAttributes(input);\n        for(const attr in inputAttributes){\n            input.setAttribute(attr, inputAttributes[attr]);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ const setCustomClass = (params)=>{\n        const inputContainer = getInputContainer(params.input);\n        if (typeof params.customClass === \"object\") {\n            addClass(inputContainer, params.customClass.input);\n        }\n    };\n    /**\n   * @param {HTMLInputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions} params\n   */ const setInputPlaceholder = (input, params)=>{\n        if (!input.placeholder || params.inputPlaceholder) {\n            input.placeholder = params.inputPlaceholder;\n        }\n    };\n    /**\n   * @param {Input} input\n   * @param {Input} prependTo\n   * @param {SweetAlertOptions} params\n   */ const setInputLabel = (input, prependTo, params)=>{\n        if (params.inputLabel) {\n            input.id = swalClasses.input;\n            const label = document.createElement(\"label\");\n            const labelClass = swalClasses[\"input-label\"];\n            label.setAttribute(\"for\", input.id);\n            label.className = labelClass;\n            if (typeof params.customClass === \"object\") {\n                addClass(label, params.customClass.inputLabel);\n            }\n            label.innerText = params.inputLabel;\n            prependTo.insertAdjacentElement(\"beforebegin\", label);\n        }\n    };\n    /**\n   * @param {SweetAlertOptions['input']} inputType\n   * @returns {HTMLElement}\n   */ const getInputContainer = (inputType)=>{\n        return getDirectChildByClass(getPopup(), swalClasses[inputType] || swalClasses.input);\n    };\n    /**\n   * @param {HTMLInputElement | HTMLOutputElement | HTMLTextAreaElement} input\n   * @param {SweetAlertOptions['inputValue']} inputValue\n   */ const checkAndSetInputValue = (input, inputValue)=>{\n        if ([\n            \"string\",\n            \"number\"\n        ].includes(typeof inputValue)) {\n            input.value = `${inputValue}`;\n        } else if (!isPromise(inputValue)) {\n            warn(`Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"${typeof inputValue}\"`);\n        }\n    };\n    /** @type {Record<string, (input: Input | HTMLElement, params: SweetAlertOptions) => Input>} */ const renderInputType = {};\n    /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params)=>{\n        checkAndSetInputValue(input, params.inputValue);\n        setInputLabel(input, input, params);\n        setInputPlaceholder(input, params);\n        input.type = params.input;\n        return input;\n    };\n    /**\n   * @param {HTMLInputElement} input\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.file = (input, params)=>{\n        setInputLabel(input, input, params);\n        setInputPlaceholder(input, params);\n        return input;\n    };\n    /**\n   * @param {HTMLInputElement} range\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.range = (range, params)=>{\n        const rangeInput = range.querySelector(\"input\");\n        const rangeOutput = range.querySelector(\"output\");\n        checkAndSetInputValue(rangeInput, params.inputValue);\n        rangeInput.type = params.input;\n        checkAndSetInputValue(rangeOutput, params.inputValue);\n        setInputLabel(rangeInput, range, params);\n        return range;\n    };\n    /**\n   * @param {HTMLSelectElement} select\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLSelectElement}\n   */ renderInputType.select = (select, params)=>{\n        select.textContent = \"\";\n        if (params.inputPlaceholder) {\n            const placeholder = document.createElement(\"option\");\n            setInnerHtml(placeholder, params.inputPlaceholder);\n            placeholder.value = \"\";\n            placeholder.disabled = true;\n            placeholder.selected = true;\n            select.appendChild(placeholder);\n        }\n        setInputLabel(select, select, params);\n        return select;\n    };\n    /**\n   * @param {HTMLInputElement} radio\n   * @returns {HTMLInputElement}\n   */ renderInputType.radio = (radio)=>{\n        radio.textContent = \"\";\n        return radio;\n    };\n    /**\n   * @param {HTMLLabelElement} checkboxContainer\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLInputElement}\n   */ renderInputType.checkbox = (checkboxContainer, params)=>{\n        const checkbox = getInput$1(getPopup(), \"checkbox\");\n        checkbox.value = \"1\";\n        checkbox.id = swalClasses.checkbox;\n        checkbox.checked = Boolean(params.inputValue);\n        const label = checkboxContainer.querySelector(\"span\");\n        setInnerHtml(label, params.inputPlaceholder);\n        return checkbox;\n    };\n    /**\n   * @param {HTMLTextAreaElement} textarea\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLTextAreaElement}\n   */ renderInputType.textarea = (textarea, params)=>{\n        checkAndSetInputValue(textarea, params.inputValue);\n        setInputPlaceholder(textarea, params);\n        setInputLabel(textarea, textarea, params);\n        /**\n     * @param {HTMLElement} el\n     * @returns {number}\n     */ const getMargin = (el)=>parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n        // https://github.com/sweetalert2/sweetalert2/issues/2291\n        setTimeout(()=>{\n            // https://github.com/sweetalert2/sweetalert2/issues/1699\n            if (\"MutationObserver\" in window) {\n                const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n                const textareaResizeHandler = ()=>{\n                    const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n                    if (textareaWidth > initialPopupWidth) {\n                        getPopup().style.width = `${textareaWidth}px`;\n                    } else {\n                        getPopup().style.width = null;\n                    }\n                };\n                new MutationObserver(textareaResizeHandler).observe(textarea, {\n                    attributes: true,\n                    attributeFilter: [\n                        \"style\"\n                    ]\n                });\n            }\n        });\n        return textarea;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderContent = (instance, params)=>{\n        const htmlContainer = getHtmlContainer();\n        applyCustomClass(htmlContainer, params, \"htmlContainer\");\n        // Content as HTML\n        if (params.html) {\n            parseHtmlToContainer(params.html, htmlContainer);\n            show(htmlContainer, \"block\");\n        } else if (params.text) {\n            htmlContainer.textContent = params.text;\n            show(htmlContainer, \"block\");\n        } else {\n            hide(htmlContainer);\n        }\n        renderInput(instance, params);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderFooter = (instance, params)=>{\n        const footer = getFooter();\n        toggle(footer, params.footer);\n        if (params.footer) {\n            parseHtmlToContainer(params.footer, footer);\n        }\n        // Custom class\n        applyCustomClass(footer, params, \"footer\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderIcon = (instance, params)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        const icon = getIcon();\n        // if the given icon already rendered, apply the styling without re-rendering the icon\n        if (innerParams && params.icon === innerParams.icon) {\n            // Custom or default content\n            setContent(icon, params);\n            applyStyles(icon, params);\n            return;\n        }\n        if (!params.icon && !params.iconHtml) {\n            hide(icon);\n            return;\n        }\n        if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n            error(`Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"${params.icon}\"`);\n            hide(icon);\n            return;\n        }\n        show(icon);\n        // Custom or default content\n        setContent(icon, params);\n        applyStyles(icon, params);\n        // Animate icon\n        addClass(icon, params.showClass.icon);\n    };\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const applyStyles = (icon, params)=>{\n        for(const iconType in iconTypes){\n            if (params.icon !== iconType) {\n                removeClass(icon, iconTypes[iconType]);\n            }\n        }\n        addClass(icon, iconTypes[params.icon]);\n        // Icon color\n        setColor(icon, params);\n        // Success icon background color\n        adjustSuccessIconBackgroundColor();\n        // Custom class\n        applyCustomClass(icon, params, \"icon\");\n    };\n    // Adjust success icon background color to match the popup background color\n    const adjustSuccessIconBackgroundColor = ()=>{\n        const popup = getPopup();\n        const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n        /** @type {NodeListOf<HTMLElement>} */ const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n        for(let i = 0; i < successIconParts.length; i++){\n            successIconParts[i].style.backgroundColor = popupBackgroundColor;\n        }\n    };\n    const successIconHtml = `\n  <div class=\"swal2-success-circular-line-left\"></div>\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\n  <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\n  <div class=\"swal2-success-circular-line-right\"></div>\n`;\n    const errorIconHtml = `\n  <span class=\"swal2-x-mark\">\n    <span class=\"swal2-x-mark-line-left\"></span>\n    <span class=\"swal2-x-mark-line-right\"></span>\n  </span>\n`;\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const setContent = (icon, params)=>{\n        let oldContent = icon.innerHTML;\n        let newContent;\n        if (params.iconHtml) {\n            newContent = iconContent(params.iconHtml);\n        } else if (params.icon === \"success\") {\n            newContent = successIconHtml;\n            oldContent = oldContent.replace(/ style=\".*?\"/g, \"\"); // undo adjustSuccessIconBackgroundColor()\n        } else if (params.icon === \"error\") {\n            newContent = errorIconHtml;\n        } else {\n            const defaultIconHtml = {\n                question: \"?\",\n                warning: \"!\",\n                info: \"i\"\n            };\n            newContent = iconContent(defaultIconHtml[params.icon]);\n        }\n        if (oldContent.trim() !== newContent.trim()) {\n            setInnerHtml(icon, newContent);\n        }\n    };\n    /**\n   * @param {HTMLElement} icon\n   * @param {SweetAlertOptions} params\n   */ const setColor = (icon, params)=>{\n        if (!params.iconColor) {\n            return;\n        }\n        icon.style.color = params.iconColor;\n        icon.style.borderColor = params.iconColor;\n        for (const sel of [\n            \".swal2-success-line-tip\",\n            \".swal2-success-line-long\",\n            \".swal2-x-mark-line-left\",\n            \".swal2-x-mark-line-right\"\n        ]){\n            setStyle(icon, sel, \"backgroundColor\", params.iconColor);\n        }\n        setStyle(icon, \".swal2-success-ring\", \"borderColor\", params.iconColor);\n    };\n    /**\n   * @param {string} content\n   * @returns {string}\n   */ const iconContent = (content)=>`<div class=\"${swalClasses[\"icon-content\"]}\">${content}</div>`;\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderImage = (instance, params)=>{\n        const image = getImage();\n        if (!params.imageUrl) {\n            hide(image);\n            return;\n        }\n        show(image, \"\");\n        // Src, alt\n        image.setAttribute(\"src\", params.imageUrl);\n        image.setAttribute(\"alt\", params.imageAlt);\n        // Width, height\n        applyNumericalStyle(image, \"width\", params.imageWidth);\n        applyNumericalStyle(image, \"height\", params.imageHeight);\n        // Class\n        image.className = swalClasses.image;\n        applyCustomClass(image, params, \"image\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderPopup = (instance, params)=>{\n        const container = getContainer();\n        const popup = getPopup();\n        // Width\n        // https://github.com/sweetalert2/sweetalert2/issues/2170\n        if (params.toast) {\n            applyNumericalStyle(container, \"width\", params.width);\n            popup.style.width = \"100%\";\n            popup.insertBefore(getLoader(), getIcon());\n        } else {\n            applyNumericalStyle(popup, \"width\", params.width);\n        }\n        // Padding\n        applyNumericalStyle(popup, \"padding\", params.padding);\n        // Color\n        if (params.color) {\n            popup.style.color = params.color;\n        }\n        // Background\n        if (params.background) {\n            popup.style.background = params.background;\n        }\n        hide(getValidationMessage());\n        // Classes\n        addClasses$1(popup, params);\n    };\n    /**\n   * @param {HTMLElement} popup\n   * @param {SweetAlertOptions} params\n   */ const addClasses$1 = (popup, params)=>{\n        // Default Class + showClass when updating Swal.update({})\n        popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? params.showClass.popup : \"\"}`;\n        if (params.toast) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"toast-shown\"]);\n            addClass(popup, swalClasses.toast);\n        } else {\n            addClass(popup, swalClasses.modal);\n        }\n        // Custom class\n        applyCustomClass(popup, params, \"popup\");\n        if (typeof params.customClass === \"string\") {\n            addClass(popup, params.customClass);\n        }\n        // Icon class (#1842)\n        if (params.icon) {\n            addClass(popup, swalClasses[`icon-${params.icon}`]);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderProgressSteps = (instance, params)=>{\n        const progressStepsContainer = getProgressSteps();\n        if (!params.progressSteps || params.progressSteps.length === 0) {\n            hide(progressStepsContainer);\n            return;\n        }\n        show(progressStepsContainer);\n        progressStepsContainer.textContent = \"\";\n        if (params.currentProgressStep >= params.progressSteps.length) {\n            warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length \" + \"(currentProgressStep like JS arrays starts from 0)\");\n        }\n        params.progressSteps.forEach((step, index)=>{\n            const stepEl = createStepElement(step);\n            progressStepsContainer.appendChild(stepEl);\n            if (index === params.currentProgressStep) {\n                addClass(stepEl, swalClasses[\"active-progress-step\"]);\n            }\n            if (index !== params.progressSteps.length - 1) {\n                const lineEl = createLineElement(params);\n                progressStepsContainer.appendChild(lineEl);\n            }\n        });\n    };\n    /**\n   * @param {string} step\n   * @returns {HTMLLIElement}\n   */ const createStepElement = (step)=>{\n        const stepEl = document.createElement(\"li\");\n        addClass(stepEl, swalClasses[\"progress-step\"]);\n        setInnerHtml(stepEl, step);\n        return stepEl;\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {HTMLLIElement}\n   */ const createLineElement = (params)=>{\n        const lineEl = document.createElement(\"li\");\n        addClass(lineEl, swalClasses[\"progress-step-line\"]);\n        if (params.progressStepsDistance) {\n            applyNumericalStyle(lineEl, \"width\", params.progressStepsDistance);\n        }\n        return lineEl;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const renderTitle = (instance, params)=>{\n        const title = getTitle();\n        toggle(title, params.title || params.titleText, \"block\");\n        if (params.title) {\n            parseHtmlToContainer(params.title, title);\n        }\n        if (params.titleText) {\n            title.innerText = params.titleText;\n        }\n        // Custom class\n        applyCustomClass(title, params, \"title\");\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const render = (instance, params)=>{\n        renderPopup(instance, params);\n        renderContainer(instance, params);\n        renderProgressSteps(instance, params);\n        renderIcon(instance, params);\n        renderImage(instance, params);\n        renderTitle(instance, params);\n        renderCloseButton(instance, params);\n        renderContent(instance, params);\n        renderActions(instance, params);\n        renderFooter(instance, params);\n        if (typeof params.didRender === \"function\") {\n            params.didRender(getPopup());\n        }\n    };\n    /**\n   * Hides loader and shows back the button which was hidden by .showLoading()\n   */ function hideLoading() {\n        // do nothing if popup is closed\n        const innerParams = privateProps.innerParams.get(this);\n        if (!innerParams) {\n            return;\n        }\n        const domCache = privateProps.domCache.get(this);\n        hide(domCache.loader);\n        if (isToast()) {\n            if (innerParams.icon) {\n                show(getIcon());\n            }\n        } else {\n            showRelatedButton(domCache);\n        }\n        removeClass([\n            domCache.popup,\n            domCache.actions\n        ], swalClasses.loading);\n        domCache.popup.removeAttribute(\"aria-busy\");\n        domCache.popup.removeAttribute(\"data-loading\");\n        domCache.confirmButton.disabled = false;\n        domCache.denyButton.disabled = false;\n        domCache.cancelButton.disabled = false;\n    }\n    const showRelatedButton = (domCache)=>{\n        const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n        if (buttonToReplace.length) {\n            show(buttonToReplace[0], \"inline-block\");\n        } else if (allButtonsAreHidden()) {\n            hide(domCache.actions);\n        }\n    };\n    /**\n   * Gets the input DOM node, this method works with input parameter.\n   *\n   * @param {SweetAlert2} instance\n   * @returns {HTMLElement | null}\n   */ function getInput(instance) {\n        const innerParams = privateProps.innerParams.get(instance || this);\n        const domCache = privateProps.domCache.get(instance || this);\n        if (!domCache) {\n            return null;\n        }\n        return getInput$1(domCache.popup, innerParams.input);\n    }\n    /*\n   * Global function to determine if SweetAlert2 popup is shown\n   */ const isVisible = ()=>{\n        return isVisible$1(getPopup());\n    };\n    /*\n   * Global function to click 'Confirm' button\n   */ const clickConfirm = ()=>getConfirmButton() && getConfirmButton().click();\n    /*\n   * Global function to click 'Deny' button\n   */ const clickDeny = ()=>getDenyButton() && getDenyButton().click();\n    /*\n   * Global function to click 'Cancel' button\n   */ const clickCancel = ()=>getCancelButton() && getCancelButton().click();\n    const DismissReason = Object.freeze({\n        cancel: \"cancel\",\n        backdrop: \"backdrop\",\n        close: \"close\",\n        esc: \"esc\",\n        timer: \"timer\"\n    });\n    /**\n   * @param {GlobalState} globalState\n   */ const removeKeydownHandler = (globalState)=>{\n        if (globalState.keydownTarget && globalState.keydownHandlerAdded) {\n            globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n                capture: globalState.keydownListenerCapture\n            });\n            globalState.keydownHandlerAdded = false;\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {*} dismissWith\n   */ const addKeydownHandler = (instance, globalState, innerParams, dismissWith)=>{\n        removeKeydownHandler(globalState);\n        if (!innerParams.toast) {\n            globalState.keydownHandler = (e)=>keydownHandler(instance, e, dismissWith);\n            globalState.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n            globalState.keydownListenerCapture = innerParams.keydownListenerCapture;\n            globalState.keydownTarget.addEventListener(\"keydown\", globalState.keydownHandler, {\n                capture: globalState.keydownListenerCapture\n            });\n            globalState.keydownHandlerAdded = true;\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} innerParams\n   * @param {number} index\n   * @param {number} increment\n   */ const setFocus = (innerParams, index, increment)=>{\n        const focusableElements = getFocusableElements();\n        // search for visible elements and select the next possible match\n        if (focusableElements.length) {\n            index = index + increment;\n            // rollover to first item\n            if (index === focusableElements.length) {\n                index = 0;\n            // go to last item\n            } else if (index === -1) {\n                index = focusableElements.length - 1;\n            }\n            return focusableElements[index].focus();\n        }\n        // no visible focusable elements, focus the popup\n        getPopup().focus();\n    };\n    const arrowKeysNextButton = [\n        \"ArrowRight\",\n        \"ArrowDown\"\n    ];\n    const arrowKeysPreviousButton = [\n        \"ArrowLeft\",\n        \"ArrowUp\"\n    ];\n    /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} e\n   * @param {function} dismissWith\n   */ const keydownHandler = (instance, e, dismissWith)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams) {\n            return; // This instance has already been destroyed\n        }\n        // Ignore keydown during IME composition\n        // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n        // https://github.com/sweetalert2/sweetalert2/issues/720\n        // https://github.com/sweetalert2/sweetalert2/issues/2406\n        if (e.isComposing || e.keyCode === 229) {\n            return;\n        }\n        if (innerParams.stopKeydownPropagation) {\n            e.stopPropagation();\n        }\n        // ENTER\n        if (e.key === \"Enter\") {\n            handleEnter(instance, e, innerParams);\n        } else if (e.key === \"Tab\") {\n            handleTab(e, innerParams);\n        } else if ([\n            ...arrowKeysNextButton,\n            ...arrowKeysPreviousButton\n        ].includes(e.key)) {\n            handleArrows(e.key);\n        } else if (e.key === \"Escape\") {\n            handleEsc(e, innerParams, dismissWith);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   */ const handleEnter = (instance, e, innerParams)=>{\n        // https://github.com/sweetalert2/sweetalert2/issues/2386\n        if (!callIfFunction(innerParams.allowEnterKey)) {\n            return;\n        }\n        if (e.target && instance.getInput() && e.target instanceof HTMLElement && e.target.outerHTML === instance.getInput().outerHTML) {\n            if ([\n                \"textarea\",\n                \"file\"\n            ].includes(innerParams.input)) {\n                return; // do not submit\n            }\n            clickConfirm();\n            e.preventDefault();\n        }\n    };\n    /**\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   */ const handleTab = (e, innerParams)=>{\n        const targetElement = e.target;\n        const focusableElements = getFocusableElements();\n        let btnIndex = -1;\n        for(let i = 0; i < focusableElements.length; i++){\n            if (targetElement === focusableElements[i]) {\n                btnIndex = i;\n                break;\n            }\n        }\n        // Cycle to the next button\n        if (!e.shiftKey) {\n            setFocus(innerParams, btnIndex, 1);\n        } else {\n            setFocus(innerParams, btnIndex, -1);\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    };\n    /**\n   * @param {string} key\n   */ const handleArrows = (key)=>{\n        const confirmButton = getConfirmButton();\n        const denyButton = getDenyButton();\n        const cancelButton = getCancelButton();\n        if (document.activeElement instanceof HTMLElement && ![\n            confirmButton,\n            denyButton,\n            cancelButton\n        ].includes(document.activeElement)) {\n            return;\n        }\n        const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n        let buttonToFocus = document.activeElement;\n        for(let i = 0; i < getActions().children.length; i++){\n            buttonToFocus = buttonToFocus[sibling];\n            if (!buttonToFocus) {\n                return;\n            }\n            if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {\n                break;\n            }\n        }\n        if (buttonToFocus instanceof HTMLButtonElement) {\n            buttonToFocus.focus();\n        }\n    };\n    /**\n   * @param {KeyboardEvent} e\n   * @param {SweetAlertOptions} innerParams\n   * @param {function} dismissWith\n   */ const handleEsc = (e, innerParams, dismissWith)=>{\n        if (callIfFunction(innerParams.allowEscapeKey)) {\n            e.preventDefault();\n            dismissWith(DismissReason.esc);\n        }\n    };\n    /**\n   * This module contains `WeakMap`s for each effectively-\"private  property\" that a `Swal` has.\n   * For example, to set the private property \"foo\" of `this` to \"bar\", you can `privateProps.foo.set(this, 'bar')`\n   * This is the approach that Babel will probably take to implement private methods/fields\n   *   https://github.com/tc39/proposal-private-methods\n   *   https://github.com/babel/babel/pull/7555\n   * Once we have the changes from that PR in Babel, and our core class fits reasonable in *one module*\n   *   then we can use that language feature.\n   */ var privateMethods = {\n        swalPromiseResolve: new WeakMap(),\n        swalPromiseReject: new WeakMap()\n    };\n    // From https://developer.paciellogroup.com/blog/2018/06/the-current-state-of-modal-dialog-accessibility/\n    // Adding aria-hidden=\"true\" to elements outside of the active modal dialog ensures that\n    // elements not within the active modal dialog will not be surfaced if a user opens a screen\n    // reader’s list of elements (headings, form controls, landmarks, etc.) in the document.\n    const setAriaHidden = ()=>{\n        const bodyChildren = Array.from(document.body.children);\n        bodyChildren.forEach((el)=>{\n            if (el === getContainer() || el.contains(getContainer())) {\n                return;\n            }\n            if (el.hasAttribute(\"aria-hidden\")) {\n                el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\"));\n            }\n            el.setAttribute(\"aria-hidden\", \"true\");\n        });\n    };\n    const unsetAriaHidden = ()=>{\n        const bodyChildren = Array.from(document.body.children);\n        bodyChildren.forEach((el)=>{\n            if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n                el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\"));\n                el.removeAttribute(\"data-previous-aria-hidden\");\n            } else {\n                el.removeAttribute(\"aria-hidden\");\n            }\n        });\n    };\n    /* istanbul ignore file */ // Fix iOS scrolling http://stackoverflow.com/q/39626302\n    const iOSfix = ()=>{\n        const iOS = // @ts-ignore\n        /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1;\n        if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\n            const offset = document.body.scrollTop;\n            document.body.style.top = `${offset * -1}px`;\n            addClass(document.body, swalClasses.iosfix);\n            lockBodyScroll();\n            addBottomPaddingForTallPopups();\n        }\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1948\n   */ const addBottomPaddingForTallPopups = ()=>{\n        const ua = navigator.userAgent;\n        const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);\n        const webkit = !!ua.match(/WebKit/i);\n        const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);\n        if (iOSSafari) {\n            const bottomPanelHeight = 44;\n            if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {\n                getContainer().style.paddingBottom = `${bottomPanelHeight}px`;\n            }\n        }\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1246\n   */ const lockBodyScroll = ()=>{\n        const container = getContainer();\n        let preventTouchMove;\n        /**\n     * @param {TouchEvent} e\n     */ container.ontouchstart = (e)=>{\n            preventTouchMove = shouldPreventTouchMove(e);\n        };\n        /**\n     * @param {TouchEvent} e\n     */ container.ontouchmove = (e)=>{\n            if (preventTouchMove) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        };\n    };\n    /**\n   * @param {TouchEvent} event\n   * @returns {boolean}\n   */ const shouldPreventTouchMove = (event)=>{\n        const target = event.target;\n        const container = getContainer();\n        if (isStylus(event) || isZoom(event)) {\n            return false;\n        }\n        if (target === container) {\n            return true;\n        }\n        if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== \"INPUT\" && // #1603\n        target.tagName !== \"TEXTAREA\" && // #2266\n        !(isScrollable(getHtmlContainer()) && // #1944\n        getHtmlContainer().contains(target))) {\n            return true;\n        }\n        return false;\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1786\n   *\n   * @param {*} event\n   * @returns {boolean}\n   */ const isStylus = (event)=>{\n        return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n    };\n    /**\n   * https://github.com/sweetalert2/sweetalert2/issues/1891\n   *\n   * @param {TouchEvent} event\n   * @returns {boolean}\n   */ const isZoom = (event)=>{\n        return event.touches && event.touches.length > 1;\n    };\n    const undoIOSfix = ()=>{\n        if (hasClass(document.body, swalClasses.iosfix)) {\n            const offset = parseInt(document.body.style.top, 10);\n            removeClass(document.body, swalClasses.iosfix);\n            document.body.style.top = \"\";\n            document.body.scrollTop = offset * -1;\n        }\n    };\n    const fixScrollbar = ()=>{\n        // for queues, do not do this more than once\n        if (states.previousBodyPadding !== null) {\n            return;\n        }\n        // if the body has overflow\n        if (document.body.scrollHeight > window.innerHeight) {\n            // add padding so the content doesn't shift after removal of scrollbar\n            states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n            document.body.style.paddingRight = `${states.previousBodyPadding + measureScrollbar()}px`;\n        }\n    };\n    const undoScrollbar = ()=>{\n        if (states.previousBodyPadding !== null) {\n            document.body.style.paddingRight = `${states.previousBodyPadding}px`;\n            states.previousBodyPadding = null;\n        }\n    };\n    /*\n   * Instance method to close sweetAlert\n   */ function removePopupAndResetState(instance, container, returnFocus, didClose) {\n        if (isToast()) {\n            triggerDidCloseAndDispose(instance, didClose);\n        } else {\n            restoreActiveElement(returnFocus).then(()=>triggerDidCloseAndDispose(instance, didClose));\n            removeKeydownHandler(globalState);\n        }\n        const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n        // workaround for #2088\n        // for some reason removing the container in Safari will scroll the document to bottom\n        if (isSafari) {\n            container.setAttribute(\"style\", \"display:none !important\");\n            container.removeAttribute(\"class\");\n            container.innerHTML = \"\";\n        } else {\n            container.remove();\n        }\n        if (isModal()) {\n            undoScrollbar();\n            undoIOSfix();\n            unsetAriaHidden();\n        }\n        removeBodyClasses();\n    }\n    function removeBodyClasses() {\n        removeClass([\n            document.documentElement,\n            document.body\n        ], [\n            swalClasses.shown,\n            swalClasses[\"height-auto\"],\n            swalClasses[\"no-backdrop\"],\n            swalClasses[\"toast-shown\"]\n        ]);\n    }\n    function close(resolveValue) {\n        resolveValue = prepareResolveValue(resolveValue);\n        const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n        const didClose = triggerClosePopup(this);\n        if (this.isAwaitingPromise()) {\n            // A swal awaiting for a promise (after a click on Confirm or Deny) cannot be dismissed anymore #2335\n            if (!resolveValue.isDismissed) {\n                handleAwaitingPromise(this);\n                swalPromiseResolve(resolveValue);\n            }\n        } else if (didClose) {\n            // Resolve Swal promise\n            swalPromiseResolve(resolveValue);\n        }\n    }\n    function isAwaitingPromise() {\n        return !!privateProps.awaitingPromise.get(this);\n    }\n    const triggerClosePopup = (instance)=>{\n        const popup = getPopup();\n        if (!popup) {\n            return false;\n        }\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n            return false;\n        }\n        removeClass(popup, innerParams.showClass.popup);\n        addClass(popup, innerParams.hideClass.popup);\n        const backdrop = getContainer();\n        removeClass(backdrop, innerParams.showClass.backdrop);\n        addClass(backdrop, innerParams.hideClass.backdrop);\n        handlePopupAnimation(instance, popup, innerParams);\n        return true;\n    };\n    function rejectPromise(error) {\n        const rejectPromise = privateMethods.swalPromiseReject.get(this);\n        handleAwaitingPromise(this);\n        if (rejectPromise) {\n            // Reject Swal promise\n            rejectPromise(error);\n        }\n    }\n    const handleAwaitingPromise = (instance)=>{\n        if (instance.isAwaitingPromise()) {\n            privateProps.awaitingPromise.delete(instance);\n            // The instance might have been previously partly destroyed, we must resume the destroy process in this case #2335\n            if (!privateProps.innerParams.get(instance)) {\n                instance._destroy();\n            }\n        }\n    };\n    const prepareResolveValue = (resolveValue)=>{\n        // When user calls Swal.close()\n        if (typeof resolveValue === \"undefined\") {\n            return {\n                isConfirmed: false,\n                isDenied: false,\n                isDismissed: true\n            };\n        }\n        return Object.assign({\n            isConfirmed: false,\n            isDenied: false,\n            isDismissed: false\n        }, resolveValue);\n    };\n    const handlePopupAnimation = (instance, popup, innerParams)=>{\n        const container = getContainer();\n        // If animation is supported, animate\n        const animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n        if (typeof innerParams.willClose === \"function\") {\n            innerParams.willClose(popup);\n        }\n        if (animationIsSupported) {\n            animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n        } else {\n            // Otherwise, remove immediately\n            removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n        }\n    };\n    const animatePopup = (instance, popup, container, returnFocus, didClose)=>{\n        globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n        popup.addEventListener(animationEndEvent, function(e) {\n            if (e.target === popup) {\n                globalState.swalCloseEventFinishedCallback();\n                delete globalState.swalCloseEventFinishedCallback;\n            }\n        });\n    };\n    const triggerDidCloseAndDispose = (instance, didClose)=>{\n        setTimeout(()=>{\n            if (typeof didClose === \"function\") {\n                didClose.bind(instance.params)();\n            }\n            instance._destroy();\n        });\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {string[]} buttons\n   * @param {boolean} disabled\n   */ function setButtonsDisabled(instance, buttons, disabled) {\n        const domCache = privateProps.domCache.get(instance);\n        buttons.forEach((button)=>{\n            domCache[button].disabled = disabled;\n        });\n    }\n    /**\n   * @param {HTMLInputElement} input\n   * @param {boolean} disabled\n   */ function setInputDisabled(input, disabled) {\n        if (!input) {\n            return;\n        }\n        if (input.type === \"radio\") {\n            const radiosContainer = input.parentNode.parentNode;\n            const radios = radiosContainer.querySelectorAll(\"input\");\n            for(let i = 0; i < radios.length; i++){\n                radios[i].disabled = disabled;\n            }\n        } else {\n            input.disabled = disabled;\n        }\n    }\n    function enableButtons() {\n        setButtonsDisabled(this, [\n            \"confirmButton\",\n            \"denyButton\",\n            \"cancelButton\"\n        ], false);\n    }\n    function disableButtons() {\n        setButtonsDisabled(this, [\n            \"confirmButton\",\n            \"denyButton\",\n            \"cancelButton\"\n        ], true);\n    }\n    function enableInput() {\n        setInputDisabled(this.getInput(), false);\n    }\n    function disableInput() {\n        setInputDisabled(this.getInput(), true);\n    }\n    /**\n   * Show block with validation message\n   *\n   * @param {string} error\n   */ function showValidationMessage(error) {\n        const domCache = privateProps.domCache.get(this);\n        const params = privateProps.innerParams.get(this);\n        setInnerHtml(domCache.validationMessage, error);\n        domCache.validationMessage.className = swalClasses[\"validation-message\"];\n        if (params.customClass && params.customClass.validationMessage) {\n            addClass(domCache.validationMessage, params.customClass.validationMessage);\n        }\n        show(domCache.validationMessage);\n        const input = this.getInput();\n        if (input) {\n            input.setAttribute(\"aria-invalid\", true);\n            input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n            focusInput(input);\n            addClass(input, swalClasses.inputerror);\n        }\n    }\n    /**\n   * Hide block with validation message\n   */ function resetValidationMessage() {\n        const domCache = privateProps.domCache.get(this);\n        if (domCache.validationMessage) {\n            hide(domCache.validationMessage);\n        }\n        const input = this.getInput();\n        if (input) {\n            input.removeAttribute(\"aria-invalid\");\n            input.removeAttribute(\"aria-describedby\");\n            removeClass(input, swalClasses.inputerror);\n        }\n    }\n    const defaultParams = {\n        title: \"\",\n        titleText: \"\",\n        text: \"\",\n        html: \"\",\n        footer: \"\",\n        icon: undefined,\n        iconColor: undefined,\n        iconHtml: undefined,\n        template: undefined,\n        toast: false,\n        showClass: {\n            popup: \"swal2-show\",\n            backdrop: \"swal2-backdrop-show\",\n            icon: \"swal2-icon-show\"\n        },\n        hideClass: {\n            popup: \"swal2-hide\",\n            backdrop: \"swal2-backdrop-hide\",\n            icon: \"swal2-icon-hide\"\n        },\n        customClass: {},\n        target: \"body\",\n        color: undefined,\n        backdrop: true,\n        heightAuto: true,\n        allowOutsideClick: true,\n        allowEscapeKey: true,\n        allowEnterKey: true,\n        stopKeydownPropagation: true,\n        keydownListenerCapture: false,\n        showConfirmButton: true,\n        showDenyButton: false,\n        showCancelButton: false,\n        preConfirm: undefined,\n        preDeny: undefined,\n        confirmButtonText: \"OK\",\n        confirmButtonAriaLabel: \"\",\n        confirmButtonColor: undefined,\n        denyButtonText: \"No\",\n        denyButtonAriaLabel: \"\",\n        denyButtonColor: undefined,\n        cancelButtonText: \"Cancel\",\n        cancelButtonAriaLabel: \"\",\n        cancelButtonColor: undefined,\n        buttonsStyling: true,\n        reverseButtons: false,\n        focusConfirm: true,\n        focusDeny: false,\n        focusCancel: false,\n        returnFocus: true,\n        showCloseButton: false,\n        closeButtonHtml: \"&times;\",\n        closeButtonAriaLabel: \"Close this dialog\",\n        loaderHtml: \"\",\n        showLoaderOnConfirm: false,\n        showLoaderOnDeny: false,\n        imageUrl: undefined,\n        imageWidth: undefined,\n        imageHeight: undefined,\n        imageAlt: \"\",\n        timer: undefined,\n        timerProgressBar: false,\n        width: undefined,\n        padding: undefined,\n        background: undefined,\n        input: undefined,\n        inputPlaceholder: \"\",\n        inputLabel: \"\",\n        inputValue: \"\",\n        inputOptions: {},\n        inputAutoTrim: true,\n        inputAttributes: {},\n        inputValidator: undefined,\n        returnInputValueOnDeny: false,\n        validationMessage: undefined,\n        grow: false,\n        position: \"center\",\n        progressSteps: [],\n        currentProgressStep: undefined,\n        progressStepsDistance: undefined,\n        willOpen: undefined,\n        didOpen: undefined,\n        didRender: undefined,\n        willClose: undefined,\n        didClose: undefined,\n        didDestroy: undefined,\n        scrollbarPadding: true\n    };\n    const updatableParams = [\n        \"allowEscapeKey\",\n        \"allowOutsideClick\",\n        \"background\",\n        \"buttonsStyling\",\n        \"cancelButtonAriaLabel\",\n        \"cancelButtonColor\",\n        \"cancelButtonText\",\n        \"closeButtonAriaLabel\",\n        \"closeButtonHtml\",\n        \"color\",\n        \"confirmButtonAriaLabel\",\n        \"confirmButtonColor\",\n        \"confirmButtonText\",\n        \"currentProgressStep\",\n        \"customClass\",\n        \"denyButtonAriaLabel\",\n        \"denyButtonColor\",\n        \"denyButtonText\",\n        \"didClose\",\n        \"didDestroy\",\n        \"footer\",\n        \"hideClass\",\n        \"html\",\n        \"icon\",\n        \"iconColor\",\n        \"iconHtml\",\n        \"imageAlt\",\n        \"imageHeight\",\n        \"imageUrl\",\n        \"imageWidth\",\n        \"preConfirm\",\n        \"preDeny\",\n        \"progressSteps\",\n        \"returnFocus\",\n        \"reverseButtons\",\n        \"showCancelButton\",\n        \"showCloseButton\",\n        \"showConfirmButton\",\n        \"showDenyButton\",\n        \"text\",\n        \"title\",\n        \"titleText\",\n        \"willClose\"\n    ];\n    const deprecatedParams = {};\n    const toastIncompatibleParams = [\n        \"allowOutsideClick\",\n        \"allowEnterKey\",\n        \"backdrop\",\n        \"focusConfirm\",\n        \"focusDeny\",\n        \"focusCancel\",\n        \"returnFocus\",\n        \"heightAuto\",\n        \"keydownListenerCapture\"\n    ];\n    /**\n   * Is valid parameter\n   *\n   * @param {string} paramName\n   * @returns {boolean}\n   */ const isValidParameter = (paramName)=>{\n        return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n    };\n    /**\n   * Is valid parameter for Swal.update() method\n   *\n   * @param {string} paramName\n   * @returns {boolean}\n   */ const isUpdatableParameter = (paramName)=>{\n        return updatableParams.indexOf(paramName) !== -1;\n    };\n    /**\n   * Is deprecated parameter\n   *\n   * @param {string} paramName\n   * @returns {string | undefined}\n   */ const isDeprecatedParameter = (paramName)=>{\n        return deprecatedParams[paramName];\n    };\n    /**\n   * @param {string} param\n   */ const checkIfParamIsValid = (param)=>{\n        if (!isValidParameter(param)) {\n            warn(`Unknown parameter \"${param}\"`);\n        }\n    };\n    /**\n   * @param {string} param\n   */ const checkIfToastParamIsValid = (param)=>{\n        if (toastIncompatibleParams.includes(param)) {\n            warn(`The parameter \"${param}\" is incompatible with toasts`);\n        }\n    };\n    /**\n   * @param {string} param\n   */ const checkIfParamIsDeprecated = (param)=>{\n        if (isDeprecatedParameter(param)) {\n            warnAboutDeprecation(param, isDeprecatedParameter(param));\n        }\n    };\n    /**\n   * Show relevant warnings for given params\n   *\n   * @param {SweetAlertOptions} params\n   */ const showWarningsForParams = (params)=>{\n        if (params.backdrop === false && params.allowOutsideClick) {\n            warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n        }\n        for(const param in params){\n            checkIfParamIsValid(param);\n            if (params.toast) {\n                checkIfToastParamIsValid(param);\n            }\n            checkIfParamIsDeprecated(param);\n        }\n    };\n    /**\n   * Updates popup parameters.\n   *\n   * @param {SweetAlertOptions} params\n   */ function update(params) {\n        const popup = getPopup();\n        const innerParams = privateProps.innerParams.get(this);\n        if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n            warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);\n            return;\n        }\n        const validUpdatableParams = filterValidParams(params);\n        const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n        render(this, updatedParams);\n        privateProps.innerParams.set(this, updatedParams);\n        Object.defineProperties(this, {\n            params: {\n                value: Object.assign({}, this.params, params),\n                writable: false,\n                enumerable: true\n            }\n        });\n    }\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {SweetAlertOptions}\n   */ const filterValidParams = (params)=>{\n        const validUpdatableParams = {};\n        Object.keys(params).forEach((param)=>{\n            if (isUpdatableParameter(param)) {\n                validUpdatableParams[param] = params[param];\n            } else {\n                warn(`Invalid parameter to update: ${param}`);\n            }\n        });\n        return validUpdatableParams;\n    };\n    function _destroy() {\n        const domCache = privateProps.domCache.get(this);\n        const innerParams = privateProps.innerParams.get(this);\n        if (!innerParams) {\n            disposeWeakMaps(this); // The WeakMaps might have been partly destroyed, we must recall it to dispose any remaining WeakMaps #2335\n            return; // This instance has already been destroyed\n        }\n        // Check if there is another Swal closing\n        if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n            globalState.swalCloseEventFinishedCallback();\n            delete globalState.swalCloseEventFinishedCallback;\n        }\n        if (typeof innerParams.didDestroy === \"function\") {\n            innerParams.didDestroy();\n        }\n        disposeSwal(this);\n    }\n    /**\n   * @param {SweetAlert2} instance\n   */ const disposeSwal = (instance)=>{\n        disposeWeakMaps(instance);\n        // Unset this.params so GC will dispose it (#1569)\n        // @ts-ignore\n        delete instance.params;\n        // Unset globalState props so GC will dispose globalState (#1569)\n        delete globalState.keydownHandler;\n        delete globalState.keydownTarget;\n        // Unset currentInstance\n        delete globalState.currentInstance;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const disposeWeakMaps = (instance)=>{\n        // If the current instance is awaiting a promise result, we keep the privateMethods to call them once the promise result is retrieved #2335\n        // @ts-ignore\n        if (instance.isAwaitingPromise()) {\n            unsetWeakMaps(privateProps, instance);\n            privateProps.awaitingPromise.set(instance, true);\n        } else {\n            unsetWeakMaps(privateMethods, instance);\n            unsetWeakMaps(privateProps, instance);\n        }\n    };\n    /**\n   * @param {object} obj\n   * @param {SweetAlert2} instance\n   */ const unsetWeakMaps = (obj, instance)=>{\n        for(const i in obj){\n            obj[i].delete(instance);\n        }\n    };\n    var instanceMethods = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        hideLoading: hideLoading,\n        disableLoading: hideLoading,\n        getInput: getInput,\n        close: close,\n        isAwaitingPromise: isAwaitingPromise,\n        rejectPromise: rejectPromise,\n        handleAwaitingPromise: handleAwaitingPromise,\n        closePopup: close,\n        closeModal: close,\n        closeToast: close,\n        enableButtons: enableButtons,\n        disableButtons: disableButtons,\n        enableInput: enableInput,\n        disableInput: disableInput,\n        showValidationMessage: showValidationMessage,\n        resetValidationMessage: resetValidationMessage,\n        update: update,\n        _destroy: _destroy\n    });\n    /**\n   * Shows loader (spinner), this is useful with AJAX requests.\n   * By default the loader be shown instead of the \"Confirm\" button.\n   */ const showLoading = (buttonToReplace)=>{\n        let popup = getPopup();\n        if (!popup) {\n            new Swal(); // eslint-disable-line no-new\n        }\n        popup = getPopup();\n        const loader = getLoader();\n        if (isToast()) {\n            hide(getIcon());\n        } else {\n            replaceButton(popup, buttonToReplace);\n        }\n        show(loader);\n        popup.setAttribute(\"data-loading\", \"true\");\n        popup.setAttribute(\"aria-busy\", \"true\");\n        popup.focus();\n    };\n    const replaceButton = (popup, buttonToReplace)=>{\n        const actions = getActions();\n        const loader = getLoader();\n        if (!buttonToReplace && isVisible$1(getConfirmButton())) {\n            buttonToReplace = getConfirmButton();\n        }\n        show(actions);\n        if (buttonToReplace) {\n            hide(buttonToReplace);\n            loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n        }\n        loader.parentNode.insertBefore(loader, buttonToReplace);\n        addClass([\n            popup,\n            actions\n        ], swalClasses.loading);\n    };\n    /**\n   * @typedef { string | number | boolean } InputValue\n   */ /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputOptionsAndValue = (instance, params)=>{\n        if (params.input === \"select\" || params.input === \"radio\") {\n            handleInputOptions(instance, params);\n        } else if ([\n            \"text\",\n            \"email\",\n            \"number\",\n            \"tel\",\n            \"textarea\"\n        ].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n            showLoading(getConfirmButton());\n            handleInputValue(instance, params);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} innerParams\n   * @returns {string | number | File | FileList | null}\n   */ const getInputValue = (instance, innerParams)=>{\n        const input = instance.getInput();\n        if (!input) {\n            return null;\n        }\n        switch(innerParams.input){\n            case \"checkbox\":\n                return getCheckboxValue(input);\n            case \"radio\":\n                return getRadioValue(input);\n            case \"file\":\n                return getFileValue(input);\n            default:\n                return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n        }\n    };\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {number}\n   */ const getCheckboxValue = (input)=>input.checked ? 1 : 0;\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {string | null}\n   */ const getRadioValue = (input)=>input.checked ? input.value : null;\n    /**\n   * @param {HTMLInputElement} input\n   * @returns {FileList | File | null}\n   */ const getFileValue = (input)=>input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputOptions = (instance, params)=>{\n        const popup = getPopup();\n        /**\n     * @param {Record<string, any>} inputOptions\n     */ const processInputOptions = (inputOptions)=>{\n            populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);\n        };\n        if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n            showLoading(getConfirmButton());\n            asPromise(params.inputOptions).then((inputOptions)=>{\n                instance.hideLoading();\n                processInputOptions(inputOptions);\n            });\n        } else if (typeof params.inputOptions === \"object\") {\n            processInputOptions(params.inputOptions);\n        } else {\n            error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {SweetAlertOptions} params\n   */ const handleInputValue = (instance, params)=>{\n        const input = instance.getInput();\n        hide(input);\n        asPromise(params.inputValue).then((inputValue)=>{\n            input.value = params.input === \"number\" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;\n            show(input);\n            input.focus();\n            instance.hideLoading();\n        }).catch((err)=>{\n            error(`Error in inputValue promise: ${err}`);\n            input.value = \"\";\n            show(input);\n            input.focus();\n            instance.hideLoading();\n        });\n    };\n    const populateInputOptions = {\n        /**\n     * @param {HTMLElement} popup\n     * @param {Record<string, any>} inputOptions\n     * @param {SweetAlertOptions} params\n     */ select: (popup, inputOptions, params)=>{\n            const select = getDirectChildByClass(popup, swalClasses.select);\n            /**\n       * @param {HTMLElement} parent\n       * @param {string} optionLabel\n       * @param {string} optionValue\n       */ const renderOption = (parent, optionLabel, optionValue)=>{\n                const option = document.createElement(\"option\");\n                option.value = optionValue;\n                setInnerHtml(option, optionLabel);\n                option.selected = isSelected(optionValue, params.inputValue);\n                parent.appendChild(option);\n            };\n            inputOptions.forEach((inputOption)=>{\n                const optionValue = inputOption[0];\n                const optionLabel = inputOption[1];\n                // <optgroup> spec:\n                // https://www.w3.org/TR/html401/interact/forms.html#h-17.6\n                // \"...all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested)...\"\n                // check whether this is a <optgroup>\n                if (Array.isArray(optionLabel)) {\n                    // if it is an array, then it is an <optgroup>\n                    const optgroup = document.createElement(\"optgroup\");\n                    optgroup.label = optionValue;\n                    optgroup.disabled = false; // not configurable for now\n                    select.appendChild(optgroup);\n                    optionLabel.forEach((o)=>renderOption(optgroup, o[1], o[0]));\n                } else {\n                    // case of <option>\n                    renderOption(select, optionLabel, optionValue);\n                }\n            });\n            select.focus();\n        },\n        /**\n     * @param {HTMLElement} popup\n     * @param {Record<string, any>} inputOptions\n     * @param {SweetAlertOptions} params\n     */ radio: (popup, inputOptions, params)=>{\n            const radio = getDirectChildByClass(popup, swalClasses.radio);\n            inputOptions.forEach((inputOption)=>{\n                const radioValue = inputOption[0];\n                const radioLabel = inputOption[1];\n                const radioInput = document.createElement(\"input\");\n                const radioLabelElement = document.createElement(\"label\");\n                radioInput.type = \"radio\";\n                radioInput.name = swalClasses.radio;\n                radioInput.value = radioValue;\n                if (isSelected(radioValue, params.inputValue)) {\n                    radioInput.checked = true;\n                }\n                const label = document.createElement(\"span\");\n                setInnerHtml(label, radioLabel);\n                label.className = swalClasses.label;\n                radioLabelElement.appendChild(radioInput);\n                radioLabelElement.appendChild(label);\n                radio.appendChild(radioLabelElement);\n            });\n            const radios = radio.querySelectorAll(\"input\");\n            if (radios.length) {\n                radios[0].focus();\n            }\n        }\n    };\n    /**\n   * Converts `inputOptions` into an array of `[value, label]`s\n   *\n   * @param {Record<string, any>} inputOptions\n   * @returns {Array<Array<string>>}\n   */ const formatInputOptions = (inputOptions)=>{\n        const result = [];\n        if (typeof Map !== \"undefined\" && inputOptions instanceof Map) {\n            inputOptions.forEach((value, key)=>{\n                let valueFormatted = value;\n                if (typeof valueFormatted === \"object\") {\n                    // case of <optgroup>\n                    valueFormatted = formatInputOptions(valueFormatted);\n                }\n                result.push([\n                    key,\n                    valueFormatted\n                ]);\n            });\n        } else {\n            Object.keys(inputOptions).forEach((key)=>{\n                let valueFormatted = inputOptions[key];\n                if (typeof valueFormatted === \"object\") {\n                    // case of <optgroup>\n                    valueFormatted = formatInputOptions(valueFormatted);\n                }\n                result.push([\n                    key,\n                    valueFormatted\n                ]);\n            });\n        }\n        return result;\n    };\n    /**\n   * @param {string} optionValue\n   * @param {InputValue | Promise<InputValue> | { toPromise: () => InputValue }} inputValue\n   * @returns {boolean}\n   */ const isSelected = (optionValue, inputValue)=>{\n        return inputValue && inputValue.toString() === optionValue.toString();\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const handleConfirmButtonClick = (instance)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableButtons();\n        if (innerParams.input) {\n            handleConfirmOrDenyWithInput(instance, \"confirm\");\n        } else {\n            confirm(instance, true);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   */ const handleDenyButtonClick = (instance)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableButtons();\n        if (innerParams.returnInputValueOnDeny) {\n            handleConfirmOrDenyWithInput(instance, \"deny\");\n        } else {\n            deny(instance, false);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {Function} dismissWith\n   */ const handleCancelButtonClick = (instance, dismissWith)=>{\n        instance.disableButtons();\n        dismissWith(DismissReason.cancel);\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {'confirm' | 'deny'} type\n   */ const handleConfirmOrDenyWithInput = (instance, type)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (!innerParams.input) {\n            error(`The \"input\" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);\n            return;\n        }\n        const inputValue = getInputValue(instance, innerParams);\n        if (innerParams.inputValidator) {\n            handleInputValidator(instance, inputValue, type);\n        } else if (!instance.getInput().checkValidity()) {\n            instance.enableButtons();\n            instance.showValidationMessage(innerParams.validationMessage);\n        } else if (type === \"deny\") {\n            deny(instance, inputValue);\n        } else {\n            confirm(instance, inputValue);\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {string | number | File | FileList | null} inputValue\n   * @param {'confirm' | 'deny'} type\n   */ const handleInputValidator = (instance, inputValue, type)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        instance.disableInput();\n        const validationPromise = Promise.resolve().then(()=>asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n        validationPromise.then((validationMessage)=>{\n            instance.enableButtons();\n            instance.enableInput();\n            if (validationMessage) {\n                instance.showValidationMessage(validationMessage);\n            } else if (type === \"deny\") {\n                deny(instance, inputValue);\n            } else {\n                confirm(instance, inputValue);\n            }\n        });\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const deny = (instance, value)=>{\n        const innerParams = privateProps.innerParams.get(instance || undefined);\n        if (innerParams.showLoaderOnDeny) {\n            showLoading(getDenyButton());\n        }\n        if (innerParams.preDeny) {\n            privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preDeny's promise is received\n            const preDenyPromise = Promise.resolve().then(()=>asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n            preDenyPromise.then((preDenyValue)=>{\n                if (preDenyValue === false) {\n                    instance.hideLoading();\n                    handleAwaitingPromise(instance);\n                } else {\n                    instance.close({\n                        isDenied: true,\n                        value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n                    });\n                }\n            }).catch((error)=>rejectWith(instance || undefined, error));\n        } else {\n            instance.close({\n                isDenied: true,\n                value\n            });\n        }\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const succeedWith = (instance, value)=>{\n        instance.close({\n            isConfirmed: true,\n            value\n        });\n    };\n    /**\n   *\n   * @param {SweetAlert2} instance\n   * @param {string} error\n   */ const rejectWith = (instance, error)=>{\n        // @ts-ignore\n        instance.rejectPromise(error);\n    };\n    /**\n   *\n   * @param {SweetAlert2} instance\n   * @param {any} value\n   */ const confirm = (instance, value)=>{\n        const innerParams = privateProps.innerParams.get(instance || undefined);\n        if (innerParams.showLoaderOnConfirm) {\n            showLoading();\n        }\n        if (innerParams.preConfirm) {\n            instance.resetValidationMessage();\n            privateProps.awaitingPromise.set(instance || undefined, true); // Flagging the instance as awaiting a promise so it's own promise's reject/resolve methods doesn't get destroyed until the result from this preConfirm's promise is received\n            const preConfirmPromise = Promise.resolve().then(()=>asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n            preConfirmPromise.then((preConfirmValue)=>{\n                if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {\n                    instance.hideLoading();\n                    handleAwaitingPromise(instance);\n                } else {\n                    succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n                }\n            }).catch((error)=>rejectWith(instance || undefined, error));\n        } else {\n            succeedWith(instance, value);\n        }\n    };\n    const handlePopupClick = (instance, domCache, dismissWith)=>{\n        const innerParams = privateProps.innerParams.get(instance);\n        if (innerParams.toast) {\n            handleToastClick(instance, domCache, dismissWith);\n        } else {\n            // Ignore click events that had mousedown on the popup but mouseup on the container\n            // This can happen when the user drags a slider\n            handleModalMousedown(domCache);\n            // Ignore click events that had mousedown on the container but mouseup on the popup\n            handleContainerMousedown(domCache);\n            handleModalClick(instance, domCache, dismissWith);\n        }\n    };\n    const handleToastClick = (instance, domCache, dismissWith)=>{\n        // Closing toast by internal click\n        domCache.popup.onclick = ()=>{\n            const innerParams = privateProps.innerParams.get(instance);\n            if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n                return;\n            }\n            dismissWith(DismissReason.close);\n        };\n    };\n    /**\n   * @param {*} innerParams\n   * @returns {boolean}\n   */ const isAnyButtonShown = (innerParams)=>{\n        return innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton;\n    };\n    let ignoreOutsideClick = false;\n    const handleModalMousedown = (domCache)=>{\n        domCache.popup.onmousedown = ()=>{\n            domCache.container.onmouseup = function(e) {\n                domCache.container.onmouseup = undefined;\n                // We only check if the mouseup target is the container because usually it doesn't\n                // have any other direct children aside of the popup\n                if (e.target === domCache.container) {\n                    ignoreOutsideClick = true;\n                }\n            };\n        };\n    };\n    const handleContainerMousedown = (domCache)=>{\n        domCache.container.onmousedown = ()=>{\n            domCache.popup.onmouseup = function(e) {\n                domCache.popup.onmouseup = undefined;\n                // We also need to check if the mouseup target is a child of the popup\n                if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n                    ignoreOutsideClick = true;\n                }\n            };\n        };\n    };\n    const handleModalClick = (instance, domCache, dismissWith)=>{\n        domCache.container.onclick = (e)=>{\n            const innerParams = privateProps.innerParams.get(instance);\n            if (ignoreOutsideClick) {\n                ignoreOutsideClick = false;\n                return;\n            }\n            if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n                dismissWith(DismissReason.backdrop);\n            }\n        };\n    };\n    const isJqueryElement = (elem)=>typeof elem === \"object\" && elem.jquery;\n    const isElement = (elem)=>elem instanceof Element || isJqueryElement(elem);\n    const argsToParams = (args)=>{\n        const params = {};\n        if (typeof args[0] === \"object\" && !isElement(args[0])) {\n            Object.assign(params, args[0]);\n        } else {\n            [\n                \"title\",\n                \"html\",\n                \"icon\"\n            ].forEach((name, index)=>{\n                const arg = args[index];\n                if (typeof arg === \"string\" || isElement(arg)) {\n                    params[name] = arg;\n                } else if (arg !== undefined) {\n                    error(`Unexpected type of ${name}! Expected \"string\" or \"Element\", got ${typeof arg}`);\n                }\n            });\n        }\n        return params;\n    };\n    function fire() {\n        const Swal = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return new Swal(...args);\n    }\n    /**\n   * Returns an extended version of `Swal` containing `params` as defaults.\n   * Useful for reusing Swal configuration.\n   *\n   * For example:\n   *\n   * Before:\n   * const textPromptOptions = { input: 'text', showCancelButton: true }\n   * const {value: firstName} = await Swal.fire({ ...textPromptOptions, title: 'What is your first name?' })\n   * const {value: lastName} = await Swal.fire({ ...textPromptOptions, title: 'What is your last name?' })\n   *\n   * After:\n   * const TextPrompt = Swal.mixin({ input: 'text', showCancelButton: true })\n   * const {value: firstName} = await TextPrompt('What is your first name?')\n   * const {value: lastName} = await TextPrompt('What is your last name?')\n   *\n   * @param mixinParams\n   */ function mixin(mixinParams) {\n        class MixinSwal extends this {\n            _main(params, priorityMixinParams) {\n                return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n            }\n        }\n        return MixinSwal;\n    }\n    /**\n   * If `timer` parameter is set, returns number of milliseconds of timer remained.\n   * Otherwise, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const getTimerLeft = ()=>{\n        return globalState.timeout && globalState.timeout.getTimerLeft();\n    };\n    /**\n   * Stop timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const stopTimer = ()=>{\n        if (globalState.timeout) {\n            stopTimerProgressBar();\n            return globalState.timeout.stop();\n        }\n    };\n    /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const resumeTimer = ()=>{\n        if (globalState.timeout) {\n            const remaining = globalState.timeout.start();\n            animateTimerProgressBar(remaining);\n            return remaining;\n        }\n    };\n    /**\n   * Resume timer. Returns number of milliseconds of timer remained.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @returns {number | undefined}\n   */ const toggleTimer = ()=>{\n        const timer = globalState.timeout;\n        return timer && (timer.running ? stopTimer() : resumeTimer());\n    };\n    /**\n   * Increase timer. Returns number of milliseconds of an updated timer.\n   * If `timer` parameter isn't set, returns undefined.\n   *\n   * @param {number} n\n   * @returns {number | undefined}\n   */ const increaseTimer = (n)=>{\n        if (globalState.timeout) {\n            const remaining = globalState.timeout.increase(n);\n            animateTimerProgressBar(remaining, true);\n            return remaining;\n        }\n    };\n    /**\n   * Check if timer is running. Returns true if timer is running\n   * or false if timer is paused or stopped.\n   * If `timer` parameter isn't set, returns undefined\n   *\n   * @returns {boolean}\n   */ const isTimerRunning = ()=>{\n        return globalState.timeout && globalState.timeout.isRunning();\n    };\n    let bodyClickListenerAdded = false;\n    const clickHandlers = {};\n    /**\n   * @param {string} attr\n   */ function bindClickHandler() {\n        let attr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"data-swal-template\";\n        clickHandlers[attr] = this;\n        if (!bodyClickListenerAdded) {\n            document.body.addEventListener(\"click\", bodyClickListener);\n            bodyClickListenerAdded = true;\n        }\n    }\n    const bodyClickListener = (event)=>{\n        for(let el = event.target; el && el !== document; el = el.parentNode){\n            for(const attr in clickHandlers){\n                const template = el.getAttribute(attr);\n                if (template) {\n                    clickHandlers[attr].fire({\n                        template\n                    });\n                    return;\n                }\n            }\n        }\n    };\n    var staticMethods = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        isValidParameter: isValidParameter,\n        isUpdatableParameter: isUpdatableParameter,\n        isDeprecatedParameter: isDeprecatedParameter,\n        argsToParams: argsToParams,\n        getContainer: getContainer,\n        getPopup: getPopup,\n        getTitle: getTitle,\n        getHtmlContainer: getHtmlContainer,\n        getImage: getImage,\n        getIcon: getIcon,\n        getIconContent: getIconContent,\n        getInputLabel: getInputLabel,\n        getCloseButton: getCloseButton,\n        getActions: getActions,\n        getConfirmButton: getConfirmButton,\n        getDenyButton: getDenyButton,\n        getCancelButton: getCancelButton,\n        getLoader: getLoader,\n        getFooter: getFooter,\n        getTimerProgressBar: getTimerProgressBar,\n        getFocusableElements: getFocusableElements,\n        getValidationMessage: getValidationMessage,\n        getProgressSteps: getProgressSteps,\n        isLoading: isLoading,\n        isVisible: isVisible,\n        clickConfirm: clickConfirm,\n        clickDeny: clickDeny,\n        clickCancel: clickCancel,\n        fire: fire,\n        mixin: mixin,\n        showLoading: showLoading,\n        enableLoading: showLoading,\n        getTimerLeft: getTimerLeft,\n        stopTimer: stopTimer,\n        resumeTimer: resumeTimer,\n        toggleTimer: toggleTimer,\n        increaseTimer: increaseTimer,\n        isTimerRunning: isTimerRunning,\n        bindClickHandler: bindClickHandler\n    });\n    class Timer {\n        /**\n     * @param {Function} callback\n     * @param {number} delay\n     */ constructor(callback, delay){\n            this.callback = callback;\n            this.remaining = delay;\n            this.running = false;\n            this.start();\n        }\n        start() {\n            if (!this.running) {\n                this.running = true;\n                this.started = new Date();\n                this.id = setTimeout(this.callback, this.remaining);\n            }\n            return this.remaining;\n        }\n        stop() {\n            if (this.running) {\n                this.running = false;\n                clearTimeout(this.id);\n                this.remaining -= new Date().getTime() - this.started.getTime();\n            }\n            return this.remaining;\n        }\n        increase(n) {\n            const running = this.running;\n            if (running) {\n                this.stop();\n            }\n            this.remaining += n;\n            if (running) {\n                this.start();\n            }\n            return this.remaining;\n        }\n        getTimerLeft() {\n            if (this.running) {\n                this.stop();\n                this.start();\n            }\n            return this.remaining;\n        }\n        isRunning() {\n            return this.running;\n        }\n    }\n    const swalStringParams = [\n        \"swal-title\",\n        \"swal-html\",\n        \"swal-footer\"\n    ];\n    /**\n   * @param {SweetAlertOptions} params\n   * @returns {SweetAlertOptions}\n   */ const getTemplateParams = (params)=>{\n        /** @type {HTMLTemplateElement} */ const template = typeof params.template === \"string\" ? document.querySelector(params.template) : params.template;\n        if (!template) {\n            return {};\n        }\n        /** @type {DocumentFragment} */ const templateContent = template.content;\n        showWarningsForElements(templateContent);\n        const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalParams = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalParams = Array.from(templateContent.querySelectorAll(\"swal-param\"));\n        swalParams.forEach((param)=>{\n            showWarningsForAttributes(param, [\n                \"name\",\n                \"value\"\n            ]);\n            const paramName = param.getAttribute(\"name\");\n            const value = param.getAttribute(\"value\");\n            if (typeof defaultParams[paramName] === \"boolean\") {\n                result[paramName] = value !== \"false\";\n            } else if (typeof defaultParams[paramName] === \"object\") {\n                result[paramName] = JSON.parse(value);\n            } else {\n                result[paramName] = value;\n            }\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalFunctionParams = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalFunctions = Array.from(templateContent.querySelectorAll(\"swal-function-param\"));\n        swalFunctions.forEach((param)=>{\n            const paramName = param.getAttribute(\"name\");\n            const value = param.getAttribute(\"value\");\n            result[paramName] = new Function(`return ${value}`)();\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalButtons = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement[]} */ const swalButtons = Array.from(templateContent.querySelectorAll(\"swal-button\"));\n        swalButtons.forEach((button)=>{\n            showWarningsForAttributes(button, [\n                \"type\",\n                \"color\",\n                \"aria-label\"\n            ]);\n            const type = button.getAttribute(\"type\");\n            result[`${type}ButtonText`] = button.innerHTML;\n            result[`show${capitalizeFirstLetter(type)}Button`] = true;\n            if (button.hasAttribute(\"color\")) {\n                result[`${type}ButtonColor`] = button.getAttribute(\"color\");\n            }\n            if (button.hasAttribute(\"aria-label\")) {\n                result[`${type}ButtonAriaLabel`] = button.getAttribute(\"aria-label\");\n            }\n        });\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalImage = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const image = templateContent.querySelector(\"swal-image\");\n        if (image) {\n            showWarningsForAttributes(image, [\n                \"src\",\n                \"width\",\n                \"height\",\n                \"alt\"\n            ]);\n            if (image.hasAttribute(\"src\")) {\n                result.imageUrl = image.getAttribute(\"src\");\n            }\n            if (image.hasAttribute(\"width\")) {\n                result.imageWidth = image.getAttribute(\"width\");\n            }\n            if (image.hasAttribute(\"height\")) {\n                result.imageHeight = image.getAttribute(\"height\");\n            }\n            if (image.hasAttribute(\"alt\")) {\n                result.imageAlt = image.getAttribute(\"alt\");\n            }\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalIcon = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const icon = templateContent.querySelector(\"swal-icon\");\n        if (icon) {\n            showWarningsForAttributes(icon, [\n                \"type\",\n                \"color\"\n            ]);\n            if (icon.hasAttribute(\"type\")) {\n                /** @type {SweetAlertIcon} */ // @ts-ignore\n                result.icon = icon.getAttribute(\"type\");\n            }\n            if (icon.hasAttribute(\"color\")) {\n                result.iconColor = icon.getAttribute(\"color\");\n            }\n            result.iconHtml = icon.innerHTML;\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @returns {SweetAlertOptions}\n   */ const getSwalInput = (templateContent)=>{\n        const result = {};\n        /** @type {HTMLElement} */ const input = templateContent.querySelector(\"swal-input\");\n        if (input) {\n            showWarningsForAttributes(input, [\n                \"type\",\n                \"label\",\n                \"placeholder\",\n                \"value\"\n            ]);\n            /** @type {SweetAlertInput} */ // @ts-ignore\n            result.input = input.getAttribute(\"type\") || \"text\";\n            if (input.hasAttribute(\"label\")) {\n                result.inputLabel = input.getAttribute(\"label\");\n            }\n            if (input.hasAttribute(\"placeholder\")) {\n                result.inputPlaceholder = input.getAttribute(\"placeholder\");\n            }\n            if (input.hasAttribute(\"value\")) {\n                result.inputValue = input.getAttribute(\"value\");\n            }\n        }\n        /** @type {HTMLElement[]} */ const inputOptions = Array.from(templateContent.querySelectorAll(\"swal-input-option\"));\n        if (inputOptions.length) {\n            result.inputOptions = {};\n            inputOptions.forEach((option)=>{\n                showWarningsForAttributes(option, [\n                    \"value\"\n                ]);\n                const optionValue = option.getAttribute(\"value\");\n                const optionName = option.innerHTML;\n                result.inputOptions[optionValue] = optionName;\n            });\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   * @param {string[]} paramNames\n   * @returns {SweetAlertOptions}\n   */ const getSwalStringParams = (templateContent, paramNames)=>{\n        const result = {};\n        for(const i in paramNames){\n            const paramName = paramNames[i];\n            /** @type {HTMLElement} */ const tag = templateContent.querySelector(paramName);\n            if (tag) {\n                showWarningsForAttributes(tag, []);\n                result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n            }\n        }\n        return result;\n    };\n    /**\n   * @param {DocumentFragment} templateContent\n   */ const showWarningsForElements = (templateContent)=>{\n        const allowedElements = swalStringParams.concat([\n            \"swal-param\",\n            \"swal-function-param\",\n            \"swal-button\",\n            \"swal-image\",\n            \"swal-icon\",\n            \"swal-input\",\n            \"swal-input-option\"\n        ]);\n        Array.from(templateContent.children).forEach((el)=>{\n            const tagName = el.tagName.toLowerCase();\n            if (!allowedElements.includes(tagName)) {\n                warn(`Unrecognized element <${tagName}>`);\n            }\n        });\n    };\n    /**\n   * @param {HTMLElement} el\n   * @param {string[]} allowedAttributes\n   */ const showWarningsForAttributes = (el, allowedAttributes)=>{\n        Array.from(el.attributes).forEach((attribute)=>{\n            if (allowedAttributes.indexOf(attribute.name) === -1) {\n                warn([\n                    `Unrecognized attribute \"${attribute.name}\" on <${el.tagName.toLowerCase()}>.`,\n                    `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(\", \")}` : \"To set the value, use HTML within the element.\"}`\n                ]);\n            }\n        });\n    };\n    const SHOW_CLASS_TIMEOUT = 10;\n    /**\n   * Open popup, add necessary classes and styles, fix scrollbar\n   *\n   * @param {SweetAlertOptions} params\n   */ const openPopup = (params)=>{\n        const container = getContainer();\n        const popup = getPopup();\n        if (typeof params.willOpen === \"function\") {\n            params.willOpen(popup);\n        }\n        const bodyStyles = window.getComputedStyle(document.body);\n        const initialBodyOverflow = bodyStyles.overflowY;\n        addClasses(container, popup, params);\n        // scrolling is 'hidden' until animation is done, after that 'auto'\n        setTimeout(()=>{\n            setScrollingVisibility(container, popup);\n        }, SHOW_CLASS_TIMEOUT);\n        if (isModal()) {\n            fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n            setAriaHidden();\n        }\n        if (!isToast() && !globalState.previousActiveElement) {\n            globalState.previousActiveElement = document.activeElement;\n        }\n        if (typeof params.didOpen === \"function\") {\n            setTimeout(()=>params.didOpen(popup));\n        }\n        removeClass(container, swalClasses[\"no-transition\"]);\n    };\n    /**\n   * @param {AnimationEvent} event\n   */ const swalOpenAnimationFinished = (event)=>{\n        const popup = getPopup();\n        if (event.target !== popup) {\n            return;\n        }\n        const container = getContainer();\n        popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n        container.style.overflowY = \"auto\";\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {HTMLElement} popup\n   */ const setScrollingVisibility = (container, popup)=>{\n        if (animationEndEvent && hasCssAnimation(popup)) {\n            container.style.overflowY = \"hidden\";\n            popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n        } else {\n            container.style.overflowY = \"auto\";\n        }\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {boolean} scrollbarPadding\n   * @param {string} initialBodyOverflow\n   */ const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow)=>{\n        iOSfix();\n        if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n            fixScrollbar();\n        }\n        // sweetalert2/issues/1247\n        setTimeout(()=>{\n            container.scrollTop = 0;\n        });\n    };\n    /**\n   * @param {HTMLElement} container\n   * @param {HTMLElement} popup\n   * @param {SweetAlertOptions} params\n   */ const addClasses = (container, popup, params)=>{\n        addClass(container, params.showClass.backdrop);\n        // this workaround with opacity is needed for https://github.com/sweetalert2/sweetalert2/issues/2059\n        popup.style.setProperty(\"opacity\", \"0\", \"important\");\n        show(popup, \"grid\");\n        setTimeout(()=>{\n            // Animate popup right after showing it\n            addClass(popup, params.showClass.popup);\n            // and remove the opacity workaround\n            popup.style.removeProperty(\"opacity\");\n        }, SHOW_CLASS_TIMEOUT); // 10ms in order to fix #2062\n        addClass([\n            document.documentElement,\n            document.body\n        ], swalClasses.shown);\n        if (params.heightAuto && params.backdrop && !params.toast) {\n            addClass([\n                document.documentElement,\n                document.body\n            ], swalClasses[\"height-auto\"]);\n        }\n    };\n    var defaultInputValidators = {\n        /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */ email: (string, validationMessage)=>{\n            return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n        },\n        /**\n     * @param {string} string\n     * @param {string} validationMessage\n     * @returns {Promise<void | string>}\n     */ url: (string, validationMessage)=>{\n            // taken from https://stackoverflow.com/a/3809435 with a small change from #1306 and #2013\n            return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n        }\n    };\n    /**\n   * @param {SweetAlertOptions} params\n   */ function setDefaultInputValidators(params) {\n        // Use default `inputValidator` for supported input types if not provided\n        if (!params.inputValidator) {\n            Object.keys(defaultInputValidators).forEach((key)=>{\n                if (params.input === key) {\n                    params.inputValidator = defaultInputValidators[key];\n                }\n            });\n        }\n    }\n    /**\n   * @param {SweetAlertOptions} params\n   */ function validateCustomTargetElement(params) {\n        // Determine if the custom target element is valid\n        if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n            warn('Target parameter is not valid, defaulting to \"body\"');\n            params.target = \"body\";\n        }\n    }\n    /**\n   * Set type, text and actions on popup\n   *\n   * @param {SweetAlertOptions} params\n   */ function setParameters(params) {\n        setDefaultInputValidators(params);\n        // showLoaderOnConfirm && preConfirm\n        if (params.showLoaderOnConfirm && !params.preConfirm) {\n            warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\n\" + \"showLoaderOnConfirm should be used together with preConfirm, see usage example:\\n\" + \"https://sweetalert2.github.io/#ajax-request\");\n        }\n        validateCustomTargetElement(params);\n        // Replace newlines with <br> in title\n        if (typeof params.title === \"string\") {\n            params.title = params.title.split(\"\\n\").join(\"<br />\");\n        }\n        init(params);\n    }\n    let currentInstance;\n    class SweetAlert {\n        constructor(){\n            // Prevent run in Node env\n            if (true) {\n                return;\n            }\n            currentInstance = this;\n            // @ts-ignore\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            const outerParams = Object.freeze(this.constructor.argsToParams(args));\n            Object.defineProperties(this, {\n                params: {\n                    value: outerParams,\n                    writable: false,\n                    enumerable: true,\n                    configurable: true\n                }\n            });\n            // @ts-ignore\n            const promise = currentInstance._main(currentInstance.params);\n            privateProps.promise.set(this, promise);\n        }\n        _main(userParams) {\n            let mixinParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            showWarningsForParams(Object.assign({}, mixinParams, userParams));\n            if (globalState.currentInstance) {\n                // @ts-ignore\n                globalState.currentInstance._destroy();\n                if (isModal()) {\n                    unsetAriaHidden();\n                }\n            }\n            globalState.currentInstance = currentInstance;\n            const innerParams = prepareParams(userParams, mixinParams);\n            setParameters(innerParams);\n            Object.freeze(innerParams);\n            // clear the previous timer\n            if (globalState.timeout) {\n                globalState.timeout.stop();\n                delete globalState.timeout;\n            }\n            // clear the restore focus timeout\n            clearTimeout(globalState.restoreFocusTimeout);\n            const domCache = populateDomCache(currentInstance);\n            render(currentInstance, innerParams);\n            privateProps.innerParams.set(currentInstance, innerParams);\n            return swalPromise(currentInstance, domCache, innerParams);\n        }\n        // `catch` cannot be the name of a module export, so we define our thenable methods here instead\n        then(onFulfilled) {\n            const promise = privateProps.promise.get(this);\n            return promise.then(onFulfilled);\n        }\n        finally(onFinally) {\n            const promise = privateProps.promise.get(this);\n            return promise.finally(onFinally);\n        }\n    }\n    /**\n   * @param {SweetAlert2} instance\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   * @returns {Promise}\n   */ const swalPromise = (instance, domCache, innerParams)=>{\n        return new Promise((resolve, reject)=>{\n            // functions to handle all closings/dismissals\n            /**\n       * @param {DismissReason} dismiss\n       */ const dismissWith = (dismiss)=>{\n                // @ts-ignore\n                instance.close({\n                    isDismissed: true,\n                    dismiss\n                });\n            };\n            privateMethods.swalPromiseResolve.set(instance, resolve);\n            privateMethods.swalPromiseReject.set(instance, reject);\n            domCache.confirmButton.onclick = ()=>{\n                handleConfirmButtonClick(instance);\n            };\n            domCache.denyButton.onclick = ()=>{\n                handleDenyButtonClick(instance);\n            };\n            domCache.cancelButton.onclick = ()=>{\n                handleCancelButtonClick(instance, dismissWith);\n            };\n            domCache.closeButton.onclick = ()=>{\n                // @ts-ignore\n                dismissWith(DismissReason.close);\n            };\n            handlePopupClick(instance, domCache, dismissWith);\n            addKeydownHandler(instance, globalState, innerParams, dismissWith);\n            handleInputOptionsAndValue(instance, innerParams);\n            openPopup(innerParams);\n            setupTimer(globalState, innerParams, dismissWith);\n            initFocus(domCache, innerParams);\n            // Scroll container to top on open (#1247, #1946)\n            setTimeout(()=>{\n                domCache.container.scrollTop = 0;\n            });\n        });\n    };\n    /**\n   * @param {SweetAlertOptions} userParams\n   * @param {SweetAlertOptions} mixinParams\n   * @returns {SweetAlertOptions}\n   */ const prepareParams = (userParams, mixinParams)=>{\n        const templateParams = getTemplateParams(userParams);\n        const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams); // precedence is described in #2131\n        params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n        params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n        return params;\n    };\n    /**\n   * @param {SweetAlert2} instance\n   * @returns {DomCache}\n   */ const populateDomCache = (instance)=>{\n        const domCache = {\n            popup: getPopup(),\n            container: getContainer(),\n            actions: getActions(),\n            confirmButton: getConfirmButton(),\n            denyButton: getDenyButton(),\n            cancelButton: getCancelButton(),\n            loader: getLoader(),\n            closeButton: getCloseButton(),\n            validationMessage: getValidationMessage(),\n            progressSteps: getProgressSteps()\n        };\n        privateProps.domCache.set(instance, domCache);\n        return domCache;\n    };\n    /**\n   * @param {GlobalState} globalState\n   * @param {SweetAlertOptions} innerParams\n   * @param {Function} dismissWith\n   */ const setupTimer = (globalState, innerParams, dismissWith)=>{\n        const timerProgressBar = getTimerProgressBar();\n        hide(timerProgressBar);\n        if (innerParams.timer) {\n            globalState.timeout = new Timer(()=>{\n                dismissWith(\"timer\");\n                delete globalState.timeout;\n            }, innerParams.timer);\n            if (innerParams.timerProgressBar) {\n                show(timerProgressBar);\n                applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n                setTimeout(()=>{\n                    if (globalState.timeout && globalState.timeout.running) {\n                        // timer can be already stopped or unset at this point\n                        animateTimerProgressBar(innerParams.timer);\n                    }\n                });\n            }\n        }\n    };\n    /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   */ const initFocus = (domCache, innerParams)=>{\n        if (innerParams.toast) {\n            return;\n        }\n        if (!callIfFunction(innerParams.allowEnterKey)) {\n            blurActiveElement();\n            return;\n        }\n        if (!focusButton(domCache, innerParams)) {\n            setFocus(innerParams, -1, 1);\n        }\n    };\n    /**\n   * @param {DomCache} domCache\n   * @param {SweetAlertOptions} innerParams\n   * @returns {boolean}\n   */ const focusButton = (domCache, innerParams)=>{\n        if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {\n            domCache.denyButton.focus();\n            return true;\n        }\n        if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {\n            domCache.cancelButton.focus();\n            return true;\n        }\n        if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {\n            domCache.confirmButton.focus();\n            return true;\n        }\n        return false;\n    };\n    const blurActiveElement = ()=>{\n        if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n            document.activeElement.blur();\n        }\n    };\n    // Dear russian users visiting russian sites. Let's have fun.\n    if (false) {}\n    // Assign instance methods from src/instanceMethods/*.js to prototype\n    Object.assign(SweetAlert.prototype, instanceMethods);\n    // Assign static methods from src/staticMethods/*.js to constructor\n    Object.assign(SweetAlert, staticMethods);\n    // Proxy to instance methods to constructor, for now, for backwards compatibility\n    Object.keys(instanceMethods).forEach((key)=>{\n        /**\n     * @param {...any} args\n     * @returns {any}\n     */ SweetAlert[key] = function() {\n            if (currentInstance) {\n                return currentInstance[key](...arguments);\n            }\n        };\n    });\n    SweetAlert.DismissReason = DismissReason;\n    SweetAlert.version = \"11.6.13\";\n    const Swal = SweetAlert;\n    // @ts-ignore\n    Swal.default = Swal;\n    return Swal;\n});\nif (typeof this !== \"undefined\" && this.Sweetalert2) {\n    this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2;\n}\n\"undefined\" != typeof document && function(e, t) {\n    var n = e.createElement(\"style\");\n    if (e.getElementsByTagName(\"head\")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);\n    else try {\n        n.innerHTML = t;\n    } catch (e) {\n        n.innerText = t;\n    }\n}(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:\"top-start     top            top-end\" \"center-start  center         center-end\" \"bottom-start  bottom-center  bottom-end\";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:rgba(0,0,0,0) !important}.swal2-container.swal2-top-start,.swal2-container.swal2-center-start,.swal2-container.swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}.swal2-container.swal2-top,.swal2-container.swal2-center,.swal2-container.swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}.swal2-container.swal2-top-end,.swal2-container.swal2-center-end,.swal2-container.swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-start>.swal2-popup,.swal2-container.swal2-center-left>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-start>.swal2-popup,.swal2-container.swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-row>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none !important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:none}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:none}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:rgba(0,0,0,0);color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:rgba(0,0,0,0);color:#f27474}.swal2-close:focus{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-input,.swal2-file,.swal2-textarea,.swal2-select,.swal2-radio,.swal2-checkbox{margin:1em 2em 3px}.swal2-input,.swal2-file,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:rgba(0,0,0,0);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}.swal2-input.swal2-inputerror,.swal2-file.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}.swal2-input:focus,.swal2-file:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-input::placeholder,.swal2-file::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:rgba(0,0,0,0);font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:rgba(0,0,0,0);color:inherit;font-size:1.125em}.swal2-radio,.swal2-checkbox{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-radio label,.swal2-checkbox label{margin:0 .6em;font-size:1.125em}.swal2-radio input,.swal2-checkbox input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:\"!\";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:0.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:swal2-show .3s}.swal2-hide{animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static !important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dlZXRhbGVydDIvZGlzdC9zd2VldGFsZXJ0Mi5hbGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7OztBQUdBLEdBQ0MsVUFBVUEsTUFBTSxFQUFFQyxPQUFPO0lBQ3hCLEtBQWlELEdBQWNFLE9BQU9ELE9BQU8sR0FBR0QsWUFDaEYsQ0FDeUc7QUFDM0csR0FBRyxJQUFJLEVBQUc7SUFBYztJQUV0Qjs7Ozs7Ozs7R0FRQyxHQUVELElBQUlRLGVBQWU7UUFDakJDLGlCQUFpQixJQUFJQztRQUNyQkMsU0FBUyxJQUFJRDtRQUNiRSxhQUFhLElBQUlGO1FBQ2pCRyxVQUFVLElBQUlIO0lBQ2hCO0lBRUEsTUFBTUksYUFBYTtJQUVuQjs7O0dBR0MsR0FDRCxNQUFNQyxTQUFTQyxDQUFBQTtRQUNiLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFLLE1BQU1DLEtBQUtGLE1BQU87WUFDckJDLE1BQU0sQ0FBQ0QsS0FBSyxDQUFDRSxFQUFFLENBQUMsR0FBR0osYUFBYUUsS0FBSyxDQUFDRSxFQUFFO1FBQzFDO1FBQ0EsT0FBT0Q7SUFDVDtJQUNBLE1BQU1FLGNBQWNKLE9BQU87UUFBQztRQUFhO1FBQVM7UUFBZTtRQUFVO1FBQVM7UUFBUztRQUFlO1FBQWlCO1FBQVM7UUFBZTtRQUFRO1FBQVE7UUFBUztRQUFTO1FBQWtCO1FBQVc7UUFBVztRQUFRO1FBQVU7UUFBbUI7UUFBVTtRQUFRO1FBQWdCO1FBQVM7UUFBUztRQUFRO1FBQVM7UUFBVTtRQUFTO1FBQVk7UUFBUztRQUFZO1FBQWM7UUFBZTtRQUFzQjtRQUFrQjtRQUF3QjtRQUFpQjtRQUFzQjtRQUFVO1FBQVc7UUFBVTtRQUFPO1FBQWE7UUFBVztRQUFZO1FBQWE7UUFBVTtRQUFnQjtRQUFjO1FBQWU7UUFBZ0I7UUFBVTtRQUFnQjtRQUFjO1FBQWU7UUFBZ0I7UUFBWTtRQUFlO1FBQW1CO1FBQU87UUFBc0I7UUFBZ0M7UUFBcUI7UUFBZ0I7UUFBZ0I7UUFBYTtRQUFpQjtLQUFhO0lB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O1lBQ2hCLElBQUlsTixpQkFBaUI7Z0JBQ25CLE9BQU9BLGVBQWUsQ0FBQ2tOLElBQUksSUFBSXpRO1lBQ2pDO1FBQ0Y7SUFDRjtJQUNBbWlCLFdBQVdqVCxhQUFhLEdBQUdBO0lBQzNCaVQsV0FBVytCLE9BQU8sR0FBRztJQUVyQixNQUFNcEssT0FBT3FJO0lBQ2IsYUFBYTtJQUNickksS0FBS3FLLE9BQU8sR0FBR3JLO0lBRWYsT0FBT0E7QUFFVDtBQUNBLElBQUksT0FBTyxJQUFJLEtBQUssZUFBZSxJQUFJLENBQUNoa0IsV0FBVyxFQUFDO0lBQUMsU0FBUyxHQUFHLGVBQWUsR0FBRyxTQUFTLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQ0EsV0FBVztBQUFBO0FBQ2pJLGVBQWEsT0FBTzZDLFlBQVUsU0FBU21YLENBQUMsRUFBQ3dVLENBQUM7SUFBRSxJQUFJN0YsSUFBRTNPLEVBQUV4TCxhQUFhLENBQUM7SUFBUyxJQUFHd0wsRUFBRXlVLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUNsbkIsV0FBVyxDQUFDb2hCLElBQUdBLEVBQUUrRixVQUFVLEVBQUMvRixFQUFFK0YsVUFBVSxDQUFDbmEsUUFBUSxJQUFHb1UsQ0FBQUEsRUFBRStGLFVBQVUsQ0FBQ0MsT0FBTyxHQUFDSCxDQUFBQTtTQUFRLElBQUc7UUFBQzdGLEVBQUV2UyxTQUFTLEdBQUNvWTtJQUFDLEVBQUMsT0FBTXhVLEdBQUU7UUFBQzJPLEVBQUVoVixTQUFTLEdBQUM2YTtJQUFDO0FBQUMsRUFBRTNyQixVQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaG9tZXBhZ2UtbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3N3ZWV0YWxlcnQyL2Rpc3Qvc3dlZXRhbGVydDIuYWxsLmpzPzEzMWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIHN3ZWV0YWxlcnQyIHYxMS42LjEzXG4qIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Td2VldGFsZXJ0MiA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIGBXZWFrTWFwYHMgZm9yIGVhY2ggZWZmZWN0aXZlbHktXCJwcml2YXRlICBwcm9wZXJ0eVwiIHRoYXQgYSBgU3dhbGAgaGFzLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gc2V0IHRoZSBwcml2YXRlIHByb3BlcnR5IFwiZm9vXCIgb2YgYHRoaXNgIHRvIFwiYmFyXCIsIHlvdSBjYW4gYHByaXZhdGVQcm9wcy5mb28uc2V0KHRoaXMsICdiYXInKWBcbiAgICogVGhpcyBpcyB0aGUgYXBwcm9hY2ggdGhhdCBCYWJlbCB3aWxsIHByb2JhYmx5IHRha2UgdG8gaW1wbGVtZW50IHByaXZhdGUgbWV0aG9kcy9maWVsZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcml2YXRlLW1ldGhvZHNcbiAgICogICBodHRwczovL2dpdGh1Yi5jb20vYmFiZWwvYmFiZWwvcHVsbC83NTU1XG4gICAqIE9uY2Ugd2UgaGF2ZSB0aGUgY2hhbmdlcyBmcm9tIHRoYXQgUFIgaW4gQmFiZWwsIGFuZCBvdXIgY29yZSBjbGFzcyBmaXRzIHJlYXNvbmFibGUgaW4gKm9uZSBtb2R1bGUqXG4gICAqICAgdGhlbiB3ZSBjYW4gdXNlIHRoYXQgbGFuZ3VhZ2UgZmVhdHVyZS5cbiAgICovXG5cbiAgdmFyIHByaXZhdGVQcm9wcyA9IHtcbiAgICBhd2FpdGluZ1Byb21pc2U6IG5ldyBXZWFrTWFwKCksXG4gICAgcHJvbWlzZTogbmV3IFdlYWtNYXAoKSxcbiAgICBpbm5lclBhcmFtczogbmV3IFdlYWtNYXAoKSxcbiAgICBkb21DYWNoZTogbmV3IFdlYWtNYXAoKVxuICB9O1xuXG4gIGNvbnN0IHN3YWxQcmVmaXggPSAnc3dhbDItJztcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gaXRlbXNcbiAgICogQHJldHVybnMge29iamVjdH1cbiAgICovXG4gIGNvbnN0IHByZWZpeCA9IGl0ZW1zID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaXRlbXMpIHtcbiAgICAgIHJlc3VsdFtpdGVtc1tpXV0gPSBzd2FsUHJlZml4ICsgaXRlbXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIGNvbnN0IHN3YWxDbGFzc2VzID0gcHJlZml4KFsnY29udGFpbmVyJywgJ3Nob3duJywgJ2hlaWdodC1hdXRvJywgJ2lvc2ZpeCcsICdwb3B1cCcsICdtb2RhbCcsICduby1iYWNrZHJvcCcsICduby10cmFuc2l0aW9uJywgJ3RvYXN0JywgJ3RvYXN0LXNob3duJywgJ3Nob3cnLCAnaGlkZScsICdjbG9zZScsICd0aXRsZScsICdodG1sLWNvbnRhaW5lcicsICdhY3Rpb25zJywgJ2NvbmZpcm0nLCAnZGVueScsICdjYW5jZWwnLCAnZGVmYXVsdC1vdXRsaW5lJywgJ2Zvb3RlcicsICdpY29uJywgJ2ljb24tY29udGVudCcsICdpbWFnZScsICdpbnB1dCcsICdmaWxlJywgJ3JhbmdlJywgJ3NlbGVjdCcsICdyYWRpbycsICdjaGVja2JveCcsICdsYWJlbCcsICd0ZXh0YXJlYScsICdpbnB1dGVycm9yJywgJ2lucHV0LWxhYmVsJywgJ3ZhbGlkYXRpb24tbWVzc2FnZScsICdwcm9ncmVzcy1zdGVwcycsICdhY3RpdmUtcHJvZ3Jlc3Mtc3RlcCcsICdwcm9ncmVzcy1zdGVwJywgJ3Byb2dyZXNzLXN0ZXAtbGluZScsICdsb2FkZXInLCAnbG9hZGluZycsICdzdHlsZWQnLCAndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdjZW50ZXInLCAnY2VudGVyLXN0YXJ0JywgJ2NlbnRlci1lbmQnLCAnY2VudGVyLWxlZnQnLCAnY2VudGVyLXJpZ2h0JywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnLCAnZ3Jvdy1yb3cnLCAnZ3Jvdy1jb2x1bW4nLCAnZ3Jvdy1mdWxsc2NyZWVuJywgJ3J0bCcsICd0aW1lci1wcm9ncmVzcy1iYXInLCAndGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcicsICdzY3JvbGxiYXItbWVhc3VyZScsICdpY29uLXN1Y2Nlc3MnLCAnaWNvbi13YXJuaW5nJywgJ2ljb24taW5mbycsICdpY29uLXF1ZXN0aW9uJywgJ2ljb24tZXJyb3InXSk7XG4gIGNvbnN0IGljb25UeXBlcyA9IHByZWZpeChbJ3N1Y2Nlc3MnLCAnd2FybmluZycsICdpbmZvJywgJ3F1ZXN0aW9uJywgJ2Vycm9yJ10pO1xuXG4gIGNvbnN0IGNvbnNvbGVQcmVmaXggPSAnU3dlZXRBbGVydDI6JztcblxuICAvKipcbiAgICogRmlsdGVyIHRoZSB1bmlxdWUgdmFsdWVzIGludG8gYSBuZXcgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICovXG4gIGNvbnN0IHVuaXF1ZUFycmF5ID0gYXJyID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlc3VsdC5pbmRleE9mKGFycltpXSkgPT09IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemUgdGhlIGZpcnN0IGxldHRlciBvZiBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBjYXBpdGFsaXplRmlyc3RMZXR0ZXIgPSBzdHIgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuXG4gIC8qKlxuICAgKiBTdGFuZGFyZGl6ZSBjb25zb2xlIHdhcm5pbmdzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgQXJyYXl9IG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0IHdhcm4gPSBtZXNzYWdlID0+IHtcbiAgICBjb25zb2xlLndhcm4oYCR7Y29uc29sZVByZWZpeH0gJHt0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcgPyBtZXNzYWdlLmpvaW4oJyAnKSA6IG1lc3NhZ2V9YCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkaXplIGNvbnNvbGUgZXJyb3JzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqL1xuICBjb25zdCBlcnJvciA9IG1lc3NhZ2UgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoYCR7Y29uc29sZVByZWZpeH0gJHttZXNzYWdlfWApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGdsb2JhbCBzdGF0ZSBmb3IgYHdhcm5PbmNlYFxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdCBwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMgPSBbXTtcblxuICAvKipcbiAgICogU2hvdyBhIGNvbnNvbGUgd2FybmluZywgYnV0IG9ubHkgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzaG93blxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgKi9cbiAgY29uc3Qgd2Fybk9uY2UgPSBtZXNzYWdlID0+IHtcbiAgICBpZiAoIXByZXZpb3VzV2Fybk9uY2VNZXNzYWdlcy5pbmNsdWRlcyhtZXNzYWdlKSkge1xuICAgICAgcHJldmlvdXNXYXJuT25jZU1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICB3YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2hvdyBhIG9uZS10aW1lIGNvbnNvbGUgd2FybmluZyBhYm91dCBkZXByZWNhdGVkIHBhcmFtcy9tZXRob2RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXByZWNhdGVkUGFyYW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZUluc3RlYWRcbiAgICovXG4gIGNvbnN0IHdhcm5BYm91dERlcHJlY2F0aW9uID0gKGRlcHJlY2F0ZWRQYXJhbSwgdXNlSW5zdGVhZCkgPT4ge1xuICAgIHdhcm5PbmNlKGBcIiR7ZGVwcmVjYXRlZFBhcmFtfVwiIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLiBQbGVhc2UgdXNlIFwiJHt1c2VJbnN0ZWFkfVwiIGluc3RlYWQuYCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElmIGBhcmdgIGlzIGEgZnVuY3Rpb24sIGNhbGwgaXQgKHdpdGggbm8gYXJndW1lbnRzIG9yIGNvbnRleHQpIGFuZCByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICogT3RoZXJ3aXNlLCBqdXN0IHBhc3MgdGhlIHZhbHVlIHRocm91Z2hcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbiB8IGFueX0gYXJnXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICBjb25zdCBjYWxsSWZGdW5jdGlvbiA9IGFyZyA9PiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhcmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBoYXNUb1Byb21pc2VGbiA9IGFyZyA9PiBhcmcgJiYgdHlwZW9mIGFyZy50b1Byb21pc2UgPT09ICdmdW5jdGlvbic7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhcmdcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBjb25zdCBhc1Byb21pc2UgPSBhcmcgPT4gaGFzVG9Qcm9taXNlRm4oYXJnKSA/IGFyZy50b1Byb21pc2UoKSA6IFByb21pc2UucmVzb2x2ZShhcmcpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYXJnXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNQcm9taXNlID0gYXJnID0+IGFyZyAmJiBQcm9taXNlLnJlc29sdmUoYXJnKSA9PT0gYXJnO1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwb3B1cCBjb250YWluZXIgd2hpY2ggY29udGFpbnMgdGhlIGJhY2tkcm9wIGFuZCB0aGUgcG9wdXAgaXRzZWxmLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q29udGFpbmVyID0gKCkgPT4gZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5jb250YWluZXJ9YCk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclN0cmluZ1xuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZWxlbWVudEJ5U2VsZWN0b3IgPSBzZWxlY3RvclN0cmluZyA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lciA/IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKSA6IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGVsZW1lbnRCeUNsYXNzID0gY2xhc3NOYW1lID0+IHtcbiAgICByZXR1cm4gZWxlbWVudEJ5U2VsZWN0b3IoYC4ke2NsYXNzTmFtZX1gKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldFBvcHVwID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMucG9wdXApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SWNvbiA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmljb24pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SWNvbkNvbnRlbnQgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1snaWNvbi1jb250ZW50J10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0VGl0bGUgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy50aXRsZSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRIdG1sQ29udGFpbmVyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SW1hZ2UgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5pbWFnZSk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRQcm9ncmVzc1N0ZXBzID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXBzJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0VmFsaWRhdGlvbk1lc3NhZ2UgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q29uZmlybUJ1dHRvbiA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5jb25maXJtfWApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0RGVueUJ1dHRvbiA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfSAuJHtzd2FsQ2xhc3Nlcy5kZW55fWApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0SW5wdXRMYWJlbCA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddKTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldExvYWRlciA9ICgpID0+IGVsZW1lbnRCeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5sb2FkZXJ9YCk7XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRDYW5jZWxCdXR0b24gPSAoKSA9PiBlbGVtZW50QnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMuYWN0aW9uc30gLiR7c3dhbENsYXNzZXMuY2FuY2VsfWApO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0QWN0aW9ucyA9ICgpID0+IGVsZW1lbnRCeUNsYXNzKHN3YWxDbGFzc2VzLmFjdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Rm9vdGVyID0gKCkgPT4gZWxlbWVudEJ5Q2xhc3Moc3dhbENsYXNzZXMuZm9vdGVyKTtcblxuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlc1sndGltZXItcHJvZ3Jlc3MtYmFyJ10pO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0Q2xvc2VCdXR0b24gPSAoKSA9PiBlbGVtZW50QnlDbGFzcyhzd2FsQ2xhc3Nlcy5jbG9zZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2prdXAvZm9jdXNhYmxlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4gIGNvbnN0IGZvY3VzYWJsZSA9IGBcbiAgYVtocmVmXSxcbiAgYXJlYVtocmVmXSxcbiAgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLFxuICBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLFxuICB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksXG4gIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksXG4gIGlmcmFtZSxcbiAgb2JqZWN0LFxuICBlbWJlZCxcbiAgW3RhYmluZGV4PVwiMFwiXSxcbiAgW2NvbnRlbnRlZGl0YWJsZV0sXG4gIGF1ZGlvW2NvbnRyb2xzXSxcbiAgdmlkZW9bY29udHJvbHNdLFxuICBzdW1tYXJ5XG5gO1xuICAvKipcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XG4gICAqL1xuICBjb25zdCBnZXRGb2N1c2FibGVFbGVtZW50cyA9ICgpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCA9IEFycmF5LmZyb20oZ2V0UG9wdXAoKS5xdWVyeVNlbGVjdG9yQWxsKCdbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSk6bm90KFt0YWJpbmRleD1cIjBcIl0pJykpXG4gICAgLy8gc29ydCBhY2NvcmRpbmcgdG8gdGFiaW5kZXhcbiAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgdGFiaW5kZXhBID0gcGFyc2VJbnQoYS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICAgICAgY29uc3QgdGFiaW5kZXhCID0gcGFyc2VJbnQoYi5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICAgICAgaWYgKHRhYmluZGV4QSA+IHRhYmluZGV4Qikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodGFiaW5kZXhBIDwgdGFiaW5kZXhCKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIGNvbnN0IG90aGVyRm9jdXNhYmxlRWxlbWVudHMgPSBBcnJheS5mcm9tKGdldFBvcHVwKCkucXVlcnlTZWxlY3RvckFsbChmb2N1c2FibGUpKS5maWx0ZXIoZWwgPT4gZWwuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpICE9PSAnLTEnKTtcbiAgICByZXR1cm4gdW5pcXVlQXJyYXkoZm9jdXNhYmxlRWxlbWVudHNXaXRoVGFiaW5kZXguY29uY2F0KG90aGVyRm9jdXNhYmxlRWxlbWVudHMpKS5maWx0ZXIoZWwgPT4gaXNWaXNpYmxlJDEoZWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc01vZGFsID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5zaG93bikgJiYgIWhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzWyd0b2FzdC1zaG93biddKSAmJiAhaGFzQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXNbJ25vLWJhY2tkcm9wJ10pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzVG9hc3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFBvcHVwKCkgJiYgaGFzQ2xhc3MoZ2V0UG9wdXAoKSwgc3dhbENsYXNzZXMudG9hc3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzTG9hZGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gZ2V0UG9wdXAoKS5oYXNBdHRyaWJ1dGUoJ2RhdGEtbG9hZGluZycpO1xuICB9O1xuXG4gIC8vIFJlbWVtYmVyIHN0YXRlIGluIGNhc2VzIHdoZXJlIG9wZW5pbmcgYW5kIGhhbmRsaW5nIGEgbW9kYWwgd2lsbCBmaWRkbGUgd2l0aCBpdC5cbiAgY29uc3Qgc3RhdGVzID0ge1xuICAgIHByZXZpb3VzQm9keVBhZGRpbmc6IG51bGxcbiAgfTtcblxuICAvKipcbiAgICogU2VjdXJlbHkgc2V0IGlubmVySFRNTCBvZiBhbiBlbGVtZW50XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTkyNlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAqL1xuICBjb25zdCBzZXRJbm5lckh0bWwgPSAoZWxlbSwgaHRtbCkgPT4ge1xuICAgIGVsZW0udGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAoaHRtbCkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhodG1sLCBgdGV4dC9odG1sYCk7XG4gICAgICBBcnJheS5mcm9tKHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdoZWFkJykuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgICBBcnJheS5mcm9tKHBhcnNlZC5xdWVyeVNlbGVjdG9yKCdib2R5JykuY2hpbGROb2RlcykuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQgfHwgY2hpbGQgaW5zdGFuY2VvZiBIVE1MQXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgZWxlbS5hcHBlbmRDaGlsZChjaGlsZC5jbG9uZU5vZGUodHJ1ZSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzI1MDdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBoYXNDbGFzcyA9IChlbGVtLCBjbGFzc05hbWUpID0+IHtcbiAgICBpZiAoIWNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0xpc3QgPSBjbGFzc05hbWUuc3BsaXQoL1xccysvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFlbGVtLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc0xpc3RbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW1vdmVDdXN0b21DbGFzc2VzID0gKGVsZW0sIHBhcmFtcykgPT4ge1xuICAgIEFycmF5LmZyb20oZWxlbS5jbGFzc0xpc3QpLmZvckVhY2goY2xhc3NOYW1lID0+IHtcbiAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhzd2FsQ2xhc3NlcykuaW5jbHVkZXMoY2xhc3NOYW1lKSAmJiAhT2JqZWN0LnZhbHVlcyhpY29uVHlwZXMpLmluY2x1ZGVzKGNsYXNzTmFtZSkgJiYgIU9iamVjdC52YWx1ZXMocGFyYW1zLnNob3dDbGFzcykuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgY29uc3QgYXBwbHlDdXN0b21DbGFzcyA9IChlbGVtLCBwYXJhbXMsIGNsYXNzTmFtZSkgPT4ge1xuICAgIHJlbW92ZUN1c3RvbUNsYXNzZXMoZWxlbSwgcGFyYW1zKTtcbiAgICBpZiAocGFyYW1zLmN1c3RvbUNsYXNzICYmIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdKSB7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcy5jdXN0b21DbGFzc1tjbGFzc05hbWVdICE9PSAnc3RyaW5nJyAmJiAhcGFyYW1zLmN1c3RvbUNsYXNzW2NsYXNzTmFtZV0uZm9yRWFjaCkge1xuICAgICAgICB3YXJuKGBJbnZhbGlkIHR5cGUgb2YgY3VzdG9tQ2xhc3MuJHtjbGFzc05hbWV9ISBFeHBlY3RlZCBzdHJpbmcgb3IgaXRlcmFibGUgb2JqZWN0LCBnb3QgXCIke3R5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXX1cImApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhZGRDbGFzcyhlbGVtLCBwYXJhbXMuY3VzdG9tQ2xhc3NbY2xhc3NOYW1lXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9yZW5kZXJlcnMvcmVuZGVySW5wdXQnKS5JbnB1dENsYXNzfSBpbnB1dENsYXNzXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50IHwgbnVsbH1cbiAgICovXG4gIGNvbnN0IGdldElucHV0JDEgPSAocG9wdXAsIGlucHV0Q2xhc3MpID0+IHtcbiAgICBpZiAoIWlucHV0Q2xhc3MpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzd2l0Y2ggKGlucHV0Q2xhc3MpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBjYXNlICdmaWxlJzpcbiAgICAgICAgcmV0dXJuIHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzW2lucHV0Q2xhc3NdfWApO1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuY2hlY2tib3h9IGlucHV0YCk7XG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5wb3B1cH0gPiAuJHtzd2FsQ2xhc3Nlcy5yYWRpb30gaW5wdXQ6Y2hlY2tlZGApIHx8IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnBvcHVwfSA+IC4ke3N3YWxDbGFzc2VzLnJhZGlvfSBpbnB1dDpmaXJzdC1jaGlsZGApO1xuICAgICAgY2FzZSAncmFuZ2UnOlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMucmFuZ2V9IGlucHV0YCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gcG9wdXAucXVlcnlTZWxlY3RvcihgLiR7c3dhbENsYXNzZXMucG9wdXB9ID4gLiR7c3dhbENsYXNzZXMuaW5wdXR9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MVGV4dEFyZWFFbGVtZW50IHwgSFRNTFNlbGVjdEVsZW1lbnR9IGlucHV0XG4gICAqL1xuICBjb25zdCBmb2N1c0lucHV0ID0gaW5wdXQgPT4ge1xuICAgIGlucHV0LmZvY3VzKCk7XG5cbiAgICAvLyBwbGFjZSBjdXJzb3IgYXQgZW5kIG9mIHRleHQgaW4gdGV4dCBpbnB1dFxuICAgIGlmIChpbnB1dC50eXBlICE9PSAnZmlsZScpIHtcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIzNDU5MTVcbiAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlO1xuICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgIGlucHV0LnZhbHVlID0gdmFsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IEhUTUxFbGVtZW50W10gfCBudWxsfSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXSB8IHJlYWRvbmx5IHN0cmluZ1tdfSBjbGFzc0xpc3RcbiAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb25cbiAgICovXG4gIGNvbnN0IHRvZ2dsZUNsYXNzID0gKHRhcmdldCwgY2xhc3NMaXN0LCBjb25kaXRpb24pID0+IHtcbiAgICBpZiAoIXRhcmdldCB8fCAhY2xhc3NMaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2xhc3NMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH1cbiAgICBjbGFzc0xpc3QuZm9yRWFjaChjbGFzc05hbWUgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgICAgICBjb25kaXRpb24gPyBlbGVtLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSA6IGVsZW0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmRpdGlvbiA/IHRhcmdldC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSkgOiB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgSFRNTEVsZW1lbnRbXSB8IG51bGx9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZyB8IHN0cmluZ1tdIHwgcmVhZG9ubHkgc3RyaW5nW119IGNsYXNzTGlzdFxuICAgKi9cbiAgY29uc3QgYWRkQ2xhc3MgPSAodGFyZ2V0LCBjbGFzc0xpc3QpID0+IHtcbiAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIGNsYXNzTGlzdCwgdHJ1ZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnQgfCBIVE1MRWxlbWVudFtdIHwgbnVsbH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgc3RyaW5nW10gfCByZWFkb25seSBzdHJpbmdbXX0gY2xhc3NMaXN0XG4gICAqL1xuICBjb25zdCByZW1vdmVDbGFzcyA9ICh0YXJnZXQsIGNsYXNzTGlzdCkgPT4ge1xuICAgIHRvZ2dsZUNsYXNzKHRhcmdldCwgY2xhc3NMaXN0LCBmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBkaXJlY3QgY2hpbGQgb2YgYW4gZWxlbWVudCBieSBjbGFzcyBuYW1lXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MgPSAoZWxlbSwgY2xhc3NOYW1lKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBBcnJheS5mcm9tKGVsZW0uY2hpbGRyZW4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBoYXNDbGFzcyhjaGlsZCwgY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBjb25zdCBhcHBseU51bWVyaWNhbFN0eWxlID0gKGVsZW0sIHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gYCR7cGFyc2VJbnQodmFsdWUpfWApIHtcbiAgICAgIHZhbHVlID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgfHwgcGFyc2VJbnQodmFsdWUpID09PSAwKSB7XG4gICAgICBlbGVtLnN0eWxlW3Byb3BlcnR5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gICAqL1xuICBjb25zdCBzaG93ID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBsZXQgZGlzcGxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ2ZsZXgnO1xuICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICovXG4gIGNvbnN0IGhpZGUgPSBlbGVtID0+IHtcbiAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgY29uc3Qgc2V0U3R5bGUgPSAocGFyZW50LCBzZWxlY3RvciwgcHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBjb25zdCBlbCA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcGFyYW0ge2FueX0gY29uZGl0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwbGF5XG4gICAqL1xuICBjb25zdCB0b2dnbGUgPSBmdW5jdGlvbiAoZWxlbSwgY29uZGl0aW9uKSB7XG4gICAgbGV0IGRpc3BsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdmbGV4JztcbiAgICBjb25kaXRpb24gPyBzaG93KGVsZW0sIGRpc3BsYXkpIDogaGlkZShlbGVtKTtcbiAgfTtcblxuICAvKipcbiAgICogYm9ycm93ZWQgZnJvbSBqcXVlcnkgJChlbGVtKS5pcygnOnZpc2libGUnKSBpbXBsZW1lbnRhdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNWaXNpYmxlJDEgPSBlbGVtID0+ICEhKGVsZW0gJiYgKGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpO1xuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGFsbEJ1dHRvbnNBcmVIaWRkZW4gPSAoKSA9PiAhaXNWaXNpYmxlJDEoZ2V0Q29uZmlybUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0RGVueUJ1dHRvbigpKSAmJiAhaXNWaXNpYmxlJDEoZ2V0Q2FuY2VsQnV0dG9uKCkpO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNTY3JvbGxhYmxlID0gZWxlbSA9PiAhIShlbGVtLnNjcm9sbEhlaWdodCA+IGVsZW0uY2xpZW50SGVpZ2h0KTtcblxuICAvKipcbiAgICogYm9ycm93ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYzNTIxMTlcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGhhc0Nzc0FuaW1hdGlvbiA9IGVsZW0gPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgY29uc3QgYW5pbUR1cmF0aW9uID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdhbmltYXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICAgIGNvbnN0IHRyYW5zRHVyYXRpb24gPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3RyYW5zaXRpb24tZHVyYXRpb24nKSB8fCAnMCcpO1xuICAgIHJldHVybiBhbmltRHVyYXRpb24gPiAwIHx8IHRyYW5zRHVyYXRpb24gPiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXJcbiAgICogQHBhcmFtIHtib29sZWFufSByZXNldFxuICAgKi9cbiAgY29uc3QgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIgPSBmdW5jdGlvbiAodGltZXIpIHtcbiAgICBsZXQgcmVzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgaWYgKGlzVmlzaWJsZSQxKHRpbWVyUHJvZ3Jlc3NCYXIpKSB7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS50cmFuc2l0aW9uID0gJ25vbmUnO1xuICAgICAgICB0aW1lclByb2dyZXNzQmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUudHJhbnNpdGlvbiA9IGB3aWR0aCAke3RpbWVyIC8gMTAwMH1zIGxpbmVhcmA7XG4gICAgICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMCUnO1xuICAgICAgfSwgMTApO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgc3RvcFRpbWVyUHJvZ3Jlc3NCYXIgPSAoKSA9PiB7XG4gICAgY29uc3QgdGltZXJQcm9ncmVzc0JhciA9IGdldFRpbWVyUHJvZ3Jlc3NCYXIoKTtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyV2lkdGggPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aW1lclByb2dyZXNzQmFyKS53aWR0aCk7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xuICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY29uc3QgdGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRpbWVyUHJvZ3Jlc3NCYXIpLndpZHRoKTtcbiAgICBjb25zdCB0aW1lclByb2dyZXNzQmFyUGVyY2VudCA9IHRpbWVyUHJvZ3Jlc3NCYXJXaWR0aCAvIHRpbWVyUHJvZ3Jlc3NCYXJGdWxsV2lkdGggKiAxMDA7XG4gICAgdGltZXJQcm9ncmVzc0Jhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xuICAgIHRpbWVyUHJvZ3Jlc3NCYXIuc3R5bGUud2lkdGggPSBgJHt0aW1lclByb2dyZXNzQmFyUGVyY2VudH0lYDtcbiAgfTtcblxuICBjb25zdCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQgPSAxMDA7XG5cbiAgLyoqIEB0eXBlIHtHbG9iYWxTdGF0ZX0gKi9cbiAgY29uc3QgZ2xvYmFsU3RhdGUgPSB7fTtcbiAgY29uc3QgZm9jdXNQcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN0b3JlIHByZXZpb3VzIGFjdGl2ZSAoZm9jdXNlZCkgZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldHVybkZvY3VzXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY29uc3QgcmVzdG9yZUFjdGl2ZUVsZW1lbnQgPSByZXR1cm5Gb2N1cyA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaWYgKCFyZXR1cm5Gb2N1cykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgY29uc3QgeSA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCBSRVNUT1JFX0ZPQ1VTX1RJTUVPVVQpOyAvLyBpc3N1ZXMvOTAwXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZWN0IE5vZGUgZW52XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNOb2RlRW52ID0gKCkgPT4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJztcblxuICBjb25zdCBzd2VldEhUTUwgPSBgXG4gPGRpdiBhcmlhLWxhYmVsbGVkYnk9XCIke3N3YWxDbGFzc2VzLnRpdGxlfVwiIGFyaWEtZGVzY3JpYmVkYnk9XCIke3N3YWxDbGFzc2VzWydodG1sLWNvbnRhaW5lciddfVwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5wb3B1cH1cIiB0YWJpbmRleD1cIi0xXCI+XG4gICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuY2xvc2V9XCI+PC9idXR0b24+XG4gICA8dWwgY2xhc3M9XCIke3N3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwcyddfVwiPjwvdWw+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5pY29ufVwiPjwvZGl2PlxuICAgPGltZyBjbGFzcz1cIiR7c3dhbENsYXNzZXMuaW1hZ2V9XCIgLz5cbiAgIDxoMiBjbGFzcz1cIiR7c3dhbENsYXNzZXMudGl0bGV9XCIgaWQ9XCIke3N3YWxDbGFzc2VzLnRpdGxlfVwiPjwvaDI+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlc1snaHRtbC1jb250YWluZXInXX1cIiBpZD1cIiR7c3dhbENsYXNzZXNbJ2h0bWwtY29udGFpbmVyJ119XCI+PC9kaXY+XG4gICA8aW5wdXQgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmlucHV0fVwiIC8+XG4gICA8aW5wdXQgdHlwZT1cImZpbGVcIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuZmlsZX1cIiAvPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMucmFuZ2V9XCI+XG4gICAgIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiAvPlxuICAgICA8b3V0cHV0Pjwvb3V0cHV0PlxuICAgPC9kaXY+XG4gICA8c2VsZWN0IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5zZWxlY3R9XCI+PC9zZWxlY3Q+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5yYWRpb31cIj48L2Rpdj5cbiAgIDxsYWJlbCBmb3I9XCIke3N3YWxDbGFzc2VzLmNoZWNrYm94fVwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jaGVja2JveH1cIj5cbiAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIC8+XG4gICAgIDxzcGFuIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5sYWJlbH1cIj48L3NwYW4+XG4gICA8L2xhYmVsPlxuICAgPHRleHRhcmVhIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy50ZXh0YXJlYX1cIj48L3RleHRhcmVhPlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddfVwiIGlkPVwiJHtzd2FsQ2xhc3Nlc1sndmFsaWRhdGlvbi1tZXNzYWdlJ119XCI+PC9kaXY+XG4gICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5hY3Rpb25zfVwiPlxuICAgICA8ZGl2IGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5sb2FkZXJ9XCI+PC9kaXY+XG4gICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHtzd2FsQ2xhc3Nlcy5jb25maXJtfVwiPjwvYnV0dG9uPlxuICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuZGVueX1cIj48L2J1dHRvbj5cbiAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3N3YWxDbGFzc2VzLmNhbmNlbH1cIj48L2J1dHRvbj5cbiAgIDwvZGl2PlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXMuZm9vdGVyfVwiPjwvZGl2PlxuICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3RpbWVyLXByb2dyZXNzLWJhci1jb250YWluZXInXX1cIj5cbiAgICAgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ3RpbWVyLXByb2dyZXNzLWJhciddfVwiPjwvZGl2PlxuICAgPC9kaXY+XG4gPC9kaXY+XG5gLnJlcGxhY2UoLyhefFxcbilcXHMqL2csICcnKTtcblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCByZXNldE9sZENvbnRhaW5lciA9ICgpID0+IHtcbiAgICBjb25zdCBvbGRDb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBpZiAoIW9sZENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvbGRDb250YWluZXIucmVtb3ZlKCk7XG4gICAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSwgc3dhbENsYXNzZXNbJ3RvYXN0LXNob3duJ10sIHN3YWxDbGFzc2VzWydoYXMtY29sdW1uJ11dKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxID0gKCkgPT4ge1xuICAgIGdsb2JhbFN0YXRlLmN1cnJlbnRJbnN0YW5jZS5yZXNldFZhbGlkYXRpb25NZXNzYWdlKCk7XG4gIH07XG4gIGNvbnN0IGFkZElucHV0Q2hhbmdlTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICBjb25zdCBpbnB1dCA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMuaW5wdXQpO1xuICAgIGNvbnN0IGZpbGUgPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLmZpbGUpO1xuICAgIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cbiAgICBjb25zdCByYW5nZSA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLnJhbmdlfSBpbnB1dGApO1xuICAgIC8qKiBAdHlwZSB7SFRNTE91dHB1dEVsZW1lbnR9ICovXG4gICAgY29uc3QgcmFuZ2VPdXRwdXQgPSBwb3B1cC5xdWVyeVNlbGVjdG9yKGAuJHtzd2FsQ2xhc3Nlcy5yYW5nZX0gb3V0cHV0YCk7XG4gICAgY29uc3Qgc2VsZWN0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuICAgIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudH0gKi9cbiAgICBjb25zdCBjaGVja2JveCA9IHBvcHVwLnF1ZXJ5U2VsZWN0b3IoYC4ke3N3YWxDbGFzc2VzLmNoZWNrYm94fSBpbnB1dGApO1xuICAgIGNvbnN0IHRleHRhcmVhID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy50ZXh0YXJlYSk7XG4gICAgaW5wdXQub25pbnB1dCA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgICBmaWxlLm9uY2hhbmdlID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICAgIHNlbGVjdC5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgICBjaGVja2JveC5vbmNoYW5nZSA9IHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMTtcbiAgICB0ZXh0YXJlYS5vbmlucHV0ID0gcmVzZXRWYWxpZGF0aW9uTWVzc2FnZSQxO1xuICAgIHJhbmdlLm9uaW5wdXQgPSAoKSA9PiB7XG4gICAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlJDEoKTtcbiAgICAgIHJhbmdlT3V0cHV0LnZhbHVlID0gcmFuZ2UudmFsdWU7XG4gICAgfTtcbiAgICByYW5nZS5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UkMSgpO1xuICAgICAgcmFuZ2VPdXRwdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEhUTUxFbGVtZW50fSB0YXJnZXRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKi9cbiAgY29uc3QgZ2V0VGFyZ2V0ID0gdGFyZ2V0ID0+IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpIDogdGFyZ2V0O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldHVwQWNjZXNzaWJpbGl0eSA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgncm9sZScsIHBhcmFtcy50b2FzdCA/ICdhbGVydCcgOiAnZGlhbG9nJyk7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCBwYXJhbXMudG9hc3QgPyAncG9saXRlJyA6ICdhc3NlcnRpdmUnKTtcbiAgICBpZiAoIXBhcmFtcy50b2FzdCkge1xuICAgICAgcG9wdXAuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgJ3RydWUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnRcbiAgICovXG4gIGNvbnN0IHNldHVwUlRMID0gdGFyZ2V0RWxlbWVudCA9PiB7XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICAgIGFkZENsYXNzKGdldENvbnRhaW5lcigpLCBzd2FsQ2xhc3Nlcy5ydGwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIG1vZGFsICsgYmFja2Ryb3AgKyBuby13YXIgbWVzc2FnZSBmb3IgUnVzc2lhbnMgdG8gRE9NXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgaW5pdCA9IHBhcmFtcyA9PiB7XG4gICAgLy8gQ2xlYW4gdXAgdGhlIG9sZCBwb3B1cCBjb250YWluZXIgaWYgaXQgZXhpc3RzXG4gICAgY29uc3Qgb2xkQ29udGFpbmVyRXhpc3RlZCA9IHJlc2V0T2xkQ29udGFpbmVyKCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNOb2RlRW52KCkpIHtcbiAgICAgIGVycm9yKCdTd2VldEFsZXJ0MiByZXF1aXJlcyBkb2N1bWVudCB0byBpbml0aWFsaXplJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5jb250YWluZXI7XG4gICAgaWYgKG9sZENvbnRhaW5lckV4aXN0ZWQpIHtcbiAgICAgIGFkZENsYXNzKGNvbnRhaW5lciwgc3dhbENsYXNzZXNbJ25vLXRyYW5zaXRpb24nXSk7XG4gICAgfVxuICAgIHNldElubmVySHRtbChjb250YWluZXIsIHN3ZWV0SFRNTCk7XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGdldFRhcmdldChwYXJhbXMudGFyZ2V0KTtcbiAgICB0YXJnZXRFbGVtZW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgc2V0dXBBY2Nlc3NpYmlsaXR5KHBhcmFtcyk7XG4gICAgc2V0dXBSVEwodGFyZ2V0RWxlbWVudCk7XG4gICAgYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudCB8IG9iamVjdCB8IHN0cmluZ30gcGFyYW1cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqL1xuICBjb25zdCBwYXJzZUh0bWxUb0NvbnRhaW5lciA9IChwYXJhbSwgdGFyZ2V0KSA9PiB7XG4gICAgLy8gRE9NIGVsZW1lbnRcbiAgICBpZiAocGFyYW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHBhcmFtKTtcbiAgICB9XG5cbiAgICAvLyBPYmplY3RcbiAgICBlbHNlIGlmICh0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnKSB7XG4gICAgICBoYW5kbGVPYmplY3QocGFyYW0sIHRhcmdldCk7XG4gICAgfVxuXG4gICAgLy8gUGxhaW4gc3RyaW5nXG4gICAgZWxzZSBpZiAocGFyYW0pIHtcbiAgICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbVxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICovXG4gIGNvbnN0IGhhbmRsZU9iamVjdCA9IChwYXJhbSwgdGFyZ2V0KSA9PiB7XG4gICAgLy8gSlF1ZXJ5IGVsZW1lbnQocylcbiAgICBpZiAocGFyYW0uanF1ZXJ5KSB7XG4gICAgICBoYW5kbGVKcXVlcnlFbGVtKHRhcmdldCwgcGFyYW0pO1xuICAgIH1cblxuICAgIC8vIEZvciBvdGhlciBvYmplY3RzIHVzZSB0aGVpciBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBlbHNlIHtcbiAgICAgIHNldElubmVySHRtbCh0YXJnZXQsIHBhcmFtLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1cbiAgICovXG4gIGNvbnN0IGhhbmRsZUpxdWVyeUVsZW0gPSAodGFyZ2V0LCBlbGVtKSA9PiB7XG4gICAgdGFyZ2V0LnRleHRDb250ZW50ID0gJyc7XG4gICAgaWYgKDAgaW4gZWxlbSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IChpIGluIGVsZW0pOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW1baV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKGVsZW0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHsnd2Via2l0QW5pbWF0aW9uRW5kJyB8ICdhbmltYXRpb25lbmQnIHwgZmFsc2V9XG4gICAqL1xuICBjb25zdCBhbmltYXRpb25FbmRFdmVudCA9ICgoKSA9PiB7XG4gICAgLy8gUHJldmVudCBydW4gaW4gTm9kZSBlbnZcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNOb2RlRW52KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVzdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNFbmRFdmVudE5hbWVzID0ge1xuICAgICAgV2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcbiAgICAgIC8vIENocm9tZSwgU2FmYXJpIGFuZCBPcGVyYVxuICAgICAgYW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyAvLyBTdGFuZGFyZCBzeW50YXhcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zRW5kRXZlbnROYW1lcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmFuc0VuZEV2ZW50TmFtZXMsIGkpICYmIHR5cGVvZiB0ZXN0RWwuc3R5bGVbaV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0cmFuc0VuZEV2ZW50TmFtZXNbaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSkoKTtcblxuICAvKipcbiAgICogTWVhc3VyZSBzY3JvbGxiYXIgd2lkdGggZm9yIHBhZGRpbmcgYm9keSBkdXJpbmcgbW9kYWwgc2hvdy9oaWRlXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9qcy9zcmMvbW9kYWwuanNcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGNvbnN0IG1lYXN1cmVTY3JvbGxiYXIgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2Nyb2xsRGl2LmNsYXNzTmFtZSA9IHN3YWxDbGFzc2VzWydzY3JvbGxiYXItbWVhc3VyZSddO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHNjcm9sbERpdik7XG4gICAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlckFjdGlvbnMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGFjdGlvbnMgPSBnZXRBY3Rpb25zKCk7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG5cbiAgICAvLyBBY3Rpb25zIChidXR0b25zKSB3cmFwcGVyXG4gICAgaWYgKCFwYXJhbXMuc2hvd0NvbmZpcm1CdXR0b24gJiYgIXBhcmFtcy5zaG93RGVueUJ1dHRvbiAmJiAhcGFyYW1zLnNob3dDYW5jZWxCdXR0b24pIHtcbiAgICAgIGhpZGUoYWN0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3coYWN0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gQ3VzdG9tIGNsYXNzXG4gICAgYXBwbHlDdXN0b21DbGFzcyhhY3Rpb25zLCBwYXJhbXMsICdhY3Rpb25zJyk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHRoZSBidXR0b25zXG4gICAgcmVuZGVyQnV0dG9ucyhhY3Rpb25zLCBsb2FkZXIsIHBhcmFtcyk7XG5cbiAgICAvLyBMb2FkZXJcbiAgICBzZXRJbm5lckh0bWwobG9hZGVyLCBwYXJhbXMubG9hZGVySHRtbCk7XG4gICAgYXBwbHlDdXN0b21DbGFzcyhsb2FkZXIsIHBhcmFtcywgJ2xvYWRlcicpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBhY3Rpb25zXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGxvYWRlclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIHJlbmRlckJ1dHRvbnMoYWN0aW9ucywgbG9hZGVyLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjb25maXJtQnV0dG9uID0gZ2V0Q29uZmlybUJ1dHRvbigpO1xuICAgIGNvbnN0IGRlbnlCdXR0b24gPSBnZXREZW55QnV0dG9uKCk7XG4gICAgY29uc3QgY2FuY2VsQnV0dG9uID0gZ2V0Q2FuY2VsQnV0dG9uKCk7XG5cbiAgICAvLyBSZW5kZXIgYnV0dG9uc1xuICAgIHJlbmRlckJ1dHRvbihjb25maXJtQnV0dG9uLCAnY29uZmlybScsIHBhcmFtcyk7XG4gICAgcmVuZGVyQnV0dG9uKGRlbnlCdXR0b24sICdkZW55JywgcGFyYW1zKTtcbiAgICByZW5kZXJCdXR0b24oY2FuY2VsQnV0dG9uLCAnY2FuY2VsJywgcGFyYW1zKTtcbiAgICBoYW5kbGVCdXR0b25zU3R5bGluZyhjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b24sIHBhcmFtcyk7XG4gICAgaWYgKHBhcmFtcy5yZXZlcnNlQnV0dG9ucykge1xuICAgICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShjYW5jZWxCdXR0b24sIGNvbmZpcm1CdXR0b24pO1xuICAgICAgICBhY3Rpb25zLmluc2VydEJlZm9yZShkZW55QnV0dG9uLCBjb25maXJtQnV0dG9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGlvbnMuaW5zZXJ0QmVmb3JlKGNhbmNlbEJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoZGVueUJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgICAgYWN0aW9ucy5pbnNlcnRCZWZvcmUoY29uZmlybUJ1dHRvbiwgbG9hZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29uZmlybUJ1dHRvblxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBkZW55QnV0dG9uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNhbmNlbEJ1dHRvblxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUJ1dHRvbnNTdHlsaW5nKGNvbmZpcm1CdXR0b24sIGRlbnlCdXR0b24sIGNhbmNlbEJ1dHRvbiwgcGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMuYnV0dG9uc1N0eWxpbmcpIHtcbiAgICAgIHJlbW92ZUNsYXNzKFtjb25maXJtQnV0dG9uLCBkZW55QnV0dG9uLCBjYW5jZWxCdXR0b25dLCBzd2FsQ2xhc3Nlcy5zdHlsZWQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhZGRDbGFzcyhbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXSwgc3dhbENsYXNzZXMuc3R5bGVkKTtcblxuICAgIC8vIEJ1dHRvbnMgYmFja2dyb3VuZCBjb2xvcnNcbiAgICBpZiAocGFyYW1zLmNvbmZpcm1CdXR0b25Db2xvcikge1xuICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY29uZmlybUJ1dHRvbkNvbG9yO1xuICAgICAgYWRkQ2xhc3MoY29uZmlybUJ1dHRvbiwgc3dhbENsYXNzZXNbJ2RlZmF1bHQtb3V0bGluZSddKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5kZW55QnV0dG9uQ29sb3IpIHtcbiAgICAgIGRlbnlCdXR0b24uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcGFyYW1zLmRlbnlCdXR0b25Db2xvcjtcbiAgICAgIGFkZENsYXNzKGRlbnlCdXR0b24sIHN3YWxDbGFzc2VzWydkZWZhdWx0LW91dGxpbmUnXSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3IpIHtcbiAgICAgIGNhbmNlbEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwYXJhbXMuY2FuY2VsQnV0dG9uQ29sb3I7XG4gICAgICBhZGRDbGFzcyhjYW5jZWxCdXR0b24sIHN3YWxDbGFzc2VzWydkZWZhdWx0LW91dGxpbmUnXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJ1dHRvblxuICAgKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55JyB8ICdjYW5jZWwnfSBidXR0b25UeXBlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyQnV0dG9uKGJ1dHRvbiwgYnV0dG9uVHlwZSwgcGFyYW1zKSB7XG4gICAgdG9nZ2xlKGJ1dHRvbiwgcGFyYW1zW2BzaG93JHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoYnV0dG9uVHlwZSl9QnV0dG9uYF0sICdpbmxpbmUtYmxvY2snKTtcbiAgICBzZXRJbm5lckh0bWwoYnV0dG9uLCBwYXJhbXNbYCR7YnV0dG9uVHlwZX1CdXR0b25UZXh0YF0pOyAvLyBTZXQgY2FwdGlvbiB0ZXh0XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvbkFyaWFMYWJlbGBdKTsgLy8gQVJJQSBsYWJlbFxuXG4gICAgLy8gQWRkIGJ1dHRvbnMgY3VzdG9tIGNsYXNzZXNcbiAgICBidXR0b24uY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbYnV0dG9uVHlwZV07XG4gICAgYXBwbHlDdXN0b21DbGFzcyhidXR0b24sIHBhcmFtcywgYCR7YnV0dG9uVHlwZX1CdXR0b25gKTtcbiAgICBhZGRDbGFzcyhidXR0b24sIHBhcmFtc1tgJHtidXR0b25UeXBlfUJ1dHRvbkNsYXNzYF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyQ2xvc2VCdXR0b24gPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gZ2V0Q2xvc2VCdXR0b24oKTtcbiAgICBzZXRJbm5lckh0bWwoY2xvc2VCdXR0b24sIHBhcmFtcy5jbG9zZUJ1dHRvbkh0bWwpO1xuXG4gICAgLy8gQ3VzdG9tIGNsYXNzXG4gICAgYXBwbHlDdXN0b21DbGFzcyhjbG9zZUJ1dHRvbiwgcGFyYW1zLCAnY2xvc2VCdXR0b24nKTtcbiAgICB0b2dnbGUoY2xvc2VCdXR0b24sIHBhcmFtcy5zaG93Q2xvc2VCdXR0b24pO1xuICAgIGNsb3NlQnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHBhcmFtcy5jbG9zZUJ1dHRvbkFyaWFMYWJlbCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyQ29udGFpbmVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYW5kbGVCYWNrZHJvcFBhcmFtKGNvbnRhaW5lciwgcGFyYW1zLmJhY2tkcm9wKTtcbiAgICBoYW5kbGVQb3NpdGlvblBhcmFtKGNvbnRhaW5lciwgcGFyYW1zLnBvc2l0aW9uKTtcbiAgICBoYW5kbGVHcm93UGFyYW0oY29udGFpbmVyLCBwYXJhbXMuZ3Jvdyk7XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKGNvbnRhaW5lciwgcGFyYW1zLCAnY29udGFpbmVyJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydiYWNrZHJvcCddfSBiYWNrZHJvcFxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlQmFja2Ryb3BQYXJhbShjb250YWluZXIsIGJhY2tkcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBiYWNrZHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5iYWNrZ3JvdW5kID0gYmFja2Ryb3A7XG4gICAgfSBlbHNlIGlmICghYmFja2Ryb3ApIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1snbm8tYmFja2Ryb3AnXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydwb3NpdGlvbiddfSBwb3NpdGlvblxuICAgKi9cbiAgZnVuY3Rpb24gaGFuZGxlUG9zaXRpb25QYXJhbShjb250YWluZXIsIHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uIGluIHN3YWxDbGFzc2VzKSB7XG4gICAgICBhZGRDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzW3Bvc2l0aW9uXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oJ1RoZSBcInBvc2l0aW9uXCIgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCwgZGVmYXVsdGluZyB0byBcImNlbnRlclwiJyk7XG4gICAgICBhZGRDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzLmNlbnRlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zWydncm93J119IGdyb3dcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUdyb3dQYXJhbShjb250YWluZXIsIGdyb3cpIHtcbiAgICBpZiAoZ3JvdyAmJiB0eXBlb2YgZ3JvdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGdyb3dDbGFzcyA9IGBncm93LSR7Z3Jvd31gO1xuICAgICAgaWYgKGdyb3dDbGFzcyBpbiBzd2FsQ2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzcyhjb250YWluZXIsIHN3YWxDbGFzc2VzW2dyb3dDbGFzc10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi8uLi8uLi8uLi9zd2VldGFsZXJ0Mi5kLnRzXCIvPlxuXG4gIC8qKiBAdHlwZSB7SW5wdXRDbGFzc1tdfSAqL1xuICBjb25zdCBpbnB1dENsYXNzZXMgPSBbJ2lucHV0JywgJ2ZpbGUnLCAncmFuZ2UnLCAnc2VsZWN0JywgJ3JhZGlvJywgJ2NoZWNrYm94JywgJ3RleHRhcmVhJ107XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVySW5wdXQgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGNvbnN0IHJlcmVuZGVyID0gIWlubmVyUGFyYW1zIHx8IHBhcmFtcy5pbnB1dCAhPT0gaW5uZXJQYXJhbXMuaW5wdXQ7XG4gICAgaW5wdXRDbGFzc2VzLmZvckVhY2goaW5wdXRDbGFzcyA9PiB7XG4gICAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldERpcmVjdENoaWxkQnlDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXNbaW5wdXRDbGFzc10pO1xuXG4gICAgICAvLyBzZXQgYXR0cmlidXRlc1xuICAgICAgc2V0QXR0cmlidXRlcyhpbnB1dENsYXNzLCBwYXJhbXMuaW5wdXRBdHRyaWJ1dGVzKTtcblxuICAgICAgLy8gc2V0IGNsYXNzXG4gICAgICBpbnB1dENvbnRhaW5lci5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlc1tpbnB1dENsYXNzXTtcbiAgICAgIGlmIChyZXJlbmRlcikge1xuICAgICAgICBoaWRlKGlucHV0Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocGFyYW1zLmlucHV0KSB7XG4gICAgICBpZiAocmVyZW5kZXIpIHtcbiAgICAgICAgc2hvd0lucHV0KHBhcmFtcyk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgY3VzdG9tIGNsYXNzXG4gICAgICBzZXRDdXN0b21DbGFzcyhwYXJhbXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBzaG93SW5wdXQgPSBwYXJhbXMgPT4ge1xuICAgIGlmICghcmVuZGVySW5wdXRUeXBlW3BhcmFtcy5pbnB1dF0pIHtcbiAgICAgIGVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXQhIEV4cGVjdGVkIFwidGV4dFwiLCBcImVtYWlsXCIsIFwicGFzc3dvcmRcIiwgXCJudW1iZXJcIiwgXCJ0ZWxcIiwgXCJzZWxlY3RcIiwgXCJyYWRpb1wiLCBcImNoZWNrYm94XCIsIFwidGV4dGFyZWFcIiwgXCJmaWxlXCIgb3IgXCJ1cmxcIiwgZ290IFwiJHtwYXJhbXMuaW5wdXR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRDb250YWluZXIgPSBnZXRJbnB1dENvbnRhaW5lcihwYXJhbXMuaW5wdXQpO1xuICAgIGNvbnN0IGlucHV0ID0gcmVuZGVySW5wdXRUeXBlW3BhcmFtcy5pbnB1dF0oaW5wdXRDb250YWluZXIsIHBhcmFtcyk7XG4gICAgc2hvdyhpbnB1dENvbnRhaW5lcik7XG5cbiAgICAvLyBpbnB1dCBhdXRvZm9jdXNcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqL1xuICBjb25zdCByZW1vdmVBdHRyaWJ1dGVzID0gaW5wdXQgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYXR0ck5hbWUgPSBpbnB1dC5hdHRyaWJ1dGVzW2ldLm5hbWU7XG4gICAgICBpZiAoIVsndHlwZScsICd2YWx1ZScsICdzdHlsZSddLmluY2x1ZGVzKGF0dHJOYW1lKSkge1xuICAgICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtJbnB1dENsYXNzfSBpbnB1dENsYXNzXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0QXR0cmlidXRlcyddfSBpbnB1dEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0IHNldEF0dHJpYnV0ZXMgPSAoaW5wdXRDbGFzcywgaW5wdXRBdHRyaWJ1dGVzKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBnZXRJbnB1dCQxKGdldFBvcHVwKCksIGlucHV0Q2xhc3MpO1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVtb3ZlQXR0cmlidXRlcyhpbnB1dCk7XG4gICAgZm9yIChjb25zdCBhdHRyIGluIGlucHV0QXR0cmlidXRlcykge1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKGF0dHIsIGlucHV0QXR0cmlidXRlc1thdHRyXSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldEN1c3RvbUNsYXNzID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBpbnB1dENvbnRhaW5lciA9IGdldElucHV0Q29udGFpbmVyKHBhcmFtcy5pbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICBhZGRDbGFzcyhpbnB1dENvbnRhaW5lciwgcGFyYW1zLmN1c3RvbUNsYXNzLmlucHV0KTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3Qgc2V0SW5wdXRQbGFjZWhvbGRlciA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFpbnB1dC5wbGFjZWhvbGRlciB8fCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcikge1xuICAgICAgaW5wdXQucGxhY2Vob2xkZXIgPSBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SW5wdXR9IGlucHV0XG4gICAqIEBwYXJhbSB7SW5wdXR9IHByZXBlbmRUb1xuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldElucHV0TGFiZWwgPSAoaW5wdXQsIHByZXBlbmRUbywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKHBhcmFtcy5pbnB1dExhYmVsKSB7XG4gICAgICBpbnB1dC5pZCA9IHN3YWxDbGFzc2VzLmlucHV0O1xuICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgY29uc3QgbGFiZWxDbGFzcyA9IHN3YWxDbGFzc2VzWydpbnB1dC1sYWJlbCddO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdmb3InLCBpbnB1dC5pZCk7XG4gICAgICBsYWJlbC5jbGFzc05hbWUgPSBsYWJlbENsYXNzO1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFkZENsYXNzKGxhYmVsLCBwYXJhbXMuY3VzdG9tQ2xhc3MuaW5wdXRMYWJlbCk7XG4gICAgICB9XG4gICAgICBsYWJlbC5pbm5lclRleHQgPSBwYXJhbXMuaW5wdXRMYWJlbDtcbiAgICAgIHByZXBlbmRUby5pbnNlcnRBZGphY2VudEVsZW1lbnQoJ2JlZm9yZWJlZ2luJywgbGFiZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc1snaW5wdXQnXX0gaW5wdXRUeXBlXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICovXG4gIGNvbnN0IGdldElucHV0Q29udGFpbmVyID0gaW5wdXRUeXBlID0+IHtcbiAgICByZXR1cm4gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKGdldFBvcHVwKCksIHN3YWxDbGFzc2VzW2lucHV0VHlwZV0gfHwgc3dhbENsYXNzZXMuaW5wdXQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnQgfCBIVE1MT3V0cHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnNbJ2lucHV0VmFsdWUnXX0gaW5wdXRWYWx1ZVxuICAgKi9cbiAgY29uc3QgY2hlY2tBbmRTZXRJbnB1dFZhbHVlID0gKGlucHV0LCBpbnB1dFZhbHVlKSA9PiB7XG4gICAgaWYgKFsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiBpbnB1dFZhbHVlKSkge1xuICAgICAgaW5wdXQudmFsdWUgPSBgJHtpbnB1dFZhbHVlfWA7XG4gICAgfSBlbHNlIGlmICghaXNQcm9taXNlKGlucHV0VmFsdWUpKSB7XG4gICAgICB3YXJuKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRWYWx1ZSEgRXhwZWN0ZWQgXCJzdHJpbmdcIiwgXCJudW1iZXJcIiBvciBcIlByb21pc2VcIiwgZ290IFwiJHt0eXBlb2YgaW5wdXRWYWx1ZX1cImApO1xuICAgIH1cbiAgfTtcblxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIChpbnB1dDogSW5wdXQgfCBIVE1MRWxlbWVudCwgcGFyYW1zOiBTd2VldEFsZXJ0T3B0aW9ucykgPT4gSW5wdXQ+fSAqL1xuICBjb25zdCByZW5kZXJJbnB1dFR5cGUgPSB7fTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJJbnB1dFR5cGUudGV4dCA9IHJlbmRlcklucHV0VHlwZS5lbWFpbCA9IHJlbmRlcklucHV0VHlwZS5wYXNzd29yZCA9IHJlbmRlcklucHV0VHlwZS5udW1iZXIgPSByZW5kZXJJbnB1dFR5cGUudGVsID0gcmVuZGVySW5wdXRUeXBlLnVybCA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gICAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKGlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgc2V0SW5wdXRMYWJlbChpbnB1dCwgaW5wdXQsIHBhcmFtcyk7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgICBpbnB1dC50eXBlID0gcGFyYW1zLmlucHV0O1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJJbnB1dFR5cGUuZmlsZSA9IChpbnB1dCwgcGFyYW1zKSA9PiB7XG4gICAgc2V0SW5wdXRMYWJlbChpbnB1dCwgaW5wdXQsIHBhcmFtcyk7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcihpbnB1dCwgcGFyYW1zKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gcmFuZ2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVySW5wdXRUeXBlLnJhbmdlID0gKHJhbmdlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCByYW5nZUlucHV0ID0gcmFuZ2UucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICBjb25zdCByYW5nZU91dHB1dCA9IHJhbmdlLnF1ZXJ5U2VsZWN0b3IoJ291dHB1dCcpO1xuICAgIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShyYW5nZUlucHV0LCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgcmFuZ2VJbnB1dC50eXBlID0gcGFyYW1zLmlucHV0O1xuICAgIGNoZWNrQW5kU2V0SW5wdXRWYWx1ZShyYW5nZU91dHB1dCwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgIHNldElucHV0TGFiZWwocmFuZ2VJbnB1dCwgcmFuZ2UsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxTZWxlY3RFbGVtZW50fSBzZWxlY3RcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MU2VsZWN0RWxlbWVudH1cbiAgICovXG4gIHJlbmRlcklucHV0VHlwZS5zZWxlY3QgPSAoc2VsZWN0LCBwYXJhbXMpID0+IHtcbiAgICBzZWxlY3QudGV4dENvbnRlbnQgPSAnJztcbiAgICBpZiAocGFyYW1zLmlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICBzZXRJbm5lckh0bWwocGxhY2Vob2xkZXIsIHBhcmFtcy5pbnB1dFBsYWNlaG9sZGVyKTtcbiAgICAgIHBsYWNlaG9sZGVyLnZhbHVlID0gJyc7XG4gICAgICBwbGFjZWhvbGRlci5kaXNhYmxlZCA9IHRydWU7XG4gICAgICBwbGFjZWhvbGRlci5zZWxlY3RlZCA9IHRydWU7XG4gICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQocGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICBzZXRJbnB1dExhYmVsKHNlbGVjdCwgc2VsZWN0LCBwYXJhbXMpO1xuICAgIHJldHVybiBzZWxlY3Q7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gcmFkaW9cbiAgICogQHJldHVybnMge0hUTUxJbnB1dEVsZW1lbnR9XG4gICAqL1xuICByZW5kZXJJbnB1dFR5cGUucmFkaW8gPSByYWRpbyA9PiB7XG4gICAgcmFkaW8udGV4dENvbnRlbnQgPSAnJztcbiAgICByZXR1cm4gcmFkaW87XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTExhYmVsRWxlbWVudH0gY2hlY2tib3hDb250YWluZXJcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtIVE1MSW5wdXRFbGVtZW50fVxuICAgKi9cbiAgcmVuZGVySW5wdXRUeXBlLmNoZWNrYm94ID0gKGNoZWNrYm94Q29udGFpbmVyLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjaGVja2JveCA9IGdldElucHV0JDEoZ2V0UG9wdXAoKSwgJ2NoZWNrYm94Jyk7XG4gICAgY2hlY2tib3gudmFsdWUgPSAnMSc7XG4gICAgY2hlY2tib3guaWQgPSBzd2FsQ2xhc3Nlcy5jaGVja2JveDtcbiAgICBjaGVja2JveC5jaGVja2VkID0gQm9vbGVhbihwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgY29uc3QgbGFiZWwgPSBjaGVja2JveENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgc2V0SW5uZXJIdG1sKGxhYmVsLCBwYXJhbXMuaW5wdXRQbGFjZWhvbGRlcik7XG4gICAgcmV0dXJuIGNoZWNrYm94O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxUZXh0QXJlYUVsZW1lbnR9IHRleHRhcmVhXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTFRleHRBcmVhRWxlbWVudH1cbiAgICovXG4gIHJlbmRlcklucHV0VHlwZS50ZXh0YXJlYSA9ICh0ZXh0YXJlYSwgcGFyYW1zKSA9PiB7XG4gICAgY2hlY2tBbmRTZXRJbnB1dFZhbHVlKHRleHRhcmVhLCBwYXJhbXMuaW5wdXRWYWx1ZSk7XG4gICAgc2V0SW5wdXRQbGFjZWhvbGRlcih0ZXh0YXJlYSwgcGFyYW1zKTtcbiAgICBzZXRJbnB1dExhYmVsKHRleHRhcmVhLCB0ZXh0YXJlYSwgcGFyYW1zKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBjb25zdCBnZXRNYXJnaW4gPSBlbCA9PiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luTGVmdCkgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCkubWFyZ2luUmlnaHQpO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMjkxXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE2OTlcbiAgICAgIGlmICgnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3B1cFdpZHRoID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZ2V0UG9wdXAoKSkud2lkdGgpO1xuICAgICAgICBjb25zdCB0ZXh0YXJlYVJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGV4dGFyZWFXaWR0aCA9IHRleHRhcmVhLm9mZnNldFdpZHRoICsgZ2V0TWFyZ2luKHRleHRhcmVhKTtcbiAgICAgICAgICBpZiAodGV4dGFyZWFXaWR0aCA+IGluaXRpYWxQb3B1cFdpZHRoKSB7XG4gICAgICAgICAgICBnZXRQb3B1cCgpLnN0eWxlLndpZHRoID0gYCR7dGV4dGFyZWFXaWR0aH1weGA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBvcHVwKCkuc3R5bGUud2lkdGggPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGV4dGFyZWFSZXNpemVIYW5kbGVyKS5vYnNlcnZlKHRleHRhcmVhLCB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsnc3R5bGUnXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dGFyZWE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyQ29udGVudCA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaHRtbENvbnRhaW5lciA9IGdldEh0bWxDb250YWluZXIoKTtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGh0bWxDb250YWluZXIsIHBhcmFtcywgJ2h0bWxDb250YWluZXInKTtcblxuICAgIC8vIENvbnRlbnQgYXMgSFRNTFxuICAgIGlmIChwYXJhbXMuaHRtbCkge1xuICAgICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLmh0bWwsIGh0bWxDb250YWluZXIpO1xuICAgICAgc2hvdyhodG1sQ29udGFpbmVyLCAnYmxvY2snKTtcbiAgICB9XG5cbiAgICAvLyBDb250ZW50IGFzIHBsYWluIHRleHRcbiAgICBlbHNlIGlmIChwYXJhbXMudGV4dCkge1xuICAgICAgaHRtbENvbnRhaW5lci50ZXh0Q29udGVudCA9IHBhcmFtcy50ZXh0O1xuICAgICAgc2hvdyhodG1sQ29udGFpbmVyLCAnYmxvY2snKTtcbiAgICB9XG5cbiAgICAvLyBObyBjb250ZW50XG4gICAgZWxzZSB7XG4gICAgICBoaWRlKGh0bWxDb250YWluZXIpO1xuICAgIH1cbiAgICByZW5kZXJJbnB1dChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJGb290ZXIgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGZvb3RlciA9IGdldEZvb3RlcigpO1xuICAgIHRvZ2dsZShmb290ZXIsIHBhcmFtcy5mb290ZXIpO1xuICAgIGlmIChwYXJhbXMuZm9vdGVyKSB7XG4gICAgICBwYXJzZUh0bWxUb0NvbnRhaW5lcihwYXJhbXMuZm9vdGVyLCBmb290ZXIpO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSBjbGFzc1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MoZm9vdGVyLCBwYXJhbXMsICdmb290ZXInKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCByZW5kZXJJY29uID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGNvbnN0IGljb24gPSBnZXRJY29uKCk7XG5cbiAgICAvLyBpZiB0aGUgZ2l2ZW4gaWNvbiBhbHJlYWR5IHJlbmRlcmVkLCBhcHBseSB0aGUgc3R5bGluZyB3aXRob3V0IHJlLXJlbmRlcmluZyB0aGUgaWNvblxuICAgIGlmIChpbm5lclBhcmFtcyAmJiBwYXJhbXMuaWNvbiA9PT0gaW5uZXJQYXJhbXMuaWNvbikge1xuICAgICAgLy8gQ3VzdG9tIG9yIGRlZmF1bHQgY29udGVudFxuICAgICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgICAgYXBwbHlTdHlsZXMoaWNvbiwgcGFyYW1zKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuaWNvbiAmJiAhcGFyYW1zLmljb25IdG1sKSB7XG4gICAgICBoaWRlKGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmljb24gJiYgT2JqZWN0LmtleXMoaWNvblR5cGVzKS5pbmRleE9mKHBhcmFtcy5pY29uKSA9PT0gLTEpIHtcbiAgICAgIGVycm9yKGBVbmtub3duIGljb24hIEV4cGVjdGVkIFwic3VjY2Vzc1wiLCBcImVycm9yXCIsIFwid2FybmluZ1wiLCBcImluZm9cIiBvciBcInF1ZXN0aW9uXCIsIGdvdCBcIiR7cGFyYW1zLmljb259XCJgKTtcbiAgICAgIGhpZGUoaWNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNob3coaWNvbik7XG5cbiAgICAvLyBDdXN0b20gb3IgZGVmYXVsdCBjb250ZW50XG4gICAgc2V0Q29udGVudChpY29uLCBwYXJhbXMpO1xuICAgIGFwcGx5U3R5bGVzKGljb24sIHBhcmFtcyk7XG5cbiAgICAvLyBBbmltYXRlIGljb25cbiAgICBhZGRDbGFzcyhpY29uLCBwYXJhbXMuc2hvd0NsYXNzLmljb24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgYXBwbHlTdHlsZXMgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gICAgZm9yIChjb25zdCBpY29uVHlwZSBpbiBpY29uVHlwZXMpIHtcbiAgICAgIGlmIChwYXJhbXMuaWNvbiAhPT0gaWNvblR5cGUpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoaWNvbiwgaWNvblR5cGVzW2ljb25UeXBlXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFkZENsYXNzKGljb24sIGljb25UeXBlc1twYXJhbXMuaWNvbl0pO1xuXG4gICAgLy8gSWNvbiBjb2xvclxuICAgIHNldENvbG9yKGljb24sIHBhcmFtcyk7XG5cbiAgICAvLyBTdWNjZXNzIGljb24gYmFja2dyb3VuZCBjb2xvclxuICAgIGFkanVzdFN1Y2Nlc3NJY29uQmFja2dyb3VuZENvbG9yKCk7XG5cbiAgICAvLyBDdXN0b20gY2xhc3NcbiAgICBhcHBseUN1c3RvbUNsYXNzKGljb24sIHBhcmFtcywgJ2ljb24nKTtcbiAgfTtcblxuICAvLyBBZGp1c3Qgc3VjY2VzcyBpY29uIGJhY2tncm91bmQgY29sb3IgdG8gbWF0Y2ggdGhlIHBvcHVwIGJhY2tncm91bmQgY29sb3JcbiAgY29uc3QgYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IgPSAoKSA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IHBvcHVwQmFja2dyb3VuZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocG9wdXApLmdldFByb3BlcnR5VmFsdWUoJ2JhY2tncm91bmQtY29sb3InKTtcbiAgICAvKiogQHR5cGUge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fSAqL1xuICAgIGNvbnN0IHN1Y2Nlc3NJY29uUGFydHMgPSBwb3B1cC5xdWVyeVNlbGVjdG9yQWxsKCdbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV0sIC5zd2FsMi1zdWNjZXNzLWZpeCcpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VjY2Vzc0ljb25QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VjY2Vzc0ljb25QYXJ0c1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBwb3B1cEJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1Y2Nlc3NJY29uSHRtbCA9IGBcbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1sZWZ0XCI+PC9kaXY+XG4gIDxzcGFuIGNsYXNzPVwic3dhbDItc3VjY2Vzcy1saW5lLXRpcFwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJzd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ1wiPjwvc3Bhbj5cbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtcmluZ1wiPjwvZGl2PiA8ZGl2IGNsYXNzPVwic3dhbDItc3VjY2Vzcy1maXhcIj48L2Rpdj5cbiAgPGRpdiBjbGFzcz1cInN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodFwiPjwvZGl2PlxuYDtcbiAgY29uc3QgZXJyb3JJY29uSHRtbCA9IGBcbiAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmtcIj5cbiAgICA8c3BhbiBjbGFzcz1cInN3YWwyLXgtbWFyay1saW5lLWxlZnRcIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJzd2FsMi14LW1hcmstbGluZS1yaWdodFwiPjwvc3Bhbj5cbiAgPC9zcGFuPlxuYDtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaWNvblxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNldENvbnRlbnQgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gICAgbGV0IG9sZENvbnRlbnQgPSBpY29uLmlubmVySFRNTDtcbiAgICBsZXQgbmV3Q29udGVudDtcbiAgICBpZiAocGFyYW1zLmljb25IdG1sKSB7XG4gICAgICBuZXdDb250ZW50ID0gaWNvbkNvbnRlbnQocGFyYW1zLmljb25IdG1sKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5pY29uID09PSAnc3VjY2VzcycpIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBzdWNjZXNzSWNvbkh0bWw7XG4gICAgICBvbGRDb250ZW50ID0gb2xkQ29udGVudC5yZXBsYWNlKC8gc3R5bGU9XCIuKj9cIi9nLCAnJyk7IC8vIHVuZG8gYWRqdXN0U3VjY2Vzc0ljb25CYWNrZ3JvdW5kQ29sb3IoKVxuICAgIH0gZWxzZSBpZiAocGFyYW1zLmljb24gPT09ICdlcnJvcicpIHtcbiAgICAgIG5ld0NvbnRlbnQgPSBlcnJvckljb25IdG1sO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0SWNvbkh0bWwgPSB7XG4gICAgICAgIHF1ZXN0aW9uOiAnPycsXG4gICAgICAgIHdhcm5pbmc6ICchJyxcbiAgICAgICAgaW5mbzogJ2knXG4gICAgICB9O1xuICAgICAgbmV3Q29udGVudCA9IGljb25Db250ZW50KGRlZmF1bHRJY29uSHRtbFtwYXJhbXMuaWNvbl0pO1xuICAgIH1cbiAgICBpZiAob2xkQ29udGVudC50cmltKCkgIT09IG5ld0NvbnRlbnQudHJpbSgpKSB7XG4gICAgICBzZXRJbm5lckh0bWwoaWNvbiwgbmV3Q29udGVudCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBpY29uXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3Qgc2V0Q29sb3IgPSAoaWNvbiwgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFwYXJhbXMuaWNvbkNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGljb24uc3R5bGUuY29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuICAgIGljb24uc3R5bGUuYm9yZGVyQ29sb3IgPSBwYXJhbXMuaWNvbkNvbG9yO1xuICAgIGZvciAoY29uc3Qgc2VsIG9mIFsnLnN3YWwyLXN1Y2Nlc3MtbGluZS10aXAnLCAnLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25nJywgJy5zd2FsMi14LW1hcmstbGluZS1sZWZ0JywgJy5zd2FsMi14LW1hcmstbGluZS1yaWdodCddKSB7XG4gICAgICBzZXRTdHlsZShpY29uLCBzZWwsICdiYWNrZ3JvdW5kQ29sb3InLCBwYXJhbXMuaWNvbkNvbG9yKTtcbiAgICB9XG4gICAgc2V0U3R5bGUoaWNvbiwgJy5zd2FsMi1zdWNjZXNzLXJpbmcnLCAnYm9yZGVyQ29sb3InLCBwYXJhbXMuaWNvbkNvbG9yKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IGljb25Db250ZW50ID0gY29udGVudCA9PiBgPGRpdiBjbGFzcz1cIiR7c3dhbENsYXNzZXNbJ2ljb24tY29udGVudCddfVwiPiR7Y29udGVudH08L2Rpdj5gO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlckltYWdlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IGdldEltYWdlKCk7XG4gICAgaWYgKCFwYXJhbXMuaW1hZ2VVcmwpIHtcbiAgICAgIGhpZGUoaW1hZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzaG93KGltYWdlLCAnJyk7XG5cbiAgICAvLyBTcmMsIGFsdFxuICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnc3JjJywgcGFyYW1zLmltYWdlVXJsKTtcbiAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ2FsdCcsIHBhcmFtcy5pbWFnZUFsdCk7XG5cbiAgICAvLyBXaWR0aCwgaGVpZ2h0XG4gICAgYXBwbHlOdW1lcmljYWxTdHlsZShpbWFnZSwgJ3dpZHRoJywgcGFyYW1zLmltYWdlV2lkdGgpO1xuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoaW1hZ2UsICdoZWlnaHQnLCBwYXJhbXMuaW1hZ2VIZWlnaHQpO1xuXG4gICAgLy8gQ2xhc3NcbiAgICBpbWFnZS5jbGFzc05hbWUgPSBzd2FsQ2xhc3Nlcy5pbWFnZTtcbiAgICBhcHBseUN1c3RvbUNsYXNzKGltYWdlLCBwYXJhbXMsICdpbWFnZScpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlclBvcHVwID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBnZXRDb250YWluZXIoKTtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG5cbiAgICAvLyBXaWR0aFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMjE3MFxuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUoY29udGFpbmVyLCAnd2lkdGgnLCBwYXJhbXMud2lkdGgpO1xuICAgICAgcG9wdXAuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBwb3B1cC5pbnNlcnRCZWZvcmUoZ2V0TG9hZGVyKCksIGdldEljb24oKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUocG9wdXAsICd3aWR0aCcsIHBhcmFtcy53aWR0aCk7XG4gICAgfVxuXG4gICAgLy8gUGFkZGluZ1xuICAgIGFwcGx5TnVtZXJpY2FsU3R5bGUocG9wdXAsICdwYWRkaW5nJywgcGFyYW1zLnBhZGRpbmcpO1xuXG4gICAgLy8gQ29sb3JcbiAgICBpZiAocGFyYW1zLmNvbG9yKSB7XG4gICAgICBwb3B1cC5zdHlsZS5jb2xvciA9IHBhcmFtcy5jb2xvcjtcbiAgICB9XG5cbiAgICAvLyBCYWNrZ3JvdW5kXG4gICAgaWYgKHBhcmFtcy5iYWNrZ3JvdW5kKSB7XG4gICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kID0gcGFyYW1zLmJhY2tncm91bmQ7XG4gICAgfVxuICAgIGhpZGUoZ2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSk7XG5cbiAgICAvLyBDbGFzc2VzXG4gICAgYWRkQ2xhc3NlcyQxKHBvcHVwLCBwYXJhbXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IGFkZENsYXNzZXMkMSA9IChwb3B1cCwgcGFyYW1zKSA9PiB7XG4gICAgLy8gRGVmYXVsdCBDbGFzcyArIHNob3dDbGFzcyB3aGVuIHVwZGF0aW5nIFN3YWwudXBkYXRlKHt9KVxuICAgIHBvcHVwLmNsYXNzTmFtZSA9IGAke3N3YWxDbGFzc2VzLnBvcHVwfSAke2lzVmlzaWJsZSQxKHBvcHVwKSA/IHBhcmFtcy5zaG93Q2xhc3MucG9wdXAgOiAnJ31gO1xuICAgIGlmIChwYXJhbXMudG9hc3QpIHtcbiAgICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXSk7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMudG9hc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgc3dhbENsYXNzZXMubW9kYWwpO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSBjbGFzc1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3MocG9wdXAsIHBhcmFtcywgJ3BvcHVwJyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuY3VzdG9tQ2xhc3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLmN1c3RvbUNsYXNzKTtcbiAgICB9XG5cbiAgICAvLyBJY29uIGNsYXNzICgjMTg0MilcbiAgICBpZiAocGFyYW1zLmljb24pIHtcbiAgICAgIGFkZENsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlc1tgaWNvbi0ke3BhcmFtcy5pY29ufWBdKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyUHJvZ3Jlc3NTdGVwcyA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lciA9IGdldFByb2dyZXNzU3RlcHMoKTtcbiAgICBpZiAoIXBhcmFtcy5wcm9ncmVzc1N0ZXBzIHx8IHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaGlkZShwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2hvdyhwcm9ncmVzc1N0ZXBzQ29udGFpbmVyKTtcbiAgICBwcm9ncmVzc1N0ZXBzQ29udGFpbmVyLnRleHRDb250ZW50ID0gJyc7XG4gICAgaWYgKHBhcmFtcy5jdXJyZW50UHJvZ3Jlc3NTdGVwID49IHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmxlbmd0aCkge1xuICAgICAgd2FybignSW52YWxpZCBjdXJyZW50UHJvZ3Jlc3NTdGVwIHBhcmFtZXRlciwgaXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBwcm9ncmVzc1N0ZXBzLmxlbmd0aCAnICsgJyhjdXJyZW50UHJvZ3Jlc3NTdGVwIGxpa2UgSlMgYXJyYXlzIHN0YXJ0cyBmcm9tIDApJyk7XG4gICAgfVxuICAgIHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmZvckVhY2goKHN0ZXAsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzdGVwRWwgPSBjcmVhdGVTdGVwRWxlbWVudChzdGVwKTtcbiAgICAgIHByb2dyZXNzU3RlcHNDb250YWluZXIuYXBwZW5kQ2hpbGQoc3RlcEVsKTtcbiAgICAgIGlmIChpbmRleCA9PT0gcGFyYW1zLmN1cnJlbnRQcm9ncmVzc1N0ZXApIHtcbiAgICAgICAgYWRkQ2xhc3Moc3RlcEVsLCBzd2FsQ2xhc3Nlc1snYWN0aXZlLXByb2dyZXNzLXN0ZXAnXSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggIT09IHBhcmFtcy5wcm9ncmVzc1N0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgbGluZUVsID0gY3JlYXRlTGluZUVsZW1lbnQocGFyYW1zKTtcbiAgICAgICAgcHJvZ3Jlc3NTdGVwc0NvbnRhaW5lci5hcHBlbmRDaGlsZChsaW5lRWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RlcFxuICAgKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAgICovXG4gIGNvbnN0IGNyZWF0ZVN0ZXBFbGVtZW50ID0gc3RlcCA9PiB7XG4gICAgY29uc3Qgc3RlcEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICBhZGRDbGFzcyhzdGVwRWwsIHN3YWxDbGFzc2VzWydwcm9ncmVzcy1zdGVwJ10pO1xuICAgIHNldElubmVySHRtbChzdGVwRWwsIHN0ZXApO1xuICAgIHJldHVybiBzdGVwRWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7SFRNTExJRWxlbWVudH1cbiAgICovXG4gIGNvbnN0IGNyZWF0ZUxpbmVFbGVtZW50ID0gcGFyYW1zID0+IHtcbiAgICBjb25zdCBsaW5lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgIGFkZENsYXNzKGxpbmVFbCwgc3dhbENsYXNzZXNbJ3Byb2dyZXNzLXN0ZXAtbGluZSddKTtcbiAgICBpZiAocGFyYW1zLnByb2dyZXNzU3RlcHNEaXN0YW5jZSkge1xuICAgICAgYXBwbHlOdW1lcmljYWxTdHlsZShsaW5lRWwsICd3aWR0aCcsIHBhcmFtcy5wcm9ncmVzc1N0ZXBzRGlzdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZUVsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHJlbmRlclRpdGxlID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCB0aXRsZSA9IGdldFRpdGxlKCk7XG4gICAgdG9nZ2xlKHRpdGxlLCBwYXJhbXMudGl0bGUgfHwgcGFyYW1zLnRpdGxlVGV4dCwgJ2Jsb2NrJyk7XG4gICAgaWYgKHBhcmFtcy50aXRsZSkge1xuICAgICAgcGFyc2VIdG1sVG9Db250YWluZXIocGFyYW1zLnRpdGxlLCB0aXRsZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMudGl0bGVUZXh0KSB7XG4gICAgICB0aXRsZS5pbm5lclRleHQgPSBwYXJhbXMudGl0bGVUZXh0O1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSBjbGFzc1xuICAgIGFwcGx5Q3VzdG9tQ2xhc3ModGl0bGUsIHBhcmFtcywgJ3RpdGxlJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgcmVuZGVyID0gKGluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICByZW5kZXJQb3B1cChpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJDb250YWluZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyUHJvZ3Jlc3NTdGVwcyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJJY29uKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckltYWdlKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlclRpdGxlKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckNsb3NlQnV0dG9uKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIHJlbmRlckNvbnRlbnQoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgcmVuZGVyQWN0aW9ucyhpbnN0YW5jZSwgcGFyYW1zKTtcbiAgICByZW5kZXJGb290ZXIoaW5zdGFuY2UsIHBhcmFtcyk7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZGlkUmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJhbXMuZGlkUmVuZGVyKGdldFBvcHVwKCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSGlkZXMgbG9hZGVyIGFuZCBzaG93cyBiYWNrIHRoZSBidXR0b24gd2hpY2ggd2FzIGhpZGRlbiBieSAuc2hvd0xvYWRpbmcoKVxuICAgKi9cbiAgZnVuY3Rpb24gaGlkZUxvYWRpbmcoKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBwb3B1cCBpcyBjbG9zZWRcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gICAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gICAgaGlkZShkb21DYWNoZS5sb2FkZXIpO1xuICAgIGlmIChpc1RvYXN0KCkpIHtcbiAgICAgIGlmIChpbm5lclBhcmFtcy5pY29uKSB7XG4gICAgICAgIHNob3coZ2V0SWNvbigpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvd1JlbGF0ZWRCdXR0b24oZG9tQ2FjaGUpO1xuICAgIH1cbiAgICByZW1vdmVDbGFzcyhbZG9tQ2FjaGUucG9wdXAsIGRvbUNhY2hlLmFjdGlvbnNdLCBzd2FsQ2xhc3Nlcy5sb2FkaW5nKTtcbiAgICBkb21DYWNoZS5wb3B1cC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtYnVzeScpO1xuICAgIGRvbUNhY2hlLnBvcHVwLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sb2FkaW5nJyk7XG4gICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIGRvbUNhY2hlLmRlbnlCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBkb21DYWNoZS5jYW5jZWxCdXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBzaG93UmVsYXRlZEJ1dHRvbiA9IGRvbUNhY2hlID0+IHtcbiAgICBjb25zdCBidXR0b25Ub1JlcGxhY2UgPSBkb21DYWNoZS5wb3B1cC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGRvbUNhY2hlLmxvYWRlci5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnV0dG9uLXRvLXJlcGxhY2UnKSk7XG4gICAgaWYgKGJ1dHRvblRvUmVwbGFjZS5sZW5ndGgpIHtcbiAgICAgIHNob3coYnV0dG9uVG9SZXBsYWNlWzBdLCAnaW5saW5lLWJsb2NrJyk7XG4gICAgfSBlbHNlIGlmIChhbGxCdXR0b25zQXJlSGlkZGVuKCkpIHtcbiAgICAgIGhpZGUoZG9tQ2FjaGUuYWN0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbnB1dCBET00gbm9kZSwgdGhpcyBtZXRob2Qgd29ya3Mgd2l0aCBpbnB1dCBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJbnB1dChpbnN0YW5jZSkge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSB8fCB0aGlzKTtcbiAgICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQoaW5zdGFuY2UgfHwgdGhpcyk7XG4gICAgaWYgKCFkb21DYWNoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXRJbnB1dCQxKGRvbUNhY2hlLnBvcHVwLCBpbm5lclBhcmFtcy5pbnB1dCk7XG4gIH1cblxuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIFN3ZWV0QWxlcnQyIHBvcHVwIGlzIHNob3duXG4gICAqL1xuICBjb25zdCBpc1Zpc2libGUgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGlzVmlzaWJsZSQxKGdldFBvcHVwKCkpO1xuICB9O1xuXG4gIC8qXG4gICAqIEdsb2JhbCBmdW5jdGlvbiB0byBjbGljayAnQ29uZmlybScgYnV0dG9uXG4gICAqL1xuICBjb25zdCBjbGlja0NvbmZpcm0gPSAoKSA9PiBnZXRDb25maXJtQnV0dG9uKCkgJiYgZ2V0Q29uZmlybUJ1dHRvbigpLmNsaWNrKCk7XG5cbiAgLypcbiAgICogR2xvYmFsIGZ1bmN0aW9uIHRvIGNsaWNrICdEZW55JyBidXR0b25cbiAgICovXG4gIGNvbnN0IGNsaWNrRGVueSA9ICgpID0+IGdldERlbnlCdXR0b24oKSAmJiBnZXREZW55QnV0dG9uKCkuY2xpY2soKTtcblxuICAvKlxuICAgKiBHbG9iYWwgZnVuY3Rpb24gdG8gY2xpY2sgJ0NhbmNlbCcgYnV0dG9uXG4gICAqL1xuICBjb25zdCBjbGlja0NhbmNlbCA9ICgpID0+IGdldENhbmNlbEJ1dHRvbigpICYmIGdldENhbmNlbEJ1dHRvbigpLmNsaWNrKCk7XG5cbiAgY29uc3QgRGlzbWlzc1JlYXNvbiA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNhbmNlbDogJ2NhbmNlbCcsXG4gICAgYmFja2Ryb3A6ICdiYWNrZHJvcCcsXG4gICAgY2xvc2U6ICdjbG9zZScsXG4gICAgZXNjOiAnZXNjJyxcbiAgICB0aW1lcjogJ3RpbWVyJ1xuICB9KTtcblxuICAvKipcbiAgICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAgICovXG4gIGNvbnN0IHJlbW92ZUtleWRvd25IYW5kbGVyID0gZ2xvYmFsU3RhdGUgPT4ge1xuICAgIGlmIChnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ICYmIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyQWRkZWQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyLCB7XG4gICAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHBhcmFtIHsqfSBkaXNtaXNzV2l0aFxuICAgKi9cbiAgY29uc3QgYWRkS2V5ZG93bkhhbmRsZXIgPSAoaW5zdGFuY2UsIGdsb2JhbFN0YXRlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgICByZW1vdmVLZXlkb3duSGFuZGxlcihnbG9iYWxTdGF0ZSk7XG4gICAgaWYgKCFpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXIgPSBlID0+IGtleWRvd25IYW5kbGVyKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCk7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duVGFyZ2V0ID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZSA/IHdpbmRvdyA6IGdldFBvcHVwKCk7XG4gICAgICBnbG9iYWxTdGF0ZS5rZXlkb3duTGlzdGVuZXJDYXB0dXJlID0gaW5uZXJQYXJhbXMua2V5ZG93bkxpc3RlbmVyQ2FwdHVyZTtcbiAgICAgIGdsb2JhbFN0YXRlLmtleWRvd25UYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGdsb2JhbFN0YXRlLmtleWRvd25IYW5kbGVyLCB7XG4gICAgICAgIGNhcHR1cmU6IGdsb2JhbFN0YXRlLmtleWRvd25MaXN0ZW5lckNhcHR1cmVcbiAgICAgIH0pO1xuICAgICAgZ2xvYmFsU3RhdGUua2V5ZG93bkhhbmRsZXJBZGRlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluY3JlbWVudFxuICAgKi9cbiAgY29uc3Qgc2V0Rm9jdXMgPSAoaW5uZXJQYXJhbXMsIGluZGV4LCBpbmNyZW1lbnQpID0+IHtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgLy8gc2VhcmNoIGZvciB2aXNpYmxlIGVsZW1lbnRzIGFuZCBzZWxlY3QgdGhlIG5leHQgcG9zc2libGUgbWF0Y2hcbiAgICBpZiAoZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBpbmRleCA9IGluZGV4ICsgaW5jcmVtZW50O1xuXG4gICAgICAvLyByb2xsb3ZlciB0byBmaXJzdCBpdGVtXG4gICAgICBpZiAoaW5kZXggPT09IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgLy8gZ28gdG8gbGFzdCBpdGVtXG4gICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICBpbmRleCA9IGZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9jdXNhYmxlRWxlbWVudHNbaW5kZXhdLmZvY3VzKCk7XG4gICAgfVxuICAgIC8vIG5vIHZpc2libGUgZm9jdXNhYmxlIGVsZW1lbnRzLCBmb2N1cyB0aGUgcG9wdXBcbiAgICBnZXRQb3B1cCgpLmZvY3VzKCk7XG4gIH07XG4gIGNvbnN0IGFycm93S2V5c05leHRCdXR0b24gPSBbJ0Fycm93UmlnaHQnLCAnQXJyb3dEb3duJ107XG4gIGNvbnN0IGFycm93S2V5c1ByZXZpb3VzQnV0dG9uID0gWydBcnJvd0xlZnQnLCAnQXJyb3dVcCddO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGtleWRvd25IYW5kbGVyID0gKGluc3RhbmNlLCBlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaWYgKCFpbm5lclBhcmFtcykge1xuICAgICAgcmV0dXJuOyAvLyBUaGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkXG4gICAgfVxuXG4gICAgLy8gSWdub3JlIGtleWRvd24gZHVyaW5nIElNRSBjb21wb3NpdGlvblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9rZXlkb3duX2V2ZW50I2lnbm9yaW5nX2tleWRvd25fZHVyaW5nX2ltZV9jb21wb3NpdGlvblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvNzIwXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yNDA2XG4gICAgaWYgKGUuaXNDb21wb3NpbmcgfHwgZS5rZXlDb2RlID09PSAyMjkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLnN0b3BLZXlkb3duUHJvcGFnYXRpb24pIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gRU5URVJcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgIGhhbmRsZUVudGVyKGluc3RhbmNlLCBlLCBpbm5lclBhcmFtcyk7XG4gICAgfVxuXG4gICAgLy8gVEFCXG4gICAgZWxzZSBpZiAoZS5rZXkgPT09ICdUYWInKSB7XG4gICAgICBoYW5kbGVUYWIoZSwgaW5uZXJQYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIEFSUk9XUyAtIHN3aXRjaCBmb2N1cyBiZXR3ZWVuIGJ1dHRvbnNcbiAgICBlbHNlIGlmIChbLi4uYXJyb3dLZXlzTmV4dEJ1dHRvbiwgLi4uYXJyb3dLZXlzUHJldmlvdXNCdXR0b25dLmluY2x1ZGVzKGUua2V5KSkge1xuICAgICAgaGFuZGxlQXJyb3dzKGUua2V5KTtcbiAgICB9XG5cbiAgICAvLyBFU0NcbiAgICBlbHNlIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgIGhhbmRsZUVzYyhlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gICAqL1xuICBjb25zdCBoYW5kbGVFbnRlciA9IChpbnN0YW5jZSwgZSwgaW5uZXJQYXJhbXMpID0+IHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzIzODZcbiAgICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlLnRhcmdldCAmJiBpbnN0YW5jZS5nZXRJbnB1dCgpICYmIGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZS50YXJnZXQub3V0ZXJIVE1MID09PSBpbnN0YW5jZS5nZXRJbnB1dCgpLm91dGVySFRNTCkge1xuICAgICAgaWYgKFsndGV4dGFyZWEnLCAnZmlsZSddLmluY2x1ZGVzKGlubmVyUGFyYW1zLmlucHV0KSkge1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdCBzdWJtaXRcbiAgICAgIH1cblxuICAgICAgY2xpY2tDb25maXJtKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICovXG4gIGNvbnN0IGhhbmRsZVRhYiA9IChlLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlLnRhcmdldDtcbiAgICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgbGV0IGJ0bkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2N1c2FibGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRhcmdldEVsZW1lbnQgPT09IGZvY3VzYWJsZUVsZW1lbnRzW2ldKSB7XG4gICAgICAgIGJ0bkluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ3ljbGUgdG8gdGhlIG5leHQgYnV0dG9uXG4gICAgaWYgKCFlLnNoaWZ0S2V5KSB7XG4gICAgICBzZXRGb2N1cyhpbm5lclBhcmFtcywgYnRuSW5kZXgsIDEpO1xuICAgIH1cblxuICAgIC8vIEN5Y2xlIHRvIHRoZSBwcmV2IGJ1dHRvblxuICAgIGVsc2Uge1xuICAgICAgc2V0Rm9jdXMoaW5uZXJQYXJhbXMsIGJ0bkluZGV4LCAtMSk7XG4gICAgfVxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBjb25zdCBoYW5kbGVBcnJvd3MgPSBrZXkgPT4ge1xuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBnZXRDb25maXJtQnV0dG9uKCk7XG4gICAgY29uc3QgZGVueUJ1dHRvbiA9IGdldERlbnlCdXR0b24oKTtcbiAgICBjb25zdCBjYW5jZWxCdXR0b24gPSBnZXRDYW5jZWxCdXR0b24oKTtcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmICFbY29uZmlybUJ1dHRvbiwgZGVueUJ1dHRvbiwgY2FuY2VsQnV0dG9uXS5pbmNsdWRlcyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gYXJyb3dLZXlzTmV4dEJ1dHRvbi5pbmNsdWRlcyhrZXkpID8gJ25leHRFbGVtZW50U2libGluZycgOiAncHJldmlvdXNFbGVtZW50U2libGluZyc7XG4gICAgbGV0IGJ1dHRvblRvRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2V0QWN0aW9ucygpLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBidXR0b25Ub0ZvY3VzID0gYnV0dG9uVG9Gb2N1c1tzaWJsaW5nXTtcbiAgICAgIGlmICghYnV0dG9uVG9Gb2N1cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYnV0dG9uVG9Gb2N1cyBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50ICYmIGlzVmlzaWJsZSQxKGJ1dHRvblRvRm9jdXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYnV0dG9uVG9Gb2N1cyBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50KSB7XG4gICAgICBidXR0b25Ub0ZvY3VzLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IGhhbmRsZUVzYyA9IChlLCBpbm5lclBhcmFtcywgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBpZiAoY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dFc2NhcGVLZXkpKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBkaXNtaXNzV2l0aChEaXNtaXNzUmVhc29uLmVzYyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1vZHVsZSBjb250YWlucyBgV2Vha01hcGBzIGZvciBlYWNoIGVmZmVjdGl2ZWx5LVwicHJpdmF0ZSAgcHJvcGVydHlcIiB0aGF0IGEgYFN3YWxgIGhhcy5cbiAgICogRm9yIGV4YW1wbGUsIHRvIHNldCB0aGUgcHJpdmF0ZSBwcm9wZXJ0eSBcImZvb1wiIG9mIGB0aGlzYCB0byBcImJhclwiLCB5b3UgY2FuIGBwcml2YXRlUHJvcHMuZm9vLnNldCh0aGlzLCAnYmFyJylgXG4gICAqIFRoaXMgaXMgdGhlIGFwcHJvYWNoIHRoYXQgQmFiZWwgd2lsbCBwcm9iYWJseSB0YWtlIHRvIGltcGxlbWVudCBwcml2YXRlIG1ldGhvZHMvZmllbGRzXG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtcHJpdmF0ZS1tZXRob2RzXG4gICAqICAgaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL3B1bGwvNzU1NVxuICAgKiBPbmNlIHdlIGhhdmUgdGhlIGNoYW5nZXMgZnJvbSB0aGF0IFBSIGluIEJhYmVsLCBhbmQgb3VyIGNvcmUgY2xhc3MgZml0cyByZWFzb25hYmxlIGluICpvbmUgbW9kdWxlKlxuICAgKiAgIHRoZW4gd2UgY2FuIHVzZSB0aGF0IGxhbmd1YWdlIGZlYXR1cmUuXG4gICAqL1xuXG4gIHZhciBwcml2YXRlTWV0aG9kcyA9IHtcbiAgICBzd2FsUHJvbWlzZVJlc29sdmU6IG5ldyBXZWFrTWFwKCksXG4gICAgc3dhbFByb21pc2VSZWplY3Q6IG5ldyBXZWFrTWFwKClcbiAgfTtcblxuICAvLyBGcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLnBhY2llbGxvZ3JvdXAuY29tL2Jsb2cvMjAxOC8wNi90aGUtY3VycmVudC1zdGF0ZS1vZi1tb2RhbC1kaWFsb2ctYWNjZXNzaWJpbGl0eS9cbiAgLy8gQWRkaW5nIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIHRvIGVsZW1lbnRzIG91dHNpZGUgb2YgdGhlIGFjdGl2ZSBtb2RhbCBkaWFsb2cgZW5zdXJlcyB0aGF0XG4gIC8vIGVsZW1lbnRzIG5vdCB3aXRoaW4gdGhlIGFjdGl2ZSBtb2RhbCBkaWFsb2cgd2lsbCBub3QgYmUgc3VyZmFjZWQgaWYgYSB1c2VyIG9wZW5zIGEgc2NyZWVuXG4gIC8vIHJlYWRlcuKAmXMgbGlzdCBvZiBlbGVtZW50cyAoaGVhZGluZ3MsIGZvcm0gY29udHJvbHMsIGxhbmRtYXJrcywgZXRjLikgaW4gdGhlIGRvY3VtZW50LlxuXG4gIGNvbnN0IHNldEFyaWFIaWRkZW4gPSAoKSA9PiB7XG4gICAgY29uc3QgYm9keUNoaWxkcmVuID0gQXJyYXkuZnJvbShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICBib2R5Q2hpbGRyZW4uZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwgPT09IGdldENvbnRhaW5lcigpIHx8IGVsLmNvbnRhaW5zKGdldENvbnRhaW5lcigpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicsIGVsLmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSk7XG4gICAgICB9XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgdW5zZXRBcmlhSGlkZGVuID0gKCkgPT4ge1xuICAgIGNvbnN0IGJvZHlDaGlsZHJlbiA9IEFycmF5LmZyb20oZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gICAgYm9keUNoaWxkcmVuLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCBlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcHJldmlvdXMtYXJpYS1oaWRkZW4nKSk7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wcmV2aW91cy1hcmlhLWhpZGRlbicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cbiAgLy8gRml4IGlPUyBzY3JvbGxpbmcgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMzk2MjYzMDJcblxuICBjb25zdCBpT1NmaXggPSAoKSA9PiB7XG4gICAgY29uc3QgaU9TID1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbSB8fCBuYXZpZ2F0b3IucGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMTtcbiAgICBpZiAoaU9TICYmICFoYXNDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcDtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUudG9wID0gYCR7b2Zmc2V0ICogLTF9cHhgO1xuICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgc3dhbENsYXNzZXMuaW9zZml4KTtcbiAgICAgIGxvY2tCb2R5U2Nyb2xsKCk7XG4gICAgICBhZGRCb3R0b21QYWRkaW5nRm9yVGFsbFBvcHVwcygpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8xOTQ4XG4gICAqL1xuICBjb25zdCBhZGRCb3R0b21QYWRkaW5nRm9yVGFsbFBvcHVwcyA9ICgpID0+IHtcbiAgICBjb25zdCB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgaU9TID0gISF1YS5tYXRjaCgvaVBhZC9pKSB8fCAhIXVhLm1hdGNoKC9pUGhvbmUvaSk7XG4gICAgY29uc3Qgd2Via2l0ID0gISF1YS5tYXRjaCgvV2ViS2l0L2kpO1xuICAgIGNvbnN0IGlPU1NhZmFyaSA9IGlPUyAmJiB3ZWJraXQgJiYgIXVhLm1hdGNoKC9DcmlPUy9pKTtcbiAgICBpZiAoaU9TU2FmYXJpKSB7XG4gICAgICBjb25zdCBib3R0b21QYW5lbEhlaWdodCA9IDQ0O1xuICAgICAgaWYgKGdldFBvcHVwKCkuc2Nyb2xsSGVpZ2h0ID4gd2luZG93LmlubmVySGVpZ2h0IC0gYm90dG9tUGFuZWxIZWlnaHQpIHtcbiAgICAgICAgZ2V0Q29udGFpbmVyKCkuc3R5bGUucGFkZGluZ0JvdHRvbSA9IGAke2JvdHRvbVBhbmVsSGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTI0NlxuICAgKi9cbiAgY29uc3QgbG9ja0JvZHlTY3JvbGwgPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgbGV0IHByZXZlbnRUb3VjaE1vdmU7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAgICovXG4gICAgY29udGFpbmVyLm9udG91Y2hzdGFydCA9IGUgPT4ge1xuICAgICAgcHJldmVudFRvdWNoTW92ZSA9IHNob3VsZFByZXZlbnRUb3VjaE1vdmUoZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICAgKi9cbiAgICBjb250YWluZXIub250b3VjaG1vdmUgPSBlID0+IHtcbiAgICAgIGlmIChwcmV2ZW50VG91Y2hNb3ZlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3Qgc2hvdWxkUHJldmVudFRvdWNoTW92ZSA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgaWYgKGlzU3R5bHVzKGV2ZW50KSB8fCBpc1pvb20oZXZlbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghaXNTY3JvbGxhYmxlKGNvbnRhaW5lcikgJiYgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdGFyZ2V0LnRhZ05hbWUgIT09ICdJTlBVVCcgJiZcbiAgICAvLyAjMTYwM1xuICAgIHRhcmdldC50YWdOYW1lICE9PSAnVEVYVEFSRUEnICYmXG4gICAgLy8gIzIyNjZcbiAgICAhKGlzU2Nyb2xsYWJsZShnZXRIdG1sQ29udGFpbmVyKCkpICYmXG4gICAgLy8gIzE5NDRcbiAgICBnZXRIdG1sQ29udGFpbmVyKCkuY29udGFpbnModGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zd2VldGFsZXJ0Mi9zd2VldGFsZXJ0Mi9pc3N1ZXMvMTc4NlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNTdHlsdXMgPSBldmVudCA9PiB7XG4gICAgcmV0dXJuIGV2ZW50LnRvdWNoZXMgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggJiYgZXZlbnQudG91Y2hlc1swXS50b3VjaFR5cGUgPT09ICdzdHlsdXMnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vc3dlZXRhbGVydDIvc3dlZXRhbGVydDIvaXNzdWVzLzE4OTFcbiAgICpcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBldmVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGlzWm9vbSA9IGV2ZW50ID0+IHtcbiAgICByZXR1cm4gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDE7XG4gIH07XG4gIGNvbnN0IHVuZG9JT1NmaXggPSAoKSA9PiB7XG4gICAgaWYgKGhhc0NsYXNzKGRvY3VtZW50LmJvZHksIHN3YWxDbGFzc2VzLmlvc2ZpeCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHBhcnNlSW50KGRvY3VtZW50LmJvZHkuc3R5bGUudG9wLCAxMCk7XG4gICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCBzd2FsQ2xhc3Nlcy5pb3NmaXgpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSAnJztcbiAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gb2Zmc2V0ICogLTE7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZpeFNjcm9sbGJhciA9ICgpID0+IHtcbiAgICAvLyBmb3IgcXVldWVzLCBkbyBub3QgZG8gdGhpcyBtb3JlIHRoYW4gb25jZVxuICAgIGlmIChzdGF0ZXMucHJldmlvdXNCb2R5UGFkZGluZyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgYm9keSBoYXMgb3ZlcmZsb3dcbiAgICBpZiAoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIHNvIHRoZSBjb250ZW50IGRvZXNuJ3Qgc2hpZnQgYWZ0ZXIgcmVtb3ZhbCBvZiBzY3JvbGxiYXJcbiAgICAgIHN0YXRlcy5wcmV2aW91c0JvZHlQYWRkaW5nID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgKyBtZWFzdXJlU2Nyb2xsYmFyKCl9cHhgO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdW5kb1Njcm9sbGJhciA9ICgpID0+IHtcbiAgICBpZiAoc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgIT09IG51bGwpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7c3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmd9cHhgO1xuICAgICAgc3RhdGVzLnByZXZpb3VzQm9keVBhZGRpbmcgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKlxuICAgKiBJbnN0YW5jZSBtZXRob2QgdG8gY2xvc2Ugc3dlZXRBbGVydFxuICAgKi9cblxuICBmdW5jdGlvbiByZW1vdmVQb3B1cEFuZFJlc2V0U3RhdGUoaW5zdGFuY2UsIGNvbnRhaW5lciwgcmV0dXJuRm9jdXMsIGRpZENsb3NlKSB7XG4gICAgaWYgKGlzVG9hc3QoKSkge1xuICAgICAgdHJpZ2dlckRpZENsb3NlQW5kRGlzcG9zZShpbnN0YW5jZSwgZGlkQ2xvc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlQWN0aXZlRWxlbWVudChyZXR1cm5Gb2N1cykudGhlbigoKSA9PiB0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlKGluc3RhbmNlLCBkaWRDbG9zZSkpO1xuICAgICAgcmVtb3ZlS2V5ZG93bkhhbmRsZXIoZ2xvYmFsU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgLy8gd29ya2Fyb3VuZCBmb3IgIzIwODhcbiAgICAvLyBmb3Igc29tZSByZWFzb24gcmVtb3ZpbmcgdGhlIGNvbnRhaW5lciBpbiBTYWZhcmkgd2lsbCBzY3JvbGwgdGhlIGRvY3VtZW50IHRvIGJvdHRvbVxuICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTpub25lICFpbXBvcnRhbnQnKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKGlzTW9kYWwoKSkge1xuICAgICAgdW5kb1Njcm9sbGJhcigpO1xuICAgICAgdW5kb0lPU2ZpeCgpO1xuICAgICAgdW5zZXRBcmlhSGlkZGVuKCk7XG4gICAgfVxuICAgIHJlbW92ZUJvZHlDbGFzc2VzKCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlQm9keUNsYXNzZXMoKSB7XG4gICAgcmVtb3ZlQ2xhc3MoW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZG9jdW1lbnQuYm9keV0sIFtzd2FsQ2xhc3Nlcy5zaG93biwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10sIHN3YWxDbGFzc2VzWyduby1iYWNrZHJvcCddLCBzd2FsQ2xhc3Nlc1sndG9hc3Qtc2hvd24nXV0pO1xuICB9XG4gIGZ1bmN0aW9uIGNsb3NlKHJlc29sdmVWYWx1ZSkge1xuICAgIHJlc29sdmVWYWx1ZSA9IHByZXBhcmVSZXNvbHZlVmFsdWUocmVzb2x2ZVZhbHVlKTtcbiAgICBjb25zdCBzd2FsUHJvbWlzZVJlc29sdmUgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlc29sdmUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IGRpZENsb3NlID0gdHJpZ2dlckNsb3NlUG9wdXAodGhpcyk7XG4gICAgaWYgKHRoaXMuaXNBd2FpdGluZ1Byb21pc2UoKSkge1xuICAgICAgLy8gQSBzd2FsIGF3YWl0aW5nIGZvciBhIHByb21pc2UgKGFmdGVyIGEgY2xpY2sgb24gQ29uZmlybSBvciBEZW55KSBjYW5ub3QgYmUgZGlzbWlzc2VkIGFueW1vcmUgIzIzMzVcbiAgICAgIGlmICghcmVzb2x2ZVZhbHVlLmlzRGlzbWlzc2VkKSB7XG4gICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZSh0aGlzKTtcbiAgICAgICAgc3dhbFByb21pc2VSZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaWRDbG9zZSkge1xuICAgICAgLy8gUmVzb2x2ZSBTd2FsIHByb21pc2VcbiAgICAgIHN3YWxQcm9taXNlUmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpc0F3YWl0aW5nUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gISFwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLmdldCh0aGlzKTtcbiAgfVxuICBjb25zdCB0cmlnZ2VyQ2xvc2VQb3B1cCA9IGluc3RhbmNlID0+IHtcbiAgICBjb25zdCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGlmICghaW5uZXJQYXJhbXMgfHwgaGFzQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgYWRkQ2xhc3MocG9wdXAsIGlubmVyUGFyYW1zLmhpZGVDbGFzcy5wb3B1cCk7XG4gICAgY29uc3QgYmFja2Ryb3AgPSBnZXRDb250YWluZXIoKTtcbiAgICByZW1vdmVDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgICBhZGRDbGFzcyhiYWNrZHJvcCwgaW5uZXJQYXJhbXMuaGlkZUNsYXNzLmJhY2tkcm9wKTtcbiAgICBoYW5kbGVQb3B1cEFuaW1hdGlvbihpbnN0YW5jZSwgcG9wdXAsIGlubmVyUGFyYW1zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShlcnJvcikge1xuICAgIGNvbnN0IHJlamVjdFByb21pc2UgPSBwcml2YXRlTWV0aG9kcy5zd2FsUHJvbWlzZVJlamVjdC5nZXQodGhpcyk7XG4gICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKHRoaXMpO1xuICAgIGlmIChyZWplY3RQcm9taXNlKSB7XG4gICAgICAvLyBSZWplY3QgU3dhbCBwcm9taXNlXG4gICAgICByZWplY3RQcm9taXNlKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgaGFuZGxlQXdhaXRpbmdQcm9taXNlID0gaW5zdGFuY2UgPT4ge1xuICAgIGlmIChpbnN0YW5jZS5pc0F3YWl0aW5nUHJvbWlzZSgpKSB7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLmRlbGV0ZShpbnN0YW5jZSk7XG4gICAgICAvLyBUaGUgaW5zdGFuY2UgbWlnaHQgaGF2ZSBiZWVuIHByZXZpb3VzbHkgcGFydGx5IGRlc3Ryb3llZCwgd2UgbXVzdCByZXN1bWUgdGhlIGRlc3Ryb3kgcHJvY2VzcyBpbiB0aGlzIGNhc2UgIzIzMzVcbiAgICAgIGlmICghcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSkpIHtcbiAgICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHByZXBhcmVSZXNvbHZlVmFsdWUgPSByZXNvbHZlVmFsdWUgPT4ge1xuICAgIC8vIFdoZW4gdXNlciBjYWxscyBTd2FsLmNsb3NlKClcbiAgICBpZiAodHlwZW9mIHJlc29sdmVWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29uZmlybWVkOiBmYWxzZSxcbiAgICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgICBpc0Rpc21pc3NlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgaXNDb25maXJtZWQ6IGZhbHNlLFxuICAgICAgaXNEZW5pZWQ6IGZhbHNlLFxuICAgICAgaXNEaXNtaXNzZWQ6IGZhbHNlXG4gICAgfSwgcmVzb2x2ZVZhbHVlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlUG9wdXBBbmltYXRpb24gPSAoaW5zdGFuY2UsIHBvcHVwLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIC8vIElmIGFuaW1hdGlvbiBpcyBzdXBwb3J0ZWQsIGFuaW1hdGVcbiAgICBjb25zdCBhbmltYXRpb25Jc1N1cHBvcnRlZCA9IGFuaW1hdGlvbkVuZEV2ZW50ICYmIGhhc0Nzc0FuaW1hdGlvbihwb3B1cCk7XG4gICAgaWYgKHR5cGVvZiBpbm5lclBhcmFtcy53aWxsQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlubmVyUGFyYW1zLndpbGxDbG9zZShwb3B1cCk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25Jc1N1cHBvcnRlZCkge1xuICAgICAgYW5pbWF0ZVBvcHVwKGluc3RhbmNlLCBwb3B1cCwgY29udGFpbmVyLCBpbm5lclBhcmFtcy5yZXR1cm5Gb2N1cywgaW5uZXJQYXJhbXMuZGlkQ2xvc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHJlbW92ZSBpbW1lZGlhdGVseVxuICAgICAgcmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlKGluc3RhbmNlLCBjb250YWluZXIsIGlubmVyUGFyYW1zLnJldHVybkZvY3VzLCBpbm5lclBhcmFtcy5kaWRDbG9zZSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBhbmltYXRlUG9wdXAgPSAoaW5zdGFuY2UsIHBvcHVwLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSkgPT4ge1xuICAgIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjayA9IHJlbW92ZVBvcHVwQW5kUmVzZXRTdGF0ZS5iaW5kKG51bGwsIGluc3RhbmNlLCBjb250YWluZXIsIHJldHVybkZvY3VzLCBkaWRDbG9zZSk7XG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihhbmltYXRpb25FbmRFdmVudCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gcG9wdXApIHtcbiAgICAgICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS5zd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2s7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IHRyaWdnZXJEaWRDbG9zZUFuZERpc3Bvc2UgPSAoaW5zdGFuY2UsIGRpZENsb3NlKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRpZENsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRpZENsb3NlLmJpbmQoaW5zdGFuY2UucGFyYW1zKSgpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuX2Rlc3Ryb3koKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYnV0dG9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkXG4gICAqL1xuICBmdW5jdGlvbiBzZXRCdXR0b25zRGlzYWJsZWQoaW5zdGFuY2UsIGJ1dHRvbnMsIGRpc2FibGVkKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KGluc3RhbmNlKTtcbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGRvbUNhY2hlW2J1dHRvbl0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICovXG4gIGZ1bmN0aW9uIHNldElucHV0RGlzYWJsZWQoaW5wdXQsIGRpc2FibGVkKSB7XG4gICAgaWYgKCFpbnB1dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgY29uc3QgcmFkaW9zQ29udGFpbmVyID0gaW5wdXQucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgY29uc3QgcmFkaW9zID0gcmFkaW9zQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0Jyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhZGlvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByYWRpb3NbaV0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZW5hYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIGZhbHNlKTtcbiAgfVxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucygpIHtcbiAgICBzZXRCdXR0b25zRGlzYWJsZWQodGhpcywgWydjb25maXJtQnV0dG9uJywgJ2RlbnlCdXR0b24nLCAnY2FuY2VsQnV0dG9uJ10sIHRydWUpO1xuICB9XG4gIGZ1bmN0aW9uIGVuYWJsZUlucHV0KCkge1xuICAgIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGlzYWJsZUlucHV0KCkge1xuICAgIHNldElucHV0RGlzYWJsZWQodGhpcy5nZXRJbnB1dCgpLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG93IGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclxuICAgKi9cbiAgZnVuY3Rpb24gc2hvd1ZhbGlkYXRpb25NZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgZG9tQ2FjaGUgPSBwcml2YXRlUHJvcHMuZG9tQ2FjaGUuZ2V0KHRoaXMpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQodGhpcyk7XG4gICAgc2V0SW5uZXJIdG1sKGRvbUNhY2hlLnZhbGlkYXRpb25NZXNzYWdlLCBlcnJvcik7XG4gICAgZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UuY2xhc3NOYW1lID0gc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddO1xuICAgIGlmIChwYXJhbXMuY3VzdG9tQ2xhc3MgJiYgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICBhZGRDbGFzcyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSwgcGFyYW1zLmN1c3RvbUNsYXNzLnZhbGlkYXRpb25NZXNzYWdlKTtcbiAgICB9XG4gICAgc2hvdyhkb21DYWNoZS52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgY29uc3QgaW5wdXQgPSB0aGlzLmdldElucHV0KCk7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsIHRydWUpO1xuICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jywgc3dhbENsYXNzZXNbJ3ZhbGlkYXRpb24tbWVzc2FnZSddKTtcbiAgICAgIGZvY3VzSW5wdXQoaW5wdXQpO1xuICAgICAgYWRkQ2xhc3MoaW5wdXQsIHN3YWxDbGFzc2VzLmlucHV0ZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIGJsb2NrIHdpdGggdmFsaWRhdGlvbiBtZXNzYWdlXG4gICAqL1xuICBmdW5jdGlvbiByZXNldFZhbGlkYXRpb25NZXNzYWdlKCkge1xuICAgIGNvbnN0IGRvbUNhY2hlID0gcHJpdmF0ZVByb3BzLmRvbUNhY2hlLmdldCh0aGlzKTtcbiAgICBpZiAoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpIHtcbiAgICAgIGhpZGUoZG9tQ2FjaGUudmFsaWRhdGlvbk1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJyk7XG4gICAgICBpbnB1dC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgIHJlbW92ZUNsYXNzKGlucHV0LCBzd2FsQ2xhc3Nlcy5pbnB1dGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgIHRpdGxlOiAnJyxcbiAgICB0aXRsZVRleHQ6ICcnLFxuICAgIHRleHQ6ICcnLFxuICAgIGh0bWw6ICcnLFxuICAgIGZvb3RlcjogJycsXG4gICAgaWNvbjogdW5kZWZpbmVkLFxuICAgIGljb25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGljb25IdG1sOiB1bmRlZmluZWQsXG4gICAgdGVtcGxhdGU6IHVuZGVmaW5lZCxcbiAgICB0b2FzdDogZmFsc2UsXG4gICAgc2hvd0NsYXNzOiB7XG4gICAgICBwb3B1cDogJ3N3YWwyLXNob3cnLFxuICAgICAgYmFja2Ryb3A6ICdzd2FsMi1iYWNrZHJvcC1zaG93JyxcbiAgICAgIGljb246ICdzd2FsMi1pY29uLXNob3cnXG4gICAgfSxcbiAgICBoaWRlQ2xhc3M6IHtcbiAgICAgIHBvcHVwOiAnc3dhbDItaGlkZScsXG4gICAgICBiYWNrZHJvcDogJ3N3YWwyLWJhY2tkcm9wLWhpZGUnLFxuICAgICAgaWNvbjogJ3N3YWwyLWljb24taGlkZSdcbiAgICB9LFxuICAgIGN1c3RvbUNsYXNzOiB7fSxcbiAgICB0YXJnZXQ6ICdib2R5JyxcbiAgICBjb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGhlaWdodEF1dG86IHRydWUsXG4gICAgYWxsb3dPdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgYWxsb3dFc2NhcGVLZXk6IHRydWUsXG4gICAgYWxsb3dFbnRlcktleTogdHJ1ZSxcbiAgICBzdG9wS2V5ZG93blByb3BhZ2F0aW9uOiB0cnVlLFxuICAgIGtleWRvd25MaXN0ZW5lckNhcHR1cmU6IGZhbHNlLFxuICAgIHNob3dDb25maXJtQnV0dG9uOiB0cnVlLFxuICAgIHNob3dEZW55QnV0dG9uOiBmYWxzZSxcbiAgICBzaG93Q2FuY2VsQnV0dG9uOiBmYWxzZSxcbiAgICBwcmVDb25maXJtOiB1bmRlZmluZWQsXG4gICAgcHJlRGVueTogdW5kZWZpbmVkLFxuICAgIGNvbmZpcm1CdXR0b25UZXh0OiAnT0snLFxuICAgIGNvbmZpcm1CdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGNvbmZpcm1CdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGRlbnlCdXR0b25UZXh0OiAnTm8nLFxuICAgIGRlbnlCdXR0b25BcmlhTGFiZWw6ICcnLFxuICAgIGRlbnlCdXR0b25Db2xvcjogdW5kZWZpbmVkLFxuICAgIGNhbmNlbEJ1dHRvblRleHQ6ICdDYW5jZWwnLFxuICAgIGNhbmNlbEJ1dHRvbkFyaWFMYWJlbDogJycsXG4gICAgY2FuY2VsQnV0dG9uQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBidXR0b25zU3R5bGluZzogdHJ1ZSxcbiAgICByZXZlcnNlQnV0dG9uczogZmFsc2UsXG4gICAgZm9jdXNDb25maXJtOiB0cnVlLFxuICAgIGZvY3VzRGVueTogZmFsc2UsXG4gICAgZm9jdXNDYW5jZWw6IGZhbHNlLFxuICAgIHJldHVybkZvY3VzOiB0cnVlLFxuICAgIHNob3dDbG9zZUJ1dHRvbjogZmFsc2UsXG4gICAgY2xvc2VCdXR0b25IdG1sOiAnJnRpbWVzOycsXG4gICAgY2xvc2VCdXR0b25BcmlhTGFiZWw6ICdDbG9zZSB0aGlzIGRpYWxvZycsXG4gICAgbG9hZGVySHRtbDogJycsXG4gICAgc2hvd0xvYWRlck9uQ29uZmlybTogZmFsc2UsXG4gICAgc2hvd0xvYWRlck9uRGVueTogZmFsc2UsXG4gICAgaW1hZ2VVcmw6IHVuZGVmaW5lZCxcbiAgICBpbWFnZVdpZHRoOiB1bmRlZmluZWQsXG4gICAgaW1hZ2VIZWlnaHQ6IHVuZGVmaW5lZCxcbiAgICBpbWFnZUFsdDogJycsXG4gICAgdGltZXI6IHVuZGVmaW5lZCxcbiAgICB0aW1lclByb2dyZXNzQmFyOiBmYWxzZSxcbiAgICB3aWR0aDogdW5kZWZpbmVkLFxuICAgIHBhZGRpbmc6IHVuZGVmaW5lZCxcbiAgICBiYWNrZ3JvdW5kOiB1bmRlZmluZWQsXG4gICAgaW5wdXQ6IHVuZGVmaW5lZCxcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiAnJyxcbiAgICBpbnB1dExhYmVsOiAnJyxcbiAgICBpbnB1dFZhbHVlOiAnJyxcbiAgICBpbnB1dE9wdGlvbnM6IHt9LFxuICAgIGlucHV0QXV0b1RyaW06IHRydWUsXG4gICAgaW5wdXRBdHRyaWJ1dGVzOiB7fSxcbiAgICBpbnB1dFZhbGlkYXRvcjogdW5kZWZpbmVkLFxuICAgIHJldHVybklucHV0VmFsdWVPbkRlbnk6IGZhbHNlLFxuICAgIHZhbGlkYXRpb25NZXNzYWdlOiB1bmRlZmluZWQsXG4gICAgZ3JvdzogZmFsc2UsXG4gICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgIHByb2dyZXNzU3RlcHM6IFtdLFxuICAgIGN1cnJlbnRQcm9ncmVzc1N0ZXA6IHVuZGVmaW5lZCxcbiAgICBwcm9ncmVzc1N0ZXBzRGlzdGFuY2U6IHVuZGVmaW5lZCxcbiAgICB3aWxsT3BlbjogdW5kZWZpbmVkLFxuICAgIGRpZE9wZW46IHVuZGVmaW5lZCxcbiAgICBkaWRSZW5kZXI6IHVuZGVmaW5lZCxcbiAgICB3aWxsQ2xvc2U6IHVuZGVmaW5lZCxcbiAgICBkaWRDbG9zZTogdW5kZWZpbmVkLFxuICAgIGRpZERlc3Ryb3k6IHVuZGVmaW5lZCxcbiAgICBzY3JvbGxiYXJQYWRkaW5nOiB0cnVlXG4gIH07XG4gIGNvbnN0IHVwZGF0YWJsZVBhcmFtcyA9IFsnYWxsb3dFc2NhcGVLZXknLCAnYWxsb3dPdXRzaWRlQ2xpY2snLCAnYmFja2dyb3VuZCcsICdidXR0b25zU3R5bGluZycsICdjYW5jZWxCdXR0b25BcmlhTGFiZWwnLCAnY2FuY2VsQnV0dG9uQ29sb3InLCAnY2FuY2VsQnV0dG9uVGV4dCcsICdjbG9zZUJ1dHRvbkFyaWFMYWJlbCcsICdjbG9zZUJ1dHRvbkh0bWwnLCAnY29sb3InLCAnY29uZmlybUJ1dHRvbkFyaWFMYWJlbCcsICdjb25maXJtQnV0dG9uQ29sb3InLCAnY29uZmlybUJ1dHRvblRleHQnLCAnY3VycmVudFByb2dyZXNzU3RlcCcsICdjdXN0b21DbGFzcycsICdkZW55QnV0dG9uQXJpYUxhYmVsJywgJ2RlbnlCdXR0b25Db2xvcicsICdkZW55QnV0dG9uVGV4dCcsICdkaWRDbG9zZScsICdkaWREZXN0cm95JywgJ2Zvb3RlcicsICdoaWRlQ2xhc3MnLCAnaHRtbCcsICdpY29uJywgJ2ljb25Db2xvcicsICdpY29uSHRtbCcsICdpbWFnZUFsdCcsICdpbWFnZUhlaWdodCcsICdpbWFnZVVybCcsICdpbWFnZVdpZHRoJywgJ3ByZUNvbmZpcm0nLCAncHJlRGVueScsICdwcm9ncmVzc1N0ZXBzJywgJ3JldHVybkZvY3VzJywgJ3JldmVyc2VCdXR0b25zJywgJ3Nob3dDYW5jZWxCdXR0b24nLCAnc2hvd0Nsb3NlQnV0dG9uJywgJ3Nob3dDb25maXJtQnV0dG9uJywgJ3Nob3dEZW55QnV0dG9uJywgJ3RleHQnLCAndGl0bGUnLCAndGl0bGVUZXh0JywgJ3dpbGxDbG9zZSddO1xuICBjb25zdCBkZXByZWNhdGVkUGFyYW1zID0ge307XG4gIGNvbnN0IHRvYXN0SW5jb21wYXRpYmxlUGFyYW1zID0gWydhbGxvd091dHNpZGVDbGljaycsICdhbGxvd0VudGVyS2V5JywgJ2JhY2tkcm9wJywgJ2ZvY3VzQ29uZmlybScsICdmb2N1c0RlbnknLCAnZm9jdXNDYW5jZWwnLCAncmV0dXJuRm9jdXMnLCAnaGVpZ2h0QXV0bycsICdrZXlkb3duTGlzdGVuZXJDYXB0dXJlJ107XG5cbiAgLyoqXG4gICAqIElzIHZhbGlkIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNWYWxpZFBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZWZhdWx0UGFyYW1zLCBwYXJhbU5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyB2YWxpZCBwYXJhbWV0ZXIgZm9yIFN3YWwudXBkYXRlKCkgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc1VwZGF0YWJsZVBhcmFtZXRlciA9IHBhcmFtTmFtZSA9PiB7XG4gICAgcmV0dXJuIHVwZGF0YWJsZVBhcmFtcy5pbmRleE9mKHBhcmFtTmFtZSkgIT09IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBkZXByZWNhdGVkIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIgPSBwYXJhbU5hbWUgPT4ge1xuICAgIHJldHVybiBkZXByZWNhdGVkUGFyYW1zW3BhcmFtTmFtZV07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICAgKi9cbiAgY29uc3QgY2hlY2tJZlBhcmFtSXNWYWxpZCA9IHBhcmFtID0+IHtcbiAgICBpZiAoIWlzVmFsaWRQYXJhbWV0ZXIocGFyYW0pKSB7XG4gICAgICB3YXJuKGBVbmtub3duIHBhcmFtZXRlciBcIiR7cGFyYW19XCJgKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbVxuICAgKi9cbiAgY29uc3QgY2hlY2tJZlRvYXN0UGFyYW1Jc1ZhbGlkID0gcGFyYW0gPT4ge1xuICAgIGlmICh0b2FzdEluY29tcGF0aWJsZVBhcmFtcy5pbmNsdWRlcyhwYXJhbSkpIHtcbiAgICAgIHdhcm4oYFRoZSBwYXJhbWV0ZXIgXCIke3BhcmFtfVwiIGlzIGluY29tcGF0aWJsZSB3aXRoIHRvYXN0c2ApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtXG4gICAqL1xuICBjb25zdCBjaGVja0lmUGFyYW1Jc0RlcHJlY2F0ZWQgPSBwYXJhbSA9PiB7XG4gICAgaWYgKGlzRGVwcmVjYXRlZFBhcmFtZXRlcihwYXJhbSkpIHtcbiAgICAgIHdhcm5BYm91dERlcHJlY2F0aW9uKHBhcmFtLCBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXIocGFyYW0pKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNob3cgcmVsZXZhbnQgd2FybmluZ3MgZm9yIGdpdmVuIHBhcmFtc1xuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IHNob3dXYXJuaW5nc0ZvclBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgaWYgKHBhcmFtcy5iYWNrZHJvcCA9PT0gZmFsc2UgJiYgcGFyYW1zLmFsbG93T3V0c2lkZUNsaWNrKSB7XG4gICAgICB3YXJuKCdcImFsbG93T3V0c2lkZUNsaWNrXCIgcGFyYW1ldGVyIHJlcXVpcmVzIGBiYWNrZHJvcGAgcGFyYW1ldGVyIHRvIGJlIHNldCB0byBgdHJ1ZWAnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBwYXJhbSBpbiBwYXJhbXMpIHtcbiAgICAgIGNoZWNrSWZQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgaWYgKHBhcmFtcy50b2FzdCkge1xuICAgICAgICBjaGVja0lmVG9hc3RQYXJhbUlzVmFsaWQocGFyYW0pO1xuICAgICAgfVxuICAgICAgY2hlY2tJZlBhcmFtSXNEZXByZWNhdGVkKHBhcmFtKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgcG9wdXAgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGUocGFyYW1zKSB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldCh0aGlzKTtcbiAgICBpZiAoIXBvcHVwIHx8IGhhc0NsYXNzKHBvcHVwLCBpbm5lclBhcmFtcy5oaWRlQ2xhc3MucG9wdXApKSB7XG4gICAgICB3YXJuKGBZb3UncmUgdHJ5aW5nIHRvIHVwZGF0ZSB0aGUgY2xvc2VkIG9yIGNsb3NpbmcgcG9wdXAsIHRoYXQgd29uJ3Qgd29yay4gVXNlIHRoZSB1cGRhdGUoKSBtZXRob2QgaW4gcHJlQ29uZmlybSBwYXJhbWV0ZXIgb3Igc2hvdyBhIG5ldyBwb3B1cC5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSBmaWx0ZXJWYWxpZFBhcmFtcyhwYXJhbXMpO1xuICAgIGNvbnN0IHVwZGF0ZWRQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lclBhcmFtcywgdmFsaWRVcGRhdGFibGVQYXJhbXMpO1xuICAgIHJlbmRlcih0aGlzLCB1cGRhdGVkUGFyYW1zKTtcbiAgICBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuc2V0KHRoaXMsIHVwZGF0ZWRQYXJhbXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHBhcmFtcyksXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBmaWx0ZXJWYWxpZFBhcmFtcyA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgdmFsaWRVcGRhdGFibGVQYXJhbXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgaWYgKGlzVXBkYXRhYmxlUGFyYW1ldGVyKHBhcmFtKSkge1xuICAgICAgICB2YWxpZFVwZGF0YWJsZVBhcmFtc1twYXJhbV0gPSBwYXJhbXNbcGFyYW1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybihgSW52YWxpZCBwYXJhbWV0ZXIgdG8gdXBkYXRlOiAke3BhcmFtfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWxpZFVwZGF0YWJsZVBhcmFtcztcbiAgfTtcblxuICBmdW5jdGlvbiBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBkb21DYWNoZSA9IHByaXZhdGVQcm9wcy5kb21DYWNoZS5nZXQodGhpcyk7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KHRoaXMpO1xuICAgIGlmICghaW5uZXJQYXJhbXMpIHtcbiAgICAgIGRpc3Bvc2VXZWFrTWFwcyh0aGlzKTsgLy8gVGhlIFdlYWtNYXBzIG1pZ2h0IGhhdmUgYmVlbiBwYXJ0bHkgZGVzdHJveWVkLCB3ZSBtdXN0IHJlY2FsbCBpdCB0byBkaXNwb3NlIGFueSByZW1haW5pbmcgV2Vha01hcHMgIzIzMzVcbiAgICAgIHJldHVybjsgLy8gVGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZFxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGFub3RoZXIgU3dhbCBjbG9zaW5nXG4gICAgaWYgKGRvbUNhY2hlLnBvcHVwICYmIGdsb2JhbFN0YXRlLnN3YWxDbG9zZUV2ZW50RmluaXNoZWRDYWxsYmFjaykge1xuICAgICAgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrKCk7XG4gICAgICBkZWxldGUgZ2xvYmFsU3RhdGUuc3dhbENsb3NlRXZlbnRGaW5pc2hlZENhbGxiYWNrO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlubmVyUGFyYW1zLmRpZERlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlubmVyUGFyYW1zLmRpZERlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlzcG9zZVN3YWwodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0IGRpc3Bvc2VTd2FsID0gaW5zdGFuY2UgPT4ge1xuICAgIGRpc3Bvc2VXZWFrTWFwcyhpbnN0YW5jZSk7XG4gICAgLy8gVW5zZXQgdGhpcy5wYXJhbXMgc28gR0Mgd2lsbCBkaXNwb3NlIGl0ICgjMTU2OSlcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZGVsZXRlIGluc3RhbmNlLnBhcmFtcztcbiAgICAvLyBVbnNldCBnbG9iYWxTdGF0ZSBwcm9wcyBzbyBHQyB3aWxsIGRpc3Bvc2UgZ2xvYmFsU3RhdGUgKCMxNTY5KVxuICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS5rZXlkb3duSGFuZGxlcjtcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUua2V5ZG93blRhcmdldDtcbiAgICAvLyBVbnNldCBjdXJyZW50SW5zdGFuY2VcbiAgICBkZWxldGUgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3QgZGlzcG9zZVdlYWtNYXBzID0gaW5zdGFuY2UgPT4ge1xuICAgIC8vIElmIHRoZSBjdXJyZW50IGluc3RhbmNlIGlzIGF3YWl0aW5nIGEgcHJvbWlzZSByZXN1bHQsIHdlIGtlZXAgdGhlIHByaXZhdGVNZXRob2RzIHRvIGNhbGwgdGhlbSBvbmNlIHRoZSBwcm9taXNlIHJlc3VsdCBpcyByZXRyaWV2ZWQgIzIzMzVcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGluc3RhbmNlLmlzQXdhaXRpbmdQcm9taXNlKCkpIHtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLnNldChpbnN0YW5jZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZU1ldGhvZHMsIGluc3RhbmNlKTtcbiAgICAgIHVuc2V0V2Vha01hcHMocHJpdmF0ZVByb3BzLCBpbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqL1xuICBjb25zdCB1bnNldFdlYWtNYXBzID0gKG9iaiwgaW5zdGFuY2UpID0+IHtcbiAgICBmb3IgKGNvbnN0IGkgaW4gb2JqKSB7XG4gICAgICBvYmpbaV0uZGVsZXRlKGluc3RhbmNlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluc3RhbmNlTWV0aG9kcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgaGlkZUxvYWRpbmc6IGhpZGVMb2FkaW5nLFxuICAgIGRpc2FibGVMb2FkaW5nOiBoaWRlTG9hZGluZyxcbiAgICBnZXRJbnB1dDogZ2V0SW5wdXQsXG4gICAgY2xvc2U6IGNsb3NlLFxuICAgIGlzQXdhaXRpbmdQcm9taXNlOiBpc0F3YWl0aW5nUHJvbWlzZSxcbiAgICByZWplY3RQcm9taXNlOiByZWplY3RQcm9taXNlLFxuICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZTogaGFuZGxlQXdhaXRpbmdQcm9taXNlLFxuICAgIGNsb3NlUG9wdXA6IGNsb3NlLFxuICAgIGNsb3NlTW9kYWw6IGNsb3NlLFxuICAgIGNsb3NlVG9hc3Q6IGNsb3NlLFxuICAgIGVuYWJsZUJ1dHRvbnM6IGVuYWJsZUJ1dHRvbnMsXG4gICAgZGlzYWJsZUJ1dHRvbnM6IGRpc2FibGVCdXR0b25zLFxuICAgIGVuYWJsZUlucHV0OiBlbmFibGVJbnB1dCxcbiAgICBkaXNhYmxlSW5wdXQ6IGRpc2FibGVJbnB1dCxcbiAgICBzaG93VmFsaWRhdGlvbk1lc3NhZ2U6IHNob3dWYWxpZGF0aW9uTWVzc2FnZSxcbiAgICByZXNldFZhbGlkYXRpb25NZXNzYWdlOiByZXNldFZhbGlkYXRpb25NZXNzYWdlLFxuICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgIF9kZXN0cm95OiBfZGVzdHJveVxuICB9KTtcblxuICAvKipcbiAgICogU2hvd3MgbG9hZGVyIChzcGlubmVyKSwgdGhpcyBpcyB1c2VmdWwgd2l0aCBBSkFYIHJlcXVlc3RzLlxuICAgKiBCeSBkZWZhdWx0IHRoZSBsb2FkZXIgYmUgc2hvd24gaW5zdGVhZCBvZiB0aGUgXCJDb25maXJtXCIgYnV0dG9uLlxuICAgKi9cbiAgY29uc3Qgc2hvd0xvYWRpbmcgPSBidXR0b25Ub1JlcGxhY2UgPT4ge1xuICAgIGxldCBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgaWYgKCFwb3B1cCkge1xuICAgICAgbmV3IFN3YWwoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9XG5cbiAgICBwb3B1cCA9IGdldFBvcHVwKCk7XG4gICAgY29uc3QgbG9hZGVyID0gZ2V0TG9hZGVyKCk7XG4gICAgaWYgKGlzVG9hc3QoKSkge1xuICAgICAgaGlkZShnZXRJY29uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlQnV0dG9uKHBvcHVwLCBidXR0b25Ub1JlcGxhY2UpO1xuICAgIH1cbiAgICBzaG93KGxvYWRlcik7XG4gICAgcG9wdXAuc2V0QXR0cmlidXRlKCdkYXRhLWxvYWRpbmcnLCAndHJ1ZScpO1xuICAgIHBvcHVwLnNldEF0dHJpYnV0ZSgnYXJpYS1idXN5JywgJ3RydWUnKTtcbiAgICBwb3B1cC5mb2N1cygpO1xuICB9O1xuICBjb25zdCByZXBsYWNlQnV0dG9uID0gKHBvcHVwLCBidXR0b25Ub1JlcGxhY2UpID0+IHtcbiAgICBjb25zdCBhY3Rpb25zID0gZ2V0QWN0aW9ucygpO1xuICAgIGNvbnN0IGxvYWRlciA9IGdldExvYWRlcigpO1xuICAgIGlmICghYnV0dG9uVG9SZXBsYWNlICYmIGlzVmlzaWJsZSQxKGdldENvbmZpcm1CdXR0b24oKSkpIHtcbiAgICAgIGJ1dHRvblRvUmVwbGFjZSA9IGdldENvbmZpcm1CdXR0b24oKTtcbiAgICB9XG4gICAgc2hvdyhhY3Rpb25zKTtcbiAgICBpZiAoYnV0dG9uVG9SZXBsYWNlKSB7XG4gICAgICBoaWRlKGJ1dHRvblRvUmVwbGFjZSk7XG4gICAgICBsb2FkZXIuc2V0QXR0cmlidXRlKCdkYXRhLWJ1dHRvbi10by1yZXBsYWNlJywgYnV0dG9uVG9SZXBsYWNlLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGxvYWRlci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsb2FkZXIsIGJ1dHRvblRvUmVwbGFjZSk7XG4gICAgYWRkQ2xhc3MoW3BvcHVwLCBhY3Rpb25zXSwgc3dhbENsYXNzZXMubG9hZGluZyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHsgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB9IElucHV0VmFsdWVcbiAgICovXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgaGFuZGxlSW5wdXRPcHRpb25zQW5kVmFsdWUgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGlmIChwYXJhbXMuaW5wdXQgPT09ICdzZWxlY3QnIHx8IHBhcmFtcy5pbnB1dCA9PT0gJ3JhZGlvJykge1xuICAgICAgaGFuZGxlSW5wdXRPcHRpb25zKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAoWyd0ZXh0JywgJ2VtYWlsJywgJ251bWJlcicsICd0ZWwnLCAndGV4dGFyZWEnXS5pbmNsdWRlcyhwYXJhbXMuaW5wdXQpICYmIChoYXNUb1Byb21pc2VGbihwYXJhbXMuaW5wdXRWYWx1ZSkgfHwgaXNQcm9taXNlKHBhcmFtcy5pbnB1dFZhbHVlKSkpIHtcbiAgICAgIHNob3dMb2FkaW5nKGdldENvbmZpcm1CdXR0b24oKSk7XG4gICAgICBoYW5kbGVJbnB1dFZhbHVlKGluc3RhbmNlLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge3N0cmluZyB8IG51bWJlciB8IEZpbGUgfCBGaWxlTGlzdCB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRJbnB1dFZhbHVlID0gKGluc3RhbmNlLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gaW5zdGFuY2UuZ2V0SW5wdXQoKTtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3dpdGNoIChpbm5lclBhcmFtcy5pbnB1dCkge1xuICAgICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShpbnB1dCk7XG4gICAgICBjYXNlICdyYWRpbyc6XG4gICAgICAgIHJldHVybiBnZXRSYWRpb1ZhbHVlKGlucHV0KTtcbiAgICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgICByZXR1cm4gZ2V0RmlsZVZhbHVlKGlucHV0KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBpbm5lclBhcmFtcy5pbnB1dEF1dG9UcmltID8gaW5wdXQudmFsdWUudHJpbSgpIDogaW5wdXQudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBjb25zdCBnZXRDaGVja2JveFZhbHVlID0gaW5wdXQgPT4gaW5wdXQuY2hlY2tlZCA/IDEgOiAwO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxJbnB1dEVsZW1lbnR9IGlucHV0XG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgY29uc3QgZ2V0UmFkaW9WYWx1ZSA9IGlucHV0ID0+IGlucHV0LmNoZWNrZWQgPyBpbnB1dC52YWx1ZSA6IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXRcbiAgICogQHJldHVybnMge0ZpbGVMaXN0IHwgRmlsZSB8IG51bGx9XG4gICAqL1xuICBjb25zdCBnZXRGaWxlVmFsdWUgPSBpbnB1dCA9PiBpbnB1dC5maWxlcy5sZW5ndGggPyBpbnB1dC5nZXRBdHRyaWJ1dGUoJ211bHRpcGxlJykgIT09IG51bGwgPyBpbnB1dC5maWxlcyA6IGlucHV0LmZpbGVzWzBdIDogbnVsbDtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBjb25zdCBoYW5kbGVJbnB1dE9wdGlvbnMgPSAoaW5zdGFuY2UsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHBvcHVwID0gZ2V0UG9wdXAoKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGlucHV0T3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0IHByb2Nlc3NJbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnMgPT4ge1xuICAgICAgcG9wdWxhdGVJbnB1dE9wdGlvbnNbcGFyYW1zLmlucHV0XShwb3B1cCwgZm9ybWF0SW5wdXRPcHRpb25zKGlucHV0T3B0aW9ucyksIHBhcmFtcyk7XG4gICAgfTtcbiAgICBpZiAoaGFzVG9Qcm9taXNlRm4ocGFyYW1zLmlucHV0T3B0aW9ucykgfHwgaXNQcm9taXNlKHBhcmFtcy5pbnB1dE9wdGlvbnMpKSB7XG4gICAgICBzaG93TG9hZGluZyhnZXRDb25maXJtQnV0dG9uKCkpO1xuICAgICAgYXNQcm9taXNlKHBhcmFtcy5pbnB1dE9wdGlvbnMpLnRoZW4oaW5wdXRPcHRpb25zID0+IHtcbiAgICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICAgICAgcHJvY2Vzc0lucHV0T3B0aW9ucyhpbnB1dE9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zLmlucHV0T3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHByb2Nlc3NJbnB1dE9wdGlvbnMocGFyYW1zLmlucHV0T3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKGBVbmV4cGVjdGVkIHR5cGUgb2YgaW5wdXRPcHRpb25zISBFeHBlY3RlZCBvYmplY3QsIE1hcCBvciBQcm9taXNlLCBnb3QgJHt0eXBlb2YgcGFyYW1zLmlucHV0T3B0aW9uc31gKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgKi9cbiAgY29uc3QgaGFuZGxlSW5wdXRWYWx1ZSA9IChpbnN0YW5jZSwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5wdXQgPSBpbnN0YW5jZS5nZXRJbnB1dCgpO1xuICAgIGhpZGUoaW5wdXQpO1xuICAgIGFzUHJvbWlzZShwYXJhbXMuaW5wdXRWYWx1ZSkudGhlbihpbnB1dFZhbHVlID0+IHtcbiAgICAgIGlucHV0LnZhbHVlID0gcGFyYW1zLmlucHV0ID09PSAnbnVtYmVyJyA/IGAke3BhcnNlRmxvYXQoaW5wdXRWYWx1ZSkgfHwgMH1gIDogYCR7aW5wdXRWYWx1ZX1gO1xuICAgICAgc2hvdyhpbnB1dCk7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgZXJyb3IoYEVycm9yIGluIGlucHV0VmFsdWUgcHJvbWlzZTogJHtlcnJ9YCk7XG4gICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgc2hvdyhpbnB1dCk7XG4gICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgaW5zdGFuY2UuaGlkZUxvYWRpbmcoKTtcbiAgICB9KTtcbiAgfTtcbiAgY29uc3QgcG9wdWxhdGVJbnB1dE9wdGlvbnMgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wdXBcbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGlucHV0T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHBhcmFtc1xuICAgICAqL1xuICAgIHNlbGVjdDogKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0ID0gZ2V0RGlyZWN0Q2hpbGRCeUNsYXNzKHBvcHVwLCBzd2FsQ2xhc3Nlcy5zZWxlY3QpO1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25MYWJlbFxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvblZhbHVlXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbmRlck9wdGlvbiA9IChwYXJlbnQsIG9wdGlvbkxhYmVsLCBvcHRpb25WYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gb3B0aW9uVmFsdWU7XG4gICAgICAgIHNldElubmVySHRtbChvcHRpb24sIG9wdGlvbkxhYmVsKTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gaXNTZWxlY3RlZChvcHRpb25WYWx1ZSwgcGFyYW1zLmlucHV0VmFsdWUpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgIH07XG4gICAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChpbnB1dE9wdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IG9wdGlvblZhbHVlID0gaW5wdXRPcHRpb25bMF07XG4gICAgICAgIGNvbnN0IG9wdGlvbkxhYmVsID0gaW5wdXRPcHRpb25bMV07XG4gICAgICAgIC8vIDxvcHRncm91cD4gc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw0MDEvaW50ZXJhY3QvZm9ybXMuaHRtbCNoLTE3LjZcbiAgICAgICAgLy8gXCIuLi5hbGwgT1BUR1JPVVAgZWxlbWVudHMgbXVzdCBiZSBzcGVjaWZpZWQgZGlyZWN0bHkgd2l0aGluIGEgU0VMRUNUIGVsZW1lbnQgKGkuZS4sIGdyb3VwcyBtYXkgbm90IGJlIG5lc3RlZCkuLi5cIlxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHRoaXMgaXMgYSA8b3B0Z3JvdXA+XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbkxhYmVsKSkge1xuICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5LCB0aGVuIGl0IGlzIGFuIDxvcHRncm91cD5cbiAgICAgICAgICBjb25zdCBvcHRncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XG4gICAgICAgICAgb3B0Z3JvdXAubGFiZWwgPSBvcHRpb25WYWx1ZTtcbiAgICAgICAgICBvcHRncm91cC5kaXNhYmxlZCA9IGZhbHNlOyAvLyBub3QgY29uZmlndXJhYmxlIGZvciBub3dcbiAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0Z3JvdXApO1xuICAgICAgICAgIG9wdGlvbkxhYmVsLmZvckVhY2gobyA9PiByZW5kZXJPcHRpb24ob3B0Z3JvdXAsIG9bMV0sIG9bMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYXNlIG9mIDxvcHRpb24+XG4gICAgICAgICAgcmVuZGVyT3B0aW9uKHNlbGVjdCwgb3B0aW9uTGFiZWwsIG9wdGlvblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBzZWxlY3QuZm9jdXMoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHVwXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBpbnB1dE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICAgKi9cbiAgICByYWRpbzogKHBvcHVwLCBpbnB1dE9wdGlvbnMsIHBhcmFtcykgPT4ge1xuICAgICAgY29uc3QgcmFkaW8gPSBnZXREaXJlY3RDaGlsZEJ5Q2xhc3MocG9wdXAsIHN3YWxDbGFzc2VzLnJhZGlvKTtcbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKGlucHV0T3B0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmFkaW9WYWx1ZSA9IGlucHV0T3B0aW9uWzBdO1xuICAgICAgICBjb25zdCByYWRpb0xhYmVsID0gaW5wdXRPcHRpb25bMV07XG4gICAgICAgIGNvbnN0IHJhZGlvSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBjb25zdCByYWRpb0xhYmVsRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHJhZGlvSW5wdXQudHlwZSA9ICdyYWRpbyc7XG4gICAgICAgIHJhZGlvSW5wdXQubmFtZSA9IHN3YWxDbGFzc2VzLnJhZGlvO1xuICAgICAgICByYWRpb0lucHV0LnZhbHVlID0gcmFkaW9WYWx1ZTtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQocmFkaW9WYWx1ZSwgcGFyYW1zLmlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgcmFkaW9JbnB1dC5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc2V0SW5uZXJIdG1sKGxhYmVsLCByYWRpb0xhYmVsKTtcbiAgICAgICAgbGFiZWwuY2xhc3NOYW1lID0gc3dhbENsYXNzZXMubGFiZWw7XG4gICAgICAgIHJhZGlvTGFiZWxFbGVtZW50LmFwcGVuZENoaWxkKHJhZGlvSW5wdXQpO1xuICAgICAgICByYWRpb0xhYmVsRWxlbWVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIHJhZGlvLmFwcGVuZENoaWxkKHJhZGlvTGFiZWxFbGVtZW50KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmFkaW9zID0gcmFkaW8ucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKTtcbiAgICAgIGlmIChyYWRpb3MubGVuZ3RoKSB7XG4gICAgICAgIHJhZGlvc1swXS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYGlucHV0T3B0aW9uc2AgaW50byBhbiBhcnJheSBvZiBgW3ZhbHVlLCBsYWJlbF1gc1xuICAgKlxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IGlucHV0T3B0aW9uc1xuICAgKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8c3RyaW5nPj59XG4gICAqL1xuICBjb25zdCBmb3JtYXRJbnB1dE9wdGlvbnMgPSBpbnB1dE9wdGlvbnMgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmICh0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJiBpbnB1dE9wdGlvbnMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGlucHV0T3B0aW9ucy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZUZvcm1hdHRlZCA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlRm9ybWF0dGVkID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIC8vIGNhc2Ugb2YgPG9wdGdyb3VwPlxuICAgICAgICAgIHZhbHVlRm9ybWF0dGVkID0gZm9ybWF0SW5wdXRPcHRpb25zKHZhbHVlRm9ybWF0dGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChba2V5LCB2YWx1ZUZvcm1hdHRlZF0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKGlucHV0T3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBsZXQgdmFsdWVGb3JtYXR0ZWQgPSBpbnB1dE9wdGlvbnNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZUZvcm1hdHRlZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBjYXNlIG9mIDxvcHRncm91cD5cbiAgICAgICAgICB2YWx1ZUZvcm1hdHRlZCA9IGZvcm1hdElucHV0T3B0aW9ucyh2YWx1ZUZvcm1hdHRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVGb3JtYXR0ZWRdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9uVmFsdWVcbiAgICogQHBhcmFtIHtJbnB1dFZhbHVlIHwgUHJvbWlzZTxJbnB1dFZhbHVlPiB8IHsgdG9Qcm9taXNlOiAoKSA9PiBJbnB1dFZhbHVlIH19IGlucHV0VmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc1NlbGVjdGVkID0gKG9wdGlvblZhbHVlLCBpbnB1dFZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS50b1N0cmluZygpID09PSBvcHRpb25WYWx1ZS50b1N0cmluZygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrID0gaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGlubmVyUGFyYW1zID0gcHJpdmF0ZVByb3BzLmlubmVyUGFyYW1zLmdldChpbnN0YW5jZSk7XG4gICAgaW5zdGFuY2UuZGlzYWJsZUJ1dHRvbnMoKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICAgIGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQoaW5zdGFuY2UsICdjb25maXJtJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbmZpcm0oaW5zdGFuY2UsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICovXG4gIGNvbnN0IGhhbmRsZURlbnlCdXR0b25DbGljayA9IGluc3RhbmNlID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLmRpc2FibGVCdXR0b25zKCk7XG4gICAgaWYgKGlubmVyUGFyYW1zLnJldHVybklucHV0VmFsdWVPbkRlbnkpIHtcbiAgICAgIGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQoaW5zdGFuY2UsICdkZW55Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbnkoaW5zdGFuY2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc21pc3NXaXRoXG4gICAqL1xuICBjb25zdCBoYW5kbGVDYW5jZWxCdXR0b25DbGljayA9IChpbnN0YW5jZSwgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBpbnN0YW5jZS5kaXNhYmxlQnV0dG9ucygpO1xuICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2FuY2VsKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHsnY29uZmlybScgfCAnZGVueSd9IHR5cGVcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQgPSAoaW5zdGFuY2UsIHR5cGUpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGlmICghaW5uZXJQYXJhbXMuaW5wdXQpIHtcbiAgICAgIGVycm9yKGBUaGUgXCJpbnB1dFwiIHBhcmFtZXRlciBpcyBuZWVkZWQgdG8gYmUgc2V0IHdoZW4gdXNpbmcgcmV0dXJuSW5wdXRWYWx1ZU9uJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIodHlwZSl9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBnZXRJbnB1dFZhbHVlKGluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgaWYgKGlubmVyUGFyYW1zLmlucHV0VmFsaWRhdG9yKSB7XG4gICAgICBoYW5kbGVJbnB1dFZhbGlkYXRvcihpbnN0YW5jZSwgaW5wdXRWYWx1ZSwgdHlwZSk7XG4gICAgfSBlbHNlIGlmICghaW5zdGFuY2UuZ2V0SW5wdXQoKS5jaGVja1ZhbGlkaXR5KCkpIHtcbiAgICAgIGluc3RhbmNlLmVuYWJsZUJ1dHRvbnMoKTtcbiAgICAgIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZShpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZGVueScpIHtcbiAgICAgIGRlbnkoaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maXJtKGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgRmlsZSB8IEZpbGVMaXN0IHwgbnVsbH0gaW5wdXRWYWx1ZVxuICAgKiBAcGFyYW0geydjb25maXJtJyB8ICdkZW55J30gdHlwZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlSW5wdXRWYWxpZGF0b3IgPSAoaW5zdGFuY2UsIGlucHV0VmFsdWUsIHR5cGUpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGluc3RhbmNlLmRpc2FibGVJbnB1dCgpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Qcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhc1Byb21pc2UoaW5uZXJQYXJhbXMuaW5wdXRWYWxpZGF0b3IoaW5wdXRWYWx1ZSwgaW5uZXJQYXJhbXMudmFsaWRhdGlvbk1lc3NhZ2UpKSk7XG4gICAgdmFsaWRhdGlvblByb21pc2UudGhlbih2YWxpZGF0aW9uTWVzc2FnZSA9PiB7XG4gICAgICBpbnN0YW5jZS5lbmFibGVCdXR0b25zKCk7XG4gICAgICBpbnN0YW5jZS5lbmFibGVJbnB1dCgpO1xuICAgICAgaWYgKHZhbGlkYXRpb25NZXNzYWdlKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3dWYWxpZGF0aW9uTWVzc2FnZSh2YWxpZGF0aW9uTWVzc2FnZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdkZW55Jykge1xuICAgICAgICBkZW55KGluc3RhbmNlLCBpbnB1dFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbmZpcm0oaW5zdGFuY2UsIGlucHV0VmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnQyfSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAgICovXG4gIGNvbnN0IGRlbnkgPSAoaW5zdGFuY2UsIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCk7XG4gICAgaWYgKGlubmVyUGFyYW1zLnNob3dMb2FkZXJPbkRlbnkpIHtcbiAgICAgIHNob3dMb2FkaW5nKGdldERlbnlCdXR0b24oKSk7XG4gICAgfVxuICAgIGlmIChpbm5lclBhcmFtcy5wcmVEZW55KSB7XG4gICAgICBwcml2YXRlUHJvcHMuYXdhaXRpbmdQcm9taXNlLnNldChpbnN0YW5jZSB8fCB1bmRlZmluZWQsIHRydWUpOyAvLyBGbGFnZ2luZyB0aGUgaW5zdGFuY2UgYXMgYXdhaXRpbmcgYSBwcm9taXNlIHNvIGl0J3Mgb3duIHByb21pc2UncyByZWplY3QvcmVzb2x2ZSBtZXRob2RzIGRvZXNuJ3QgZ2V0IGRlc3Ryb3llZCB1bnRpbCB0aGUgcmVzdWx0IGZyb20gdGhpcyBwcmVEZW55J3MgcHJvbWlzZSBpcyByZWNlaXZlZFxuICAgICAgY29uc3QgcHJlRGVueVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IGFzUHJvbWlzZShpbm5lclBhcmFtcy5wcmVEZW55KHZhbHVlLCBpbm5lclBhcmFtcy52YWxpZGF0aW9uTWVzc2FnZSkpKTtcbiAgICAgIHByZURlbnlQcm9taXNlLnRoZW4ocHJlRGVueVZhbHVlID0+IHtcbiAgICAgICAgaWYgKHByZURlbnlWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5oaWRlTG9hZGluZygpO1xuICAgICAgICAgIGhhbmRsZUF3YWl0aW5nUHJvbWlzZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgICAgICAgICAgaXNEZW5pZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdHlwZW9mIHByZURlbnlWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZURlbnlWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnJvciA9PiByZWplY3RXaXRoKGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgZXJyb3IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UuY2xvc2Uoe1xuICAgICAgICBpc0RlbmllZDogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBjb25zdCBzdWNjZWVkV2l0aCA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBpbnN0YW5jZS5jbG9zZSh7XG4gICAgICBpc0NvbmZpcm1lZDogdHJ1ZSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlcnJvclxuICAgKi9cbiAgY29uc3QgcmVqZWN0V2l0aCA9IChpbnN0YW5jZSwgZXJyb3IpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW5zdGFuY2UucmVqZWN0UHJvbWlzZShlcnJvcik7XG4gIH07XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgY29uc3QgY29uZmlybSA9IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UgfHwgdW5kZWZpbmVkKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMuc2hvd0xvYWRlck9uQ29uZmlybSkge1xuICAgICAgc2hvd0xvYWRpbmcoKTtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLnByZUNvbmZpcm0pIHtcbiAgICAgIGluc3RhbmNlLnJlc2V0VmFsaWRhdGlvbk1lc3NhZ2UoKTtcbiAgICAgIHByaXZhdGVQcm9wcy5hd2FpdGluZ1Byb21pc2Uuc2V0KGluc3RhbmNlIHx8IHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIEZsYWdnaW5nIHRoZSBpbnN0YW5jZSBhcyBhd2FpdGluZyBhIHByb21pc2Ugc28gaXQncyBvd24gcHJvbWlzZSdzIHJlamVjdC9yZXNvbHZlIG1ldGhvZHMgZG9lc24ndCBnZXQgZGVzdHJveWVkIHVudGlsIHRoZSByZXN1bHQgZnJvbSB0aGlzIHByZUNvbmZpcm0ncyBwcm9taXNlIGlzIHJlY2VpdmVkXG4gICAgICBjb25zdCBwcmVDb25maXJtUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYXNQcm9taXNlKGlubmVyUGFyYW1zLnByZUNvbmZpcm0odmFsdWUsIGlubmVyUGFyYW1zLnZhbGlkYXRpb25NZXNzYWdlKSkpO1xuICAgICAgcHJlQ29uZmlybVByb21pc2UudGhlbihwcmVDb25maXJtVmFsdWUgPT4ge1xuICAgICAgICBpZiAoaXNWaXNpYmxlJDEoZ2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSkgfHwgcHJlQ29uZmlybVZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGVMb2FkaW5nKCk7XG4gICAgICAgICAgaGFuZGxlQXdhaXRpbmdQcm9taXNlKGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdHlwZW9mIHByZUNvbmZpcm1WYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyB2YWx1ZSA6IHByZUNvbmZpcm1WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pLmNhdGNoKGVycm9yID0+IHJlamVjdFdpdGgoaW5zdGFuY2UgfHwgdW5kZWZpbmVkLCBlcnJvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWNjZWVkV2l0aChpbnN0YW5jZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVQb3B1cENsaWNrID0gKGluc3RhbmNlLCBkb21DYWNoZSwgZGlzbWlzc1dpdGgpID0+IHtcbiAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgaGFuZGxlVG9hc3RDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWdub3JlIGNsaWNrIGV2ZW50cyB0aGF0IGhhZCBtb3VzZWRvd24gb24gdGhlIHBvcHVwIGJ1dCBtb3VzZXVwIG9uIHRoZSBjb250YWluZXJcbiAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSB1c2VyIGRyYWdzIGEgc2xpZGVyXG4gICAgICBoYW5kbGVNb2RhbE1vdXNlZG93bihkb21DYWNoZSk7XG5cbiAgICAgIC8vIElnbm9yZSBjbGljayBldmVudHMgdGhhdCBoYWQgbW91c2Vkb3duIG9uIHRoZSBjb250YWluZXIgYnV0IG1vdXNldXAgb24gdGhlIHBvcHVwXG4gICAgICBoYW5kbGVDb250YWluZXJNb3VzZWRvd24oZG9tQ2FjaGUpO1xuICAgICAgaGFuZGxlTW9kYWxDbGljayhpbnN0YW5jZSwgZG9tQ2FjaGUsIGRpc21pc3NXaXRoKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZVRvYXN0Q2xpY2sgPSAoaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIC8vIENsb3NpbmcgdG9hc3QgYnkgaW50ZXJuYWwgY2xpY2tcbiAgICBkb21DYWNoZS5wb3B1cC5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcml2YXRlUHJvcHMuaW5uZXJQYXJhbXMuZ2V0KGluc3RhbmNlKTtcbiAgICAgIGlmIChpbm5lclBhcmFtcyAmJiAoaXNBbnlCdXR0b25TaG93bihpbm5lclBhcmFtcykgfHwgaW5uZXJQYXJhbXMudGltZXIgfHwgaW5uZXJQYXJhbXMuaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2xvc2UpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5uZXJQYXJhbXNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBjb25zdCBpc0FueUJ1dHRvblNob3duID0gaW5uZXJQYXJhbXMgPT4ge1xuICAgIHJldHVybiBpbm5lclBhcmFtcy5zaG93Q29uZmlybUJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93RGVueUJ1dHRvbiB8fCBpbm5lclBhcmFtcy5zaG93Q2FuY2VsQnV0dG9uIHx8IGlubmVyUGFyYW1zLnNob3dDbG9zZUJ1dHRvbjtcbiAgfTtcbiAgbGV0IGlnbm9yZU91dHNpZGVDbGljayA9IGZhbHNlO1xuICBjb25zdCBoYW5kbGVNb2RhbE1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgICBkb21DYWNoZS5wb3B1cC5vbm1vdXNlZG93biA9ICgpID0+IHtcbiAgICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZXVwID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBXZSBvbmx5IGNoZWNrIGlmIHRoZSBtb3VzZXVwIHRhcmdldCBpcyB0aGUgY29udGFpbmVyIGJlY2F1c2UgdXN1YWxseSBpdCBkb2Vzbid0XG4gICAgICAgIC8vIGhhdmUgYW55IG90aGVyIGRpcmVjdCBjaGlsZHJlbiBhc2lkZSBvZiB0aGUgcG9wdXBcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIpIHtcbiAgICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNvbnRhaW5lck1vdXNlZG93biA9IGRvbUNhY2hlID0+IHtcbiAgICBkb21DYWNoZS5jb250YWluZXIub25tb3VzZWRvd24gPSAoKSA9PiB7XG4gICAgICBkb21DYWNoZS5wb3B1cC5vbm1vdXNldXAgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBkb21DYWNoZS5wb3B1cC5vbm1vdXNldXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBjaGVjayBpZiB0aGUgbW91c2V1cCB0YXJnZXQgaXMgYSBjaGlsZCBvZiB0aGUgcG9wdXBcbiAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5wb3B1cCB8fCBkb21DYWNoZS5wb3B1cC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH07XG4gIGNvbnN0IGhhbmRsZU1vZGFsQ2xpY2sgPSAoaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGRvbUNhY2hlLmNvbnRhaW5lci5vbmNsaWNrID0gZSA9PiB7XG4gICAgICBjb25zdCBpbm5lclBhcmFtcyA9IHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5nZXQoaW5zdGFuY2UpO1xuICAgICAgaWYgKGlnbm9yZU91dHNpZGVDbGljaykge1xuICAgICAgICBpZ25vcmVPdXRzaWRlQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGUudGFyZ2V0ID09PSBkb21DYWNoZS5jb250YWluZXIgJiYgY2FsbElmRnVuY3Rpb24oaW5uZXJQYXJhbXMuYWxsb3dPdXRzaWRlQ2xpY2spKSB7XG4gICAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uYmFja2Ryb3ApO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgY29uc3QgaXNKcXVlcnlFbGVtZW50ID0gZWxlbSA9PiB0eXBlb2YgZWxlbSA9PT0gJ29iamVjdCcgJiYgZWxlbS5qcXVlcnk7XG4gIGNvbnN0IGlzRWxlbWVudCA9IGVsZW0gPT4gZWxlbSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgaXNKcXVlcnlFbGVtZW50KGVsZW0pO1xuICBjb25zdCBhcmdzVG9QYXJhbXMgPSBhcmdzID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQoYXJnc1swXSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24ocGFyYW1zLCBhcmdzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgWyd0aXRsZScsICdodG1sJywgJ2ljb24nXS5mb3JFYWNoKChuYW1lLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IGlzRWxlbWVudChhcmcpKSB7XG4gICAgICAgICAgcGFyYW1zW25hbWVdID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSBvZiAke25hbWV9ISBFeHBlY3RlZCBcInN0cmluZ1wiIG9yIFwiRWxlbWVudFwiLCBnb3QgJHt0eXBlb2YgYXJnfWApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcblxuICBmdW5jdGlvbiBmaXJlKCkge1xuICAgIGNvbnN0IFN3YWwgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN3YWwoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHRlbmRlZCB2ZXJzaW9uIG9mIGBTd2FsYCBjb250YWluaW5nIGBwYXJhbXNgIGFzIGRlZmF1bHRzLlxuICAgKiBVc2VmdWwgZm9yIHJldXNpbmcgU3dhbCBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogQmVmb3JlOlxuICAgKiBjb25zdCB0ZXh0UHJvbXB0T3B0aW9ucyA9IHsgaW5wdXQ6ICd0ZXh0Jywgc2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSB9XG4gICAqIGNvbnN0IHt2YWx1ZTogZmlyc3ROYW1lfSA9IGF3YWl0IFN3YWwuZmlyZSh7IC4uLnRleHRQcm9tcHRPcHRpb25zLCB0aXRsZTogJ1doYXQgaXMgeW91ciBmaXJzdCBuYW1lPycgfSlcbiAgICogY29uc3Qge3ZhbHVlOiBsYXN0TmFtZX0gPSBhd2FpdCBTd2FsLmZpcmUoeyAuLi50ZXh0UHJvbXB0T3B0aW9ucywgdGl0bGU6ICdXaGF0IGlzIHlvdXIgbGFzdCBuYW1lPycgfSlcbiAgICpcbiAgICogQWZ0ZXI6XG4gICAqIGNvbnN0IFRleHRQcm9tcHQgPSBTd2FsLm1peGluKHsgaW5wdXQ6ICd0ZXh0Jywgc2hvd0NhbmNlbEJ1dHRvbjogdHJ1ZSB9KVxuICAgKiBjb25zdCB7dmFsdWU6IGZpcnN0TmFtZX0gPSBhd2FpdCBUZXh0UHJvbXB0KCdXaGF0IGlzIHlvdXIgZmlyc3QgbmFtZT8nKVxuICAgKiBjb25zdCB7dmFsdWU6IGxhc3ROYW1lfSA9IGF3YWl0IFRleHRQcm9tcHQoJ1doYXQgaXMgeW91ciBsYXN0IG5hbWU/JylcbiAgICpcbiAgICogQHBhcmFtIG1peGluUGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBtaXhpbihtaXhpblBhcmFtcykge1xuICAgIGNsYXNzIE1peGluU3dhbCBleHRlbmRzIHRoaXMge1xuICAgICAgX21haW4ocGFyYW1zLCBwcmlvcml0eU1peGluUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5fbWFpbihwYXJhbXMsIE9iamVjdC5hc3NpZ24oe30sIG1peGluUGFyYW1zLCBwcmlvcml0eU1peGluUGFyYW1zKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNaXhpblN3YWw7XG4gIH1cblxuICAvKipcbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXMgc2V0LCByZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gICAqIE90aGVyd2lzZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBnZXRUaW1lckxlZnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQgJiYgZ2xvYmFsU3RhdGUudGltZW91dC5nZXRUaW1lckxlZnQoKTtcbiAgfTtcblxuICAvKipcbiAgICogU3RvcCB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIHRpbWVyIHJlbWFpbmVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyIHwgdW5kZWZpbmVkfVxuICAgKi9cbiAgY29uc3Qgc3RvcFRpbWVyID0gKCkgPT4ge1xuICAgIGlmIChnbG9iYWxTdGF0ZS50aW1lb3V0KSB7XG4gICAgICBzdG9wVGltZXJQcm9ncmVzc0JhcigpO1xuICAgICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQuc3RvcCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzdW1lIHRpbWVyLiBSZXR1cm5zIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb2YgdGltZXIgcmVtYWluZWQuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCByZXN1bWVUaW1lciA9ICgpID0+IHtcbiAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCkge1xuICAgICAgY29uc3QgcmVtYWluaW5nID0gZ2xvYmFsU3RhdGUudGltZW91dC5zdGFydCgpO1xuICAgICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIocmVtYWluaW5nKTtcbiAgICAgIHJldHVybiByZW1haW5pbmc7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXN1bWUgdGltZXIuIFJldHVybnMgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBvZiB0aW1lciByZW1haW5lZC5cbiAgICogSWYgYHRpbWVyYCBwYXJhbWV0ZXIgaXNuJ3Qgc2V0LCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGNvbnN0IHRvZ2dsZVRpbWVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHRpbWVyID0gZ2xvYmFsU3RhdGUudGltZW91dDtcbiAgICByZXR1cm4gdGltZXIgJiYgKHRpbWVyLnJ1bm5pbmcgPyBzdG9wVGltZXIoKSA6IHJlc3VtZVRpbWVyKCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZWFzZSB0aW1lci4gUmV0dXJucyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIG9mIGFuIHVwZGF0ZWQgdGltZXIuXG4gICAqIElmIGB0aW1lcmAgcGFyYW1ldGVyIGlzbid0IHNldCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gICAqIEByZXR1cm5zIHtudW1iZXIgfCB1bmRlZmluZWR9XG4gICAqL1xuICBjb25zdCBpbmNyZWFzZVRpbWVyID0gbiA9PiB7XG4gICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgIGNvbnN0IHJlbWFpbmluZyA9IGdsb2JhbFN0YXRlLnRpbWVvdXQuaW5jcmVhc2Uobik7XG4gICAgICBhbmltYXRlVGltZXJQcm9ncmVzc0JhcihyZW1haW5pbmcsIHRydWUpO1xuICAgICAgcmV0dXJuIHJlbWFpbmluZztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRpbWVyIGlzIHJ1bm5pbmcuIFJldHVybnMgdHJ1ZSBpZiB0aW1lciBpcyBydW5uaW5nXG4gICAqIG9yIGZhbHNlIGlmIHRpbWVyIGlzIHBhdXNlZCBvciBzdG9wcGVkLlxuICAgKiBJZiBgdGltZXJgIHBhcmFtZXRlciBpc24ndCBzZXQsIHJldHVybnMgdW5kZWZpbmVkXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY29uc3QgaXNUaW1lclJ1bm5pbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGdsb2JhbFN0YXRlLnRpbWVvdXQgJiYgZ2xvYmFsU3RhdGUudGltZW91dC5pc1J1bm5pbmcoKTtcbiAgfTtcblxuICBsZXQgYm9keUNsaWNrTGlzdGVuZXJBZGRlZCA9IGZhbHNlO1xuICBjb25zdCBjbGlja0hhbmRsZXJzID0ge307XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQ2xpY2tIYW5kbGVyKCkge1xuICAgIGxldCBhdHRyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnZGF0YS1zd2FsLXRlbXBsYXRlJztcbiAgICBjbGlja0hhbmRsZXJzW2F0dHJdID0gdGhpcztcbiAgICBpZiAoIWJvZHlDbGlja0xpc3RlbmVyQWRkZWQpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBib2R5Q2xpY2tMaXN0ZW5lcik7XG4gICAgICBib2R5Q2xpY2tMaXN0ZW5lckFkZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYm9keUNsaWNrTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgZm9yIChsZXQgZWwgPSBldmVudC50YXJnZXQ7IGVsICYmIGVsICE9PSBkb2N1bWVudDsgZWwgPSBlbC5wYXJlbnROb2RlKSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgaW4gY2xpY2tIYW5kbGVycykge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgY2xpY2tIYW5kbGVyc1thdHRyXS5maXJlKHtcbiAgICAgICAgICAgIHRlbXBsYXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBzdGF0aWNNZXRob2RzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBpc1ZhbGlkUGFyYW1ldGVyOiBpc1ZhbGlkUGFyYW1ldGVyLFxuICAgIGlzVXBkYXRhYmxlUGFyYW1ldGVyOiBpc1VwZGF0YWJsZVBhcmFtZXRlcixcbiAgICBpc0RlcHJlY2F0ZWRQYXJhbWV0ZXI6IGlzRGVwcmVjYXRlZFBhcmFtZXRlcixcbiAgICBhcmdzVG9QYXJhbXM6IGFyZ3NUb1BhcmFtcyxcbiAgICBnZXRDb250YWluZXI6IGdldENvbnRhaW5lcixcbiAgICBnZXRQb3B1cDogZ2V0UG9wdXAsXG4gICAgZ2V0VGl0bGU6IGdldFRpdGxlLFxuICAgIGdldEh0bWxDb250YWluZXI6IGdldEh0bWxDb250YWluZXIsXG4gICAgZ2V0SW1hZ2U6IGdldEltYWdlLFxuICAgIGdldEljb246IGdldEljb24sXG4gICAgZ2V0SWNvbkNvbnRlbnQ6IGdldEljb25Db250ZW50LFxuICAgIGdldElucHV0TGFiZWw6IGdldElucHV0TGFiZWwsXG4gICAgZ2V0Q2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uLFxuICAgIGdldEFjdGlvbnM6IGdldEFjdGlvbnMsXG4gICAgZ2V0Q29uZmlybUJ1dHRvbjogZ2V0Q29uZmlybUJ1dHRvbixcbiAgICBnZXREZW55QnV0dG9uOiBnZXREZW55QnV0dG9uLFxuICAgIGdldENhbmNlbEJ1dHRvbjogZ2V0Q2FuY2VsQnV0dG9uLFxuICAgIGdldExvYWRlcjogZ2V0TG9hZGVyLFxuICAgIGdldEZvb3RlcjogZ2V0Rm9vdGVyLFxuICAgIGdldFRpbWVyUHJvZ3Jlc3NCYXI6IGdldFRpbWVyUHJvZ3Jlc3NCYXIsXG4gICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6IGdldEZvY3VzYWJsZUVsZW1lbnRzLFxuICAgIGdldFZhbGlkYXRpb25NZXNzYWdlOiBnZXRWYWxpZGF0aW9uTWVzc2FnZSxcbiAgICBnZXRQcm9ncmVzc1N0ZXBzOiBnZXRQcm9ncmVzc1N0ZXBzLFxuICAgIGlzTG9hZGluZzogaXNMb2FkaW5nLFxuICAgIGlzVmlzaWJsZTogaXNWaXNpYmxlLFxuICAgIGNsaWNrQ29uZmlybTogY2xpY2tDb25maXJtLFxuICAgIGNsaWNrRGVueTogY2xpY2tEZW55LFxuICAgIGNsaWNrQ2FuY2VsOiBjbGlja0NhbmNlbCxcbiAgICBmaXJlOiBmaXJlLFxuICAgIG1peGluOiBtaXhpbixcbiAgICBzaG93TG9hZGluZzogc2hvd0xvYWRpbmcsXG4gICAgZW5hYmxlTG9hZGluZzogc2hvd0xvYWRpbmcsXG4gICAgZ2V0VGltZXJMZWZ0OiBnZXRUaW1lckxlZnQsXG4gICAgc3RvcFRpbWVyOiBzdG9wVGltZXIsXG4gICAgcmVzdW1lVGltZXI6IHJlc3VtZVRpbWVyLFxuICAgIHRvZ2dsZVRpbWVyOiB0b2dnbGVUaW1lcixcbiAgICBpbmNyZWFzZVRpbWVyOiBpbmNyZWFzZVRpbWVyLFxuICAgIGlzVGltZXJSdW5uaW5nOiBpc1RpbWVyUnVubmluZyxcbiAgICBiaW5kQ2xpY2tIYW5kbGVyOiBiaW5kQ2xpY2tIYW5kbGVyXG4gIH0pO1xuXG4gIGNsYXNzIFRpbWVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBkZWxheSkge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgdGhpcy5yZW1haW5pbmcgPSBkZWxheTtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgIGlmICghdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuaWQgPSBzZXRUaW1lb3V0KHRoaXMuY2FsbGJhY2ssIHRoaXMucmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZztcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkKTtcbiAgICAgICAgdGhpcy5yZW1haW5pbmcgLT0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0ZWQuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgIH1cbiAgICBpbmNyZWFzZShuKSB7XG4gICAgICBjb25zdCBydW5uaW5nID0gdGhpcy5ydW5uaW5nO1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbWFpbmluZyArPSBuO1xuICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xuICAgIH1cbiAgICBnZXRUaW1lckxlZnQoKSB7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW1haW5pbmc7XG4gICAgfVxuICAgIGlzUnVubmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3dhbFN0cmluZ1BhcmFtcyA9IFsnc3dhbC10aXRsZScsICdzd2FsLWh0bWwnLCAnc3dhbC1mb290ZXInXTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFRlbXBsYXRlUGFyYW1zID0gcGFyYW1zID0+IHtcbiAgICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovXG4gICAgY29uc3QgdGVtcGxhdGUgPSB0eXBlb2YgcGFyYW1zLnRlbXBsYXRlID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRlbXBsYXRlKSA6IHBhcmFtcy50ZW1wbGF0ZTtcbiAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgICBjb25zdCB0ZW1wbGF0ZUNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIHNob3dXYXJuaW5nc0ZvckVsZW1lbnRzKHRlbXBsYXRlQ29udGVudCk7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihnZXRTd2FsUGFyYW1zKHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxGdW5jdGlvblBhcmFtcyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsQnV0dG9ucyh0ZW1wbGF0ZUNvbnRlbnQpLCBnZXRTd2FsSW1hZ2UodGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbEljb24odGVtcGxhdGVDb250ZW50KSwgZ2V0U3dhbElucHV0KHRlbXBsYXRlQ29udGVudCksIGdldFN3YWxTdHJpbmdQYXJhbXModGVtcGxhdGVDb250ZW50LCBzd2FsU3RyaW5nUGFyYW1zKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0U3dhbFBhcmFtcyA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICAgIGNvbnN0IHN3YWxQYXJhbXMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLXBhcmFtJykpO1xuICAgIHN3YWxQYXJhbXMuZm9yRWFjaChwYXJhbSA9PiB7XG4gICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKHBhcmFtLCBbJ25hbWUnLCAndmFsdWUnXSk7XG4gICAgICBjb25zdCBwYXJhbU5hbWUgPSBwYXJhbS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW0uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgaWYgKHR5cGVvZiBkZWZhdWx0UGFyYW1zW3BhcmFtTmFtZV0gPT09ICdib29sZWFuJykge1xuICAgICAgICByZXN1bHRbcGFyYW1OYW1lXSA9IHZhbHVlICE9PSAnZmFsc2UnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmYXVsdFBhcmFtc1twYXJhbU5hbWVdID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXN1bHRbcGFyYW1OYW1lXSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W3BhcmFtTmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBnZXRTd2FsRnVuY3Rpb25QYXJhbXMgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnRbXX0gKi9cbiAgICBjb25zdCBzd2FsRnVuY3Rpb25zID0gQXJyYXkuZnJvbSh0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3dhbC1mdW5jdGlvbi1wYXJhbScpKTtcbiAgICBzd2FsRnVuY3Rpb25zLmZvckVhY2gocGFyYW0gPT4ge1xuICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW0uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIHJlc3VsdFtwYXJhbU5hbWVdID0gbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHt2YWx1ZX1gKSgpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFN3YWxCdXR0b25zID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gICAgY29uc3Qgc3dhbEJ1dHRvbnMgPSBBcnJheS5mcm9tKHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzd2FsLWJ1dHRvbicpKTtcbiAgICBzd2FsQnV0dG9ucy5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGJ1dHRvbiwgWyd0eXBlJywgJ2NvbG9yJywgJ2FyaWEtbGFiZWwnXSk7XG4gICAgICBjb25zdCB0eXBlID0gYnV0dG9uLmdldEF0dHJpYnV0ZSgndHlwZScpO1xuICAgICAgcmVzdWx0W2Ake3R5cGV9QnV0dG9uVGV4dGBdID0gYnV0dG9uLmlubmVySFRNTDtcbiAgICAgIHJlc3VsdFtgc2hvdyR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHR5cGUpfUJ1dHRvbmBdID0gdHJ1ZTtcbiAgICAgIGlmIChidXR0b24uaGFzQXR0cmlidXRlKCdjb2xvcicpKSB7XG4gICAgICAgIHJlc3VsdFtgJHt0eXBlfUJ1dHRvbkNvbG9yYF0gPSBidXR0b24uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgfVxuICAgICAgaWYgKGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSkge1xuICAgICAgICByZXN1bHRbYCR7dHlwZX1CdXR0b25BcmlhTGFiZWxgXSA9IGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50RnJhZ21lbnR9IHRlbXBsYXRlQ29udGVudFxuICAgKiBAcmV0dXJucyB7U3dlZXRBbGVydE9wdGlvbnN9XG4gICAqL1xuICBjb25zdCBnZXRTd2FsSW1hZ2UgPSB0ZW1wbGF0ZUNvbnRlbnQgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgY29uc3QgaW1hZ2UgPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3dhbC1pbWFnZScpO1xuICAgIGlmIChpbWFnZSkge1xuICAgICAgc2hvd1dhcm5pbmdzRm9yQXR0cmlidXRlcyhpbWFnZSwgWydzcmMnLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2FsdCddKTtcbiAgICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ3NyYycpKSB7XG4gICAgICAgIHJlc3VsdC5pbWFnZVVybCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UuaGFzQXR0cmlidXRlKCd3aWR0aCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbWFnZVdpZHRoID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLmhhc0F0dHJpYnV0ZSgnaGVpZ2h0JykpIHtcbiAgICAgICAgcmVzdWx0LmltYWdlSGVpZ2h0ID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbWFnZS5oYXNBdHRyaWJ1dGUoJ2FsdCcpKSB7XG4gICAgICAgIHJlc3VsdC5pbWFnZUFsdCA9IGltYWdlLmdldEF0dHJpYnV0ZSgnYWx0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFN3YWxJY29uID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIGNvbnN0IGljb24gPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3dhbC1pY29uJyk7XG4gICAgaWYgKGljb24pIHtcbiAgICAgIHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMoaWNvbiwgWyd0eXBlJywgJ2NvbG9yJ10pO1xuICAgICAgaWYgKGljb24uaGFzQXR0cmlidXRlKCd0eXBlJykpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtTd2VldEFsZXJ0SWNvbn0gKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXN1bHQuaWNvbiA9IGljb24uZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoaWNvbi5oYXNBdHRyaWJ1dGUoJ2NvbG9yJykpIHtcbiAgICAgICAgcmVzdWx0Lmljb25Db2xvciA9IGljb24uZ2V0QXR0cmlidXRlKCdjb2xvcicpO1xuICAgICAgfVxuICAgICAgcmVzdWx0Lmljb25IdG1sID0gaWNvbi5pbm5lckhUTUw7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEByZXR1cm5zIHtTd2VldEFsZXJ0T3B0aW9uc31cbiAgICovXG4gIGNvbnN0IGdldFN3YWxJbnB1dCA9IHRlbXBsYXRlQ29udGVudCA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBjb25zdCBpbnB1dCA9IHRlbXBsYXRlQ29udGVudC5xdWVyeVNlbGVjdG9yKCdzd2FsLWlucHV0Jyk7XG4gICAgaWYgKGlucHV0KSB7XG4gICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKGlucHV0LCBbJ3R5cGUnLCAnbGFiZWwnLCAncGxhY2Vob2xkZXInLCAndmFsdWUnXSk7XG4gICAgICAvKiogQHR5cGUge1N3ZWV0QWxlcnRJbnB1dH0gKi9cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlc3VsdC5pbnB1dCA9IGlucHV0LmdldEF0dHJpYnV0ZSgndHlwZScpIHx8ICd0ZXh0JztcbiAgICAgIGlmIChpbnB1dC5oYXNBdHRyaWJ1dGUoJ2xhYmVsJykpIHtcbiAgICAgICAgcmVzdWx0LmlucHV0TGFiZWwgPSBpbnB1dC5nZXRBdHRyaWJ1dGUoJ2xhYmVsJyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQuaGFzQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpKSB7XG4gICAgICAgIHJlc3VsdC5pbnB1dFBsYWNlaG9sZGVyID0gaW5wdXQuZ2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0Lmhhc0F0dHJpYnV0ZSgndmFsdWUnKSkge1xuICAgICAgICByZXN1bHQuaW5wdXRWYWx1ZSA9IGlucHV0LmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudFtdfSAqL1xuICAgIGNvbnN0IGlucHV0T3B0aW9ucyA9IEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N3YWwtaW5wdXQtb3B0aW9uJykpO1xuICAgIGlmIChpbnB1dE9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQuaW5wdXRPcHRpb25zID0ge307XG4gICAgICBpbnB1dE9wdGlvbnMuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKG9wdGlvbiwgWyd2YWx1ZSddKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgICBjb25zdCBvcHRpb25OYW1lID0gb3B0aW9uLmlubmVySFRNTDtcbiAgICAgICAgcmVzdWx0LmlucHV0T3B0aW9uc1tvcHRpb25WYWx1ZV0gPSBvcHRpb25OYW1lO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnRGcmFnbWVudH0gdGVtcGxhdGVDb250ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtTmFtZXNcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgZ2V0U3dhbFN0cmluZ1BhcmFtcyA9ICh0ZW1wbGF0ZUNvbnRlbnQsIHBhcmFtTmFtZXMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gcGFyYW1OYW1lcykge1xuICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFyYW1OYW1lc1tpXTtcbiAgICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgICBjb25zdCB0YWcgPSB0ZW1wbGF0ZUNvbnRlbnQucXVlcnlTZWxlY3RvcihwYXJhbU5hbWUpO1xuICAgICAgaWYgKHRhZykge1xuICAgICAgICBzaG93V2FybmluZ3NGb3JBdHRyaWJ1dGVzKHRhZywgW10pO1xuICAgICAgICByZXN1bHRbcGFyYW1OYW1lLnJlcGxhY2UoL15zd2FsLS8sICcnKV0gPSB0YWcuaW5uZXJIVE1MLnRyaW0oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSB0ZW1wbGF0ZUNvbnRlbnRcbiAgICovXG4gIGNvbnN0IHNob3dXYXJuaW5nc0ZvckVsZW1lbnRzID0gdGVtcGxhdGVDb250ZW50ID0+IHtcbiAgICBjb25zdCBhbGxvd2VkRWxlbWVudHMgPSBzd2FsU3RyaW5nUGFyYW1zLmNvbmNhdChbJ3N3YWwtcGFyYW0nLCAnc3dhbC1mdW5jdGlvbi1wYXJhbScsICdzd2FsLWJ1dHRvbicsICdzd2FsLWltYWdlJywgJ3N3YWwtaWNvbicsICdzd2FsLWlucHV0JywgJ3N3YWwtaW5wdXQtb3B0aW9uJ10pO1xuICAgIEFycmF5LmZyb20odGVtcGxhdGVDb250ZW50LmNoaWxkcmVuKS5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGNvbnN0IHRhZ05hbWUgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAoIWFsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyh0YWdOYW1lKSkge1xuICAgICAgICB3YXJuKGBVbnJlY29nbml6ZWQgZWxlbWVudCA8JHt0YWdOYW1lfT5gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWxsb3dlZEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0IHNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMgPSAoZWwsIGFsbG93ZWRBdHRyaWJ1dGVzKSA9PiB7XG4gICAgQXJyYXkuZnJvbShlbC5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZXMuaW5kZXhPZihhdHRyaWJ1dGUubmFtZSkgPT09IC0xKSB7XG4gICAgICAgIHdhcm4oW2BVbnJlY29nbml6ZWQgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGUubmFtZX1cIiBvbiA8JHtlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCl9Pi5gLCBgJHthbGxvd2VkQXR0cmlidXRlcy5sZW5ndGggPyBgQWxsb3dlZCBhdHRyaWJ1dGVzIGFyZTogJHthbGxvd2VkQXR0cmlidXRlcy5qb2luKCcsICcpfWAgOiAnVG8gc2V0IHRoZSB2YWx1ZSwgdXNlIEhUTUwgd2l0aGluIHRoZSBlbGVtZW50Lid9YF0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IFNIT1dfQ0xBU1NfVElNRU9VVCA9IDEwO1xuXG4gIC8qKlxuICAgKiBPcGVuIHBvcHVwLCBhZGQgbmVjZXNzYXJ5IGNsYXNzZXMgYW5kIHN0eWxlcywgZml4IHNjcm9sbGJhclxuICAgKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IG9wZW5Qb3B1cCA9IHBhcmFtcyA9PiB7XG4gICAgY29uc3QgY29udGFpbmVyID0gZ2V0Q29udGFpbmVyKCk7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLndpbGxPcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwYXJhbXMud2lsbE9wZW4ocG9wdXApO1xuICAgIH1cbiAgICBjb25zdCBib2R5U3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSk7XG4gICAgY29uc3QgaW5pdGlhbEJvZHlPdmVyZmxvdyA9IGJvZHlTdHlsZXMub3ZlcmZsb3dZO1xuICAgIGFkZENsYXNzZXMoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKTtcblxuICAgIC8vIHNjcm9sbGluZyBpcyAnaGlkZGVuJyB1bnRpbCBhbmltYXRpb24gaXMgZG9uZSwgYWZ0ZXIgdGhhdCAnYXV0bydcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFNjcm9sbGluZ1Zpc2liaWxpdHkoY29udGFpbmVyLCBwb3B1cCk7XG4gICAgfSwgU0hPV19DTEFTU19USU1FT1VUKTtcbiAgICBpZiAoaXNNb2RhbCgpKSB7XG4gICAgICBmaXhTY3JvbGxDb250YWluZXIoY29udGFpbmVyLCBwYXJhbXMuc2Nyb2xsYmFyUGFkZGluZywgaW5pdGlhbEJvZHlPdmVyZmxvdyk7XG4gICAgICBzZXRBcmlhSGlkZGVuKCk7XG4gICAgfVxuICAgIGlmICghaXNUb2FzdCgpICYmICFnbG9iYWxTdGF0ZS5wcmV2aW91c0FjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFyYW1zLmRpZE9wZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcGFyYW1zLmRpZE9wZW4ocG9wdXApKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoY29udGFpbmVyLCBzd2FsQ2xhc3Nlc1snbm8tdHJhbnNpdGlvbiddKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtBbmltYXRpb25FdmVudH0gZXZlbnRcbiAgICovXG4gIGNvbnN0IHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQgPSBldmVudCA9PiB7XG4gICAgY29uc3QgcG9wdXAgPSBnZXRQb3B1cCgpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHBvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGdldENvbnRhaW5lcigpO1xuICAgIHBvcHVwLnJlbW92ZUV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uRW5kRXZlbnQsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnYXV0byc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgKi9cbiAgY29uc3Qgc2V0U2Nyb2xsaW5nVmlzaWJpbGl0eSA9IChjb250YWluZXIsIHBvcHVwKSA9PiB7XG4gICAgaWYgKGFuaW1hdGlvbkVuZEV2ZW50ICYmIGhhc0Nzc0FuaW1hdGlvbihwb3B1cCkpIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgIHBvcHVwLmFkZEV2ZW50TGlzdGVuZXIoYW5pbWF0aW9uRW5kRXZlbnQsIHN3YWxPcGVuQW5pbWF0aW9uRmluaXNoZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2F1dG8nO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2Nyb2xsYmFyUGFkZGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5pdGlhbEJvZHlPdmVyZmxvd1xuICAgKi9cbiAgY29uc3QgZml4U2Nyb2xsQ29udGFpbmVyID0gKGNvbnRhaW5lciwgc2Nyb2xsYmFyUGFkZGluZywgaW5pdGlhbEJvZHlPdmVyZmxvdykgPT4ge1xuICAgIGlPU2ZpeCgpO1xuICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nICYmIGluaXRpYWxCb2R5T3ZlcmZsb3cgIT09ICdoaWRkZW4nKSB7XG4gICAgICBmaXhTY3JvbGxiYXIoKTtcbiAgICB9XG5cbiAgICAvLyBzd2VldGFsZXJ0Mi9pc3N1ZXMvMTI0N1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3B1cFxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGNvbnN0IGFkZENsYXNzZXMgPSAoY29udGFpbmVyLCBwb3B1cCwgcGFyYW1zKSA9PiB7XG4gICAgYWRkQ2xhc3MoY29udGFpbmVyLCBwYXJhbXMuc2hvd0NsYXNzLmJhY2tkcm9wKTtcbiAgICAvLyB0aGlzIHdvcmthcm91bmQgd2l0aCBvcGFjaXR5IGlzIG5lZWRlZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N3ZWV0YWxlcnQyL3N3ZWV0YWxlcnQyL2lzc3Vlcy8yMDU5XG4gICAgcG9wdXAuc3R5bGUuc2V0UHJvcGVydHkoJ29wYWNpdHknLCAnMCcsICdpbXBvcnRhbnQnKTtcbiAgICBzaG93KHBvcHVwLCAnZ3JpZCcpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gQW5pbWF0ZSBwb3B1cCByaWdodCBhZnRlciBzaG93aW5nIGl0XG4gICAgICBhZGRDbGFzcyhwb3B1cCwgcGFyYW1zLnNob3dDbGFzcy5wb3B1cCk7XG4gICAgICAvLyBhbmQgcmVtb3ZlIHRoZSBvcGFjaXR5IHdvcmthcm91bmRcbiAgICAgIHBvcHVwLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdvcGFjaXR5Jyk7XG4gICAgfSwgU0hPV19DTEFTU19USU1FT1VUKTsgLy8gMTBtcyBpbiBvcmRlciB0byBmaXggIzIwNjJcblxuICAgIGFkZENsYXNzKFtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGRvY3VtZW50LmJvZHldLCBzd2FsQ2xhc3Nlcy5zaG93bik7XG4gICAgaWYgKHBhcmFtcy5oZWlnaHRBdXRvICYmIHBhcmFtcy5iYWNrZHJvcCAmJiAhcGFyYW1zLnRvYXN0KSB7XG4gICAgICBhZGRDbGFzcyhbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBkb2N1bWVudC5ib2R5XSwgc3dhbENsYXNzZXNbJ2hlaWdodC1hdXRvJ10pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZGVmYXVsdElucHV0VmFsaWRhdG9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbGlkYXRpb25NZXNzYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZCB8IHN0cmluZz59XG4gICAgICovXG4gICAgZW1haWw6IChzdHJpbmcsIHZhbGlkYXRpb25NZXNzYWdlKSA9PiB7XG4gICAgICByZXR1cm4gL15bYS16QS1aMC05LitfLV0rQFthLXpBLVowLTkuLV0rXFwuW2EtekEtWjAtOS1dezIsMjR9JC8udGVzdChzdHJpbmcpID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBQcm9taXNlLnJlc29sdmUodmFsaWRhdGlvbk1lc3NhZ2UgfHwgJ0ludmFsaWQgZW1haWwgYWRkcmVzcycpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0aW9uTWVzc2FnZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQgfCBzdHJpbmc+fVxuICAgICAqL1xuICAgIHVybDogKHN0cmluZywgdmFsaWRhdGlvbk1lc3NhZ2UpID0+IHtcbiAgICAgIC8vIHRha2VuIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM4MDk0MzUgd2l0aCBhIHNtYWxsIGNoYW5nZSBmcm9tICMxMzA2IGFuZCAjMjAxM1xuICAgICAgcmV0dXJuIC9eaHR0cHM/OlxcL1xcLyh3d3dcXC4pP1stYS16QS1aMC05QDolLl8rfiM9XXsxLDI1Nn1cXC5bYS16XXsyLDYzfVxcYihbLWEtekEtWjAtOUA6JV8rLn4jPyYvPV0qKSQvLnRlc3Qoc3RyaW5nKSA/IFByb21pc2UucmVzb2x2ZSgpIDogUHJvbWlzZS5yZXNvbHZlKHZhbGlkYXRpb25NZXNzYWdlIHx8ICdJbnZhbGlkIFVSTCcpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBzZXREZWZhdWx0SW5wdXRWYWxpZGF0b3JzKHBhcmFtcykge1xuICAgIC8vIFVzZSBkZWZhdWx0IGBpbnB1dFZhbGlkYXRvcmAgZm9yIHN1cHBvcnRlZCBpbnB1dCB0eXBlcyBpZiBub3QgcHJvdmlkZWRcbiAgICBpZiAoIXBhcmFtcy5pbnB1dFZhbGlkYXRvcikge1xuICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdElucHV0VmFsaWRhdG9ycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAocGFyYW1zLmlucHV0ID09PSBrZXkpIHtcbiAgICAgICAgICBwYXJhbXMuaW5wdXRWYWxpZGF0b3IgPSBkZWZhdWx0SW5wdXRWYWxpZGF0b3JzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBwYXJhbXNcbiAgICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ3VzdG9tVGFyZ2V0RWxlbWVudChwYXJhbXMpIHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGN1c3RvbSB0YXJnZXQgZWxlbWVudCBpcyB2YWxpZFxuICAgIGlmICghcGFyYW1zLnRhcmdldCB8fCB0eXBlb2YgcGFyYW1zLnRhcmdldCA9PT0gJ3N0cmluZycgJiYgIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IocGFyYW1zLnRhcmdldCkgfHwgdHlwZW9mIHBhcmFtcy50YXJnZXQgIT09ICdzdHJpbmcnICYmICFwYXJhbXMudGFyZ2V0LmFwcGVuZENoaWxkKSB7XG4gICAgICB3YXJuKCdUYXJnZXQgcGFyYW1ldGVyIGlzIG5vdCB2YWxpZCwgZGVmYXVsdGluZyB0byBcImJvZHlcIicpO1xuICAgICAgcGFyYW1zLnRhcmdldCA9ICdib2R5JztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHR5cGUsIHRleHQgYW5kIGFjdGlvbnMgb24gcG9wdXBcbiAgICpcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gcGFyYW1zXG4gICAqL1xuICBmdW5jdGlvbiBzZXRQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIHNldERlZmF1bHRJbnB1dFZhbGlkYXRvcnMocGFyYW1zKTtcblxuICAgIC8vIHNob3dMb2FkZXJPbkNvbmZpcm0gJiYgcHJlQ29uZmlybVxuICAgIGlmIChwYXJhbXMuc2hvd0xvYWRlck9uQ29uZmlybSAmJiAhcGFyYW1zLnByZUNvbmZpcm0pIHtcbiAgICAgIHdhcm4oJ3Nob3dMb2FkZXJPbkNvbmZpcm0gaXMgc2V0IHRvIHRydWUsIGJ1dCBwcmVDb25maXJtIGlzIG5vdCBkZWZpbmVkLlxcbicgKyAnc2hvd0xvYWRlck9uQ29uZmlybSBzaG91bGQgYmUgdXNlZCB0b2dldGhlciB3aXRoIHByZUNvbmZpcm0sIHNlZSB1c2FnZSBleGFtcGxlOlxcbicgKyAnaHR0cHM6Ly9zd2VldGFsZXJ0Mi5naXRodWIuaW8vI2FqYXgtcmVxdWVzdCcpO1xuICAgIH1cbiAgICB2YWxpZGF0ZUN1c3RvbVRhcmdldEVsZW1lbnQocGFyYW1zKTtcblxuICAgIC8vIFJlcGxhY2UgbmV3bGluZXMgd2l0aCA8YnI+IGluIHRpdGxlXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMudGl0bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwYXJhbXMudGl0bGUgPSBwYXJhbXMudGl0bGUuc3BsaXQoJ1xcbicpLmpvaW4oJzxiciAvPicpO1xuICAgIH1cbiAgICBpbml0KHBhcmFtcyk7XG4gIH1cblxuICBsZXQgY3VycmVudEluc3RhbmNlO1xuICBjbGFzcyBTd2VldEFsZXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIC8vIFByZXZlbnQgcnVuIGluIE5vZGUgZW52XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3VycmVudEluc3RhbmNlID0gdGhpcztcblxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRlclBhcmFtcyA9IE9iamVjdC5mcmVlemUodGhpcy5jb25zdHJ1Y3Rvci5hcmdzVG9QYXJhbXMoYXJncykpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICB2YWx1ZTogb3V0ZXJQYXJhbXMsXG4gICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBwcm9taXNlID0gY3VycmVudEluc3RhbmNlLl9tYWluKGN1cnJlbnRJbnN0YW5jZS5wYXJhbXMpO1xuICAgICAgcHJpdmF0ZVByb3BzLnByb21pc2Uuc2V0KHRoaXMsIHByb21pc2UpO1xuICAgIH1cbiAgICBfbWFpbih1c2VyUGFyYW1zKSB7XG4gICAgICBsZXQgbWl4aW5QYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgc2hvd1dhcm5pbmdzRm9yUGFyYW1zKE9iamVjdC5hc3NpZ24oe30sIG1peGluUGFyYW1zLCB1c2VyUGFyYW1zKSk7XG4gICAgICBpZiAoZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlLl9kZXN0cm95KCk7XG4gICAgICAgIGlmIChpc01vZGFsKCkpIHtcbiAgICAgICAgICB1bnNldEFyaWFIaWRkZW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZ2xvYmFsU3RhdGUuY3VycmVudEluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgY29uc3QgaW5uZXJQYXJhbXMgPSBwcmVwYXJlUGFyYW1zKHVzZXJQYXJhbXMsIG1peGluUGFyYW1zKTtcbiAgICAgIHNldFBhcmFtZXRlcnMoaW5uZXJQYXJhbXMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShpbm5lclBhcmFtcyk7XG5cbiAgICAgIC8vIGNsZWFyIHRoZSBwcmV2aW91cyB0aW1lclxuICAgICAgaWYgKGdsb2JhbFN0YXRlLnRpbWVvdXQpIHtcbiAgICAgICAgZ2xvYmFsU3RhdGUudGltZW91dC5zdG9wKCk7XG4gICAgICAgIGRlbGV0ZSBnbG9iYWxTdGF0ZS50aW1lb3V0O1xuICAgICAgfVxuXG4gICAgICAvLyBjbGVhciB0aGUgcmVzdG9yZSBmb2N1cyB0aW1lb3V0XG4gICAgICBjbGVhclRpbWVvdXQoZ2xvYmFsU3RhdGUucmVzdG9yZUZvY3VzVGltZW91dCk7XG4gICAgICBjb25zdCBkb21DYWNoZSA9IHBvcHVsYXRlRG9tQ2FjaGUoY3VycmVudEluc3RhbmNlKTtcbiAgICAgIHJlbmRlcihjdXJyZW50SW5zdGFuY2UsIGlubmVyUGFyYW1zKTtcbiAgICAgIHByaXZhdGVQcm9wcy5pbm5lclBhcmFtcy5zZXQoY3VycmVudEluc3RhbmNlLCBpbm5lclBhcmFtcyk7XG4gICAgICByZXR1cm4gc3dhbFByb21pc2UoY3VycmVudEluc3RhbmNlLCBkb21DYWNoZSwgaW5uZXJQYXJhbXMpO1xuICAgIH1cblxuICAgIC8vIGBjYXRjaGAgY2Fubm90IGJlIHRoZSBuYW1lIG9mIGEgbW9kdWxlIGV4cG9ydCwgc28gd2UgZGVmaW5lIG91ciB0aGVuYWJsZSBtZXRob2RzIGhlcmUgaW5zdGVhZFxuICAgIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBwcml2YXRlUHJvcHMucHJvbWlzZS5nZXQodGhpcyk7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKG9uRnVsZmlsbGVkKTtcbiAgICB9XG4gICAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgIGNvbnN0IHByb21pc2UgPSBwcml2YXRlUHJvcHMucHJvbWlzZS5nZXQodGhpcyk7XG4gICAgICByZXR1cm4gcHJvbWlzZS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydDJ9IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7RG9tQ2FjaGV9IGRvbUNhY2hlXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IGlubmVyUGFyYW1zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY29uc3Qgc3dhbFByb21pc2UgPSAoaW5zdGFuY2UsIGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBmdW5jdGlvbnMgdG8gaGFuZGxlIGFsbCBjbG9zaW5ncy9kaXNtaXNzYWxzXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7RGlzbWlzc1JlYXNvbn0gZGlzbWlzc1xuICAgICAgICovXG4gICAgICBjb25zdCBkaXNtaXNzV2l0aCA9IGRpc21pc3MgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGluc3RhbmNlLmNsb3NlKHtcbiAgICAgICAgICBpc0Rpc21pc3NlZDogdHJ1ZSxcbiAgICAgICAgICBkaXNtaXNzXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHByaXZhdGVNZXRob2RzLnN3YWxQcm9taXNlUmVzb2x2ZS5zZXQoaW5zdGFuY2UsIHJlc29sdmUpO1xuICAgICAgcHJpdmF0ZU1ldGhvZHMuc3dhbFByb21pc2VSZWplY3Quc2V0KGluc3RhbmNlLCByZWplY3QpO1xuICAgICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICBoYW5kbGVDb25maXJtQnV0dG9uQ2xpY2soaW5zdGFuY2UpO1xuICAgICAgfTtcbiAgICAgIGRvbUNhY2hlLmRlbnlCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgaGFuZGxlRGVueUJ1dHRvbkNsaWNrKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgICBkb21DYWNoZS5jYW5jZWxCdXR0b24ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgaGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2soaW5zdGFuY2UsIGRpc21pc3NXaXRoKTtcbiAgICAgIH07XG4gICAgICBkb21DYWNoZS5jbG9zZUJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRpc21pc3NXaXRoKERpc21pc3NSZWFzb24uY2xvc2UpO1xuICAgICAgfTtcbiAgICAgIGhhbmRsZVBvcHVwQ2xpY2soaW5zdGFuY2UsIGRvbUNhY2hlLCBkaXNtaXNzV2l0aCk7XG4gICAgICBhZGRLZXlkb3duSGFuZGxlcihpbnN0YW5jZSwgZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgICBoYW5kbGVJbnB1dE9wdGlvbnNBbmRWYWx1ZShpbnN0YW5jZSwgaW5uZXJQYXJhbXMpO1xuICAgICAgb3BlblBvcHVwKGlubmVyUGFyYW1zKTtcbiAgICAgIHNldHVwVGltZXIoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCk7XG4gICAgICBpbml0Rm9jdXMoZG9tQ2FjaGUsIGlubmVyUGFyYW1zKTtcblxuICAgICAgLy8gU2Nyb2xsIGNvbnRhaW5lciB0byB0b3Agb24gb3BlbiAoIzEyNDcsICMxOTQ2KVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRvbUNhY2hlLmNvbnRhaW5lci5zY3JvbGxUb3AgPSAwO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3dlZXRBbGVydE9wdGlvbnN9IHVzZXJQYXJhbXNcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gbWl4aW5QYXJhbXNcbiAgICogQHJldHVybnMge1N3ZWV0QWxlcnRPcHRpb25zfVxuICAgKi9cbiAgY29uc3QgcHJlcGFyZVBhcmFtcyA9ICh1c2VyUGFyYW1zLCBtaXhpblBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlUGFyYW1zID0gZ2V0VGVtcGxhdGVQYXJhbXModXNlclBhcmFtcyk7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcywgbWl4aW5QYXJhbXMsIHRlbXBsYXRlUGFyYW1zLCB1c2VyUGFyYW1zKTsgLy8gcHJlY2VkZW5jZSBpcyBkZXNjcmliZWQgaW4gIzIxMzFcbiAgICBwYXJhbXMuc2hvd0NsYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcmFtcy5zaG93Q2xhc3MsIHBhcmFtcy5zaG93Q2xhc3MpO1xuICAgIHBhcmFtcy5oaWRlQ2xhc3MgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyYW1zLmhpZGVDbGFzcywgcGFyYW1zLmhpZGVDbGFzcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0Mn0gaW5zdGFuY2VcbiAgICogQHJldHVybnMge0RvbUNhY2hlfVxuICAgKi9cbiAgY29uc3QgcG9wdWxhdGVEb21DYWNoZSA9IGluc3RhbmNlID0+IHtcbiAgICBjb25zdCBkb21DYWNoZSA9IHtcbiAgICAgIHBvcHVwOiBnZXRQb3B1cCgpLFxuICAgICAgY29udGFpbmVyOiBnZXRDb250YWluZXIoKSxcbiAgICAgIGFjdGlvbnM6IGdldEFjdGlvbnMoKSxcbiAgICAgIGNvbmZpcm1CdXR0b246IGdldENvbmZpcm1CdXR0b24oKSxcbiAgICAgIGRlbnlCdXR0b246IGdldERlbnlCdXR0b24oKSxcbiAgICAgIGNhbmNlbEJ1dHRvbjogZ2V0Q2FuY2VsQnV0dG9uKCksXG4gICAgICBsb2FkZXI6IGdldExvYWRlcigpLFxuICAgICAgY2xvc2VCdXR0b246IGdldENsb3NlQnV0dG9uKCksXG4gICAgICB2YWxpZGF0aW9uTWVzc2FnZTogZ2V0VmFsaWRhdGlvbk1lc3NhZ2UoKSxcbiAgICAgIHByb2dyZXNzU3RlcHM6IGdldFByb2dyZXNzU3RlcHMoKVxuICAgIH07XG4gICAgcHJpdmF0ZVByb3BzLmRvbUNhY2hlLnNldChpbnN0YW5jZSwgZG9tQ2FjaGUpO1xuICAgIHJldHVybiBkb21DYWNoZTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtHbG9iYWxTdGF0ZX0gZ2xvYmFsU3RhdGVcbiAgICogQHBhcmFtIHtTd2VldEFsZXJ0T3B0aW9uc30gaW5uZXJQYXJhbXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzbWlzc1dpdGhcbiAgICovXG4gIGNvbnN0IHNldHVwVGltZXIgPSAoZ2xvYmFsU3RhdGUsIGlubmVyUGFyYW1zLCBkaXNtaXNzV2l0aCkgPT4ge1xuICAgIGNvbnN0IHRpbWVyUHJvZ3Jlc3NCYXIgPSBnZXRUaW1lclByb2dyZXNzQmFyKCk7XG4gICAgaGlkZSh0aW1lclByb2dyZXNzQmFyKTtcbiAgICBpZiAoaW5uZXJQYXJhbXMudGltZXIpIHtcbiAgICAgIGdsb2JhbFN0YXRlLnRpbWVvdXQgPSBuZXcgVGltZXIoKCkgPT4ge1xuICAgICAgICBkaXNtaXNzV2l0aCgndGltZXInKTtcbiAgICAgICAgZGVsZXRlIGdsb2JhbFN0YXRlLnRpbWVvdXQ7XG4gICAgICB9LCBpbm5lclBhcmFtcy50aW1lcik7XG4gICAgICBpZiAoaW5uZXJQYXJhbXMudGltZXJQcm9ncmVzc0Jhcikge1xuICAgICAgICBzaG93KHRpbWVyUHJvZ3Jlc3NCYXIpO1xuICAgICAgICBhcHBseUN1c3RvbUNsYXNzKHRpbWVyUHJvZ3Jlc3NCYXIsIGlubmVyUGFyYW1zLCAndGltZXJQcm9ncmVzc0JhcicpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoZ2xvYmFsU3RhdGUudGltZW91dCAmJiBnbG9iYWxTdGF0ZS50aW1lb3V0LnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIC8vIHRpbWVyIGNhbiBiZSBhbHJlYWR5IHN0b3BwZWQgb3IgdW5zZXQgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgYW5pbWF0ZVRpbWVyUHJvZ3Jlc3NCYXIoaW5uZXJQYXJhbXMudGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKi9cbiAgY29uc3QgaW5pdEZvY3VzID0gKGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGlmIChpbm5lclBhcmFtcy50b2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbGxJZkZ1bmN0aW9uKGlubmVyUGFyYW1zLmFsbG93RW50ZXJLZXkpKSB7XG4gICAgICBibHVyQWN0aXZlRWxlbWVudCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZvY3VzQnV0dG9uKGRvbUNhY2hlLCBpbm5lclBhcmFtcykpIHtcbiAgICAgIHNldEZvY3VzKGlubmVyUGFyYW1zLCAtMSwgMSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvbUNhY2hlfSBkb21DYWNoZVxuICAgKiBAcGFyYW0ge1N3ZWV0QWxlcnRPcHRpb25zfSBpbm5lclBhcmFtc1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNvbnN0IGZvY3VzQnV0dG9uID0gKGRvbUNhY2hlLCBpbm5lclBhcmFtcykgPT4ge1xuICAgIGlmIChpbm5lclBhcmFtcy5mb2N1c0RlbnkgJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuZGVueUJ1dHRvbikpIHtcbiAgICAgIGRvbUNhY2hlLmRlbnlCdXR0b24uZm9jdXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW5uZXJQYXJhbXMuZm9jdXNDYW5jZWwgJiYgaXNWaXNpYmxlJDEoZG9tQ2FjaGUuY2FuY2VsQnV0dG9uKSkge1xuICAgICAgZG9tQ2FjaGUuY2FuY2VsQnV0dG9uLmZvY3VzKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlubmVyUGFyYW1zLmZvY3VzQ29uZmlybSAmJiBpc1Zpc2libGUkMShkb21DYWNoZS5jb25maXJtQnV0dG9uKSkge1xuICAgICAgZG9tQ2FjaGUuY29uZmlybUJ1dHRvbi5mb2N1cygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3QgYmx1ckFjdGl2ZUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiB0eXBlb2YgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRGVhciBydXNzaWFuIHVzZXJzIHZpc2l0aW5nIHJ1c3NpYW4gc2l0ZXMuIExldCdzIGhhdmUgZnVuLlxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL15ydVxcYi8udGVzdChuYXZpZ2F0b3IubGFuZ3VhZ2UpICYmIGxvY2F0aW9uLmhvc3QubWF0Y2goL1xcLihydXxzdXx4bi0tcDFhaSkkLykpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IGluaXRpYXRpb25EYXRlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3N3YWwtaW5pdGlhdGlvbicpO1xuICAgIGlmICghaW5pdGlhdGlvbkRhdGUpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdzd2FsLWluaXRpYXRpb24nLCBgJHtub3d9YCk7XG4gICAgfSBlbHNlIGlmICgobm93LmdldFRpbWUoKSAtIERhdGUucGFyc2UoaW5pdGlhdGlvbkRhdGUpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KSA+IDMpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIGNvbnN0IHVrcmFpbmlhbkFudGhlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgIHVrcmFpbmlhbkFudGhlbS5zcmMgPSAnaHR0cHM6Ly9mbGFnLWdpbW4ucnUvd3AtY29udGVudC91cGxvYWRzLzIwMjEvMDkvVWtyYWluYS5tcDMnO1xuICAgICAgICB1a3JhaW5pYW5BbnRoZW0ubG9vcCA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodWtyYWluaWFuQW50aGVtKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdWtyYWluaWFuQW50aGVtLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgMjUwMCk7XG4gICAgICB9LCA1MDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFzc2lnbiBpbnN0YW5jZSBtZXRob2RzIGZyb20gc3JjL2luc3RhbmNlTWV0aG9kcy8qLmpzIHRvIHByb3RvdHlwZVxuICBPYmplY3QuYXNzaWduKFN3ZWV0QWxlcnQucHJvdG90eXBlLCBpbnN0YW5jZU1ldGhvZHMpO1xuXG4gIC8vIEFzc2lnbiBzdGF0aWMgbWV0aG9kcyBmcm9tIHNyYy9zdGF0aWNNZXRob2RzLyouanMgdG8gY29uc3RydWN0b3JcbiAgT2JqZWN0LmFzc2lnbihTd2VldEFsZXJ0LCBzdGF0aWNNZXRob2RzKTtcblxuICAvLyBQcm94eSB0byBpbnN0YW5jZSBtZXRob2RzIHRvIGNvbnN0cnVjdG9yLCBmb3Igbm93LCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgT2JqZWN0LmtleXMoaW5zdGFuY2VNZXRob2RzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3NcbiAgICAgKiBAcmV0dXJucyB7YW55fVxuICAgICAqL1xuICAgIFN3ZWV0QWxlcnRba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZVtrZXldKC4uLmFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIFN3ZWV0QWxlcnQuRGlzbWlzc1JlYXNvbiA9IERpc21pc3NSZWFzb247XG4gIFN3ZWV0QWxlcnQudmVyc2lvbiA9ICcxMS42LjEzJztcblxuICBjb25zdCBTd2FsID0gU3dlZXRBbGVydDtcbiAgLy8gQHRzLWlnbm9yZVxuICBTd2FsLmRlZmF1bHQgPSBTd2FsO1xuXG4gIHJldHVybiBTd2FsO1xuXG59KSk7XG5pZiAodHlwZW9mIHRoaXMgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuU3dlZXRhbGVydDIpe3RoaXMuc3dhbCA9IHRoaXMuc3dlZXRBbGVydCA9IHRoaXMuU3dhbCA9IHRoaXMuU3dlZXRBbGVydCA9IHRoaXMuU3dlZXRhbGVydDJ9XG5cInVuZGVmaW5lZFwiIT10eXBlb2YgZG9jdW1lbnQmJmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7aWYoZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQobiksbi5zdHlsZVNoZWV0KW4uc3R5bGVTaGVldC5kaXNhYmxlZHx8KG4uc3R5bGVTaGVldC5jc3NUZXh0PXQpO2Vsc2UgdHJ5e24uaW5uZXJIVE1MPXR9Y2F0Y2goZSl7bi5pbm5lclRleHQ9dH19KGRvY3VtZW50LFwiLnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0e2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLWNvbHVtbjoxLzQgIWltcG9ydGFudDtncmlkLXJvdzoxLzQgIWltcG9ydGFudDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6bWluLWNvbnRlbnQgYXV0byBtaW4tY29udGVudDtwYWRkaW5nOjFlbTtvdmVyZmxvdy15OmhpZGRlbjtiYWNrZ3JvdW5kOiNmZmY7Ym94LXNoYWRvdzowIDAgMXB4IHJnYmEoMCwwLDAsLjA3NSksMCAxcHggMnB4IHJnYmEoMCwwLDAsLjA3NSksMXB4IDJweCA0cHggcmdiYSgwLDAsMCwuMDc1KSwxcHggM3B4IDhweCByZ2JhKDAsMCwwLC4wNzUpLDJweCA0cHggMTZweCByZ2JhKDAsMCwwLC4wNzUpO3BvaW50ZXItZXZlbnRzOmFsbH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Q+KntncmlkLWNvbHVtbjoyfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItdGl0bGV7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtmb250LXNpemU6MWVtO3RleHQtYWxpZ246aW5pdGlhbH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWxvYWRpbmd7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWlucHV0e2hlaWdodDoyZW07bWFyZ2luOi41ZW07Zm9udC1zaXplOjFlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZXtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItZm9vdGVye21hcmdpbjouNWVtIDAgMDtwYWRkaW5nOi41ZW0gMCAwO2ZvbnQtc2l6ZTouOGVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItY2xvc2V7Z3JpZC1jb2x1bW46My8zO2dyaWQtcm93OjEvOTk7YWxpZ24tc2VsZjpjZW50ZXI7d2lkdGg6LjhlbTtoZWlnaHQ6LjhlbTttYXJnaW46MDtmb250LXNpemU6MmVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaHRtbC1jb250YWluZXJ7bWFyZ2luOi41ZW0gMWVtO3BhZGRpbmc6MDtvdmVyZmxvdzppbml0aWFsO2ZvbnQtc2l6ZToxZW07dGV4dC1hbGlnbjppbml0aWFsfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaHRtbC1jb250YWluZXI6ZW1wdHl7cGFkZGluZzowfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItbG9hZGVye2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07aGVpZ2h0OjJlbTttYXJnaW46LjI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29ue2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MS85OTthbGlnbi1zZWxmOmNlbnRlcjt3aWR0aDoyZW07bWluLXdpZHRoOjJlbTtoZWlnaHQ6MmVtO21hcmdpbjowIC41ZW0gMCAwfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjEuOGVtO2ZvbnQtd2VpZ2h0OmJvbGR9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17dG9wOi44NzVlbTt3aWR0aDoxLjM3NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9bGVmdF17bGVmdDouMzEyNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItaWNvbi5zd2FsMi1lcnJvciBbY2xhc3NePXN3YWwyLXgtbWFyay1saW5lXVtjbGFzcyQ9cmlnaHRde3JpZ2h0Oi4zMTI1ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1hY3Rpb25ze2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2hlaWdodDphdXRvO21hcmdpbjowO21hcmdpbi10b3A6LjVlbTtwYWRkaW5nOjAgLjVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN0eWxlZHttYXJnaW46LjI1ZW0gLjVlbTtwYWRkaW5nOi40ZW0gLjZlbTtmb250LXNpemU6MWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2Vzc3tib3JkZXItY29sb3I6I2E1ZGM4Nn0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjEuNmVtO2hlaWdodDozZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9bGVmdF17dG9wOi0wLjhlbTtsZWZ0Oi0wLjVlbTt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyk7dHJhbnNmb3JtLW9yaWdpbjoyZW0gMmVtO2JvcmRlci1yYWRpdXM6NGVtIDAgMCA0ZW19LnN3YWwyLXBvcHVwLnN3YWwyLXRvYXN0IC5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotMC4yNWVtO2xlZnQ6LjkzNzVlbTt0cmFuc2Zvcm0tb3JpZ2luOjAgMS41ZW07Ym9yZGVyLXJhZGl1czowIDRlbSA0ZW0gMH0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3t3aWR0aDoyZW07aGVpZ2h0OjJlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtZml4e3RvcDowO2xlZnQ6LjQzNzVlbTt3aWR0aDouNDM3NWVtO2hlaWdodDoyLjY4NzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVde2hlaWdodDouMzEyNWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdCAuc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPWxvbmdde3RvcDouOTM3NWVtO3JpZ2h0Oi4xODc1ZW07d2lkdGg6MS4zNzVlbX0uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtdGlwe2FuaW1hdGlvbjpzd2FsMi10b2FzdC1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXAgLjc1c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3QgLnN3YWwyLXN1Y2Nlc3Muc3dhbDItaWNvbi1zaG93IC5zd2FsMi1zdWNjZXNzLWxpbmUtbG9uZ3thbmltYXRpb246c3dhbDItdG9hc3QtYW5pbWF0ZS1zdWNjZXNzLWxpbmUtbG9uZyAuNzVzfS5zd2FsMi1wb3B1cC5zd2FsMi10b2FzdC5zd2FsMi1zaG93e2FuaW1hdGlvbjpzd2FsMi10b2FzdC1zaG93IC41c30uc3dhbDItcG9wdXAuc3dhbDItdG9hc3Quc3dhbDItaGlkZXthbmltYXRpb246c3dhbDItdG9hc3QtaGlkZSAuMXMgZm9yd2FyZHN9LnN3YWwyLWNvbnRhaW5lcntkaXNwbGF5OmdyaWQ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDYwO3RvcDowO3JpZ2h0OjA7Ym90dG9tOjA7bGVmdDowO2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLXRlbXBsYXRlLWFyZWFzOlxcXCJ0b3Atc3RhcnQgICAgIHRvcCAgICAgICAgICAgIHRvcC1lbmRcXFwiIFxcXCJjZW50ZXItc3RhcnQgIGNlbnRlciAgICAgICAgIGNlbnRlci1lbmRcXFwiIFxcXCJib3R0b20tc3RhcnQgIGJvdHRvbS1jZW50ZXIgIGJvdHRvbS1lbmRcXFwiO2dyaWQtdGVtcGxhdGUtcm93czptaW5tYXgobWluLWNvbnRlbnQsIGF1dG8pIG1pbm1heChtaW4tY29udGVudCwgYXV0bykgbWlubWF4KG1pbi1jb250ZW50LCBhdXRvKTtoZWlnaHQ6MTAwJTtwYWRkaW5nOi42MjVlbTtvdmVyZmxvdy14OmhpZGRlbjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjFzOy13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNofS5zd2FsMi1jb250YWluZXIuc3dhbDItYmFja2Ryb3Atc2hvdywuc3dhbDItY29udGFpbmVyLnN3YWwyLW5vYW5pbWF0aW9ue2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuNCl9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1iYWNrZHJvcC1oaWRle2JhY2tncm91bmQ6cmdiYSgwLDAsMCwwKSAhaW1wb3J0YW50fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXN0YXJ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXN0YXJ0LC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLXN0YXJ0e2dyaWQtdGVtcGxhdGUtY29sdW1uczptaW5tYXgoMCwgMWZyKSBhdXRvIGF1dG99LnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3AsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXIsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b217Z3JpZC10ZW1wbGF0ZS1jb2x1bW5zOmF1dG8gbWlubWF4KDAsIDFmcikgYXV0b30uc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWVuZHtncmlkLXRlbXBsYXRlLWNvbHVtbnM6YXV0byBhdXRvIG1pbm1heCgwLCAxZnIpfS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXN0YXJ0Pi5zd2FsMi1wb3B1cHthbGlnbi1zZWxmOnN0YXJ0fS5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wPi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjoyO2FsaWduLXNlbGY6c3RhcnQ7anVzdGlmeS1zZWxmOmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1lbmQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0Pi5zd2FsMi1wb3B1cHtncmlkLWNvbHVtbjozO2FsaWduLXNlbGY6c3RhcnQ7anVzdGlmeS1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1zdGFydD4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItbGVmdD4uc3dhbDItcG9wdXB7Z3JpZC1yb3c6MjthbGlnbi1zZWxmOmNlbnRlcn0uc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcj4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtncmlkLXJvdzoyO2FsaWduLXNlbGY6Y2VudGVyO2p1c3RpZnktc2VsZjpjZW50ZXJ9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItZW5kPi5zd2FsMi1wb3B1cCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztncmlkLXJvdzoyO2FsaWduLXNlbGY6Y2VudGVyO2p1c3RpZnktc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tc3RhcnQ+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWxlZnQ+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjE7Z3JpZC1yb3c6MzthbGlnbi1zZWxmOmVuZH0uc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbT4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MjtncmlkLXJvdzozO2p1c3RpZnktc2VsZjpjZW50ZXI7YWxpZ24tc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kPi5zd2FsMi1wb3B1cCwuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1yaWdodD4uc3dhbDItcG9wdXB7Z3JpZC1jb2x1bW46MztncmlkLXJvdzozO2FsaWduLXNlbGY6ZW5kO2p1c3RpZnktc2VsZjplbmR9LnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LXJvdz4uc3dhbDItcG9wdXAsLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ncm93LWZ1bGxzY3JlZW4+LnN3YWwyLXBvcHVwe2dyaWQtY29sdW1uOjEvNDt3aWR0aDoxMDAlfS5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1jb2x1bW4+LnN3YWwyLXBvcHVwLC5zd2FsMi1jb250YWluZXIuc3dhbDItZ3Jvdy1mdWxsc2NyZWVuPi5zd2FsMi1wb3B1cHtncmlkLXJvdzoxLzQ7YWxpZ24tc2VsZjpzdHJldGNofS5zd2FsMi1jb250YWluZXIuc3dhbDItbm8tdHJhbnNpdGlvbnt0cmFuc2l0aW9uOm5vbmUgIWltcG9ydGFudH0uc3dhbDItcG9wdXB7ZGlzcGxheTpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO2JveC1zaXppbmc6Ym9yZGVyLWJveDtncmlkLXRlbXBsYXRlLWNvbHVtbnM6bWlubWF4KDAsIDEwMCUpO3dpZHRoOjMyZW07bWF4LXdpZHRoOjEwMCU7cGFkZGluZzowIDAgMS4yNWVtO2JvcmRlcjpub25lO2JvcmRlci1yYWRpdXM6NXB4O2JhY2tncm91bmQ6I2ZmZjtjb2xvcjojNTQ1NDU0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjFyZW19LnN3YWwyLXBvcHVwOmZvY3Vze291dGxpbmU6bm9uZX0uc3dhbDItcG9wdXAuc3dhbDItbG9hZGluZ3tvdmVyZmxvdy15OmhpZGRlbn0uc3dhbDItdGl0bGV7cG9zaXRpb246cmVsYXRpdmU7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjA7cGFkZGluZzouOGVtIDFlbSAwO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuODc1ZW07Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyO3RleHQtdHJhbnNmb3JtOm5vbmU7d29yZC13cmFwOmJyZWFrLXdvcmR9LnN3YWwyLWFjdGlvbnN7ZGlzcGxheTpmbGV4O3otaW5kZXg6MTtib3gtc2l6aW5nOmJvcmRlci1ib3g7ZmxleC13cmFwOndyYXA7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6YXV0bzttYXJnaW46MS4yNWVtIGF1dG8gMDtwYWRkaW5nOjB9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkW2Rpc2FibGVkXXtvcGFjaXR5Oi40fS5zd2FsMi1hY3Rpb25zOm5vdCguc3dhbDItbG9hZGluZykgLnN3YWwyLXN0eWxlZDpob3ZlcntiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMSksIHJnYmEoMCwgMCwgMCwgMC4xKSl9LnN3YWwyLWFjdGlvbnM6bm90KC5zd2FsMi1sb2FkaW5nKSAuc3dhbDItc3R5bGVkOmFjdGl2ZXtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudChyZ2JhKDAsIDAsIDAsIDAuMiksIHJnYmEoMCwgMCwgMCwgMC4yKSl9LnN3YWwyLWxvYWRlcntkaXNwbGF5Om5vbmU7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6Mi4yZW07aGVpZ2h0OjIuMmVtO21hcmdpbjowIDEuODc1ZW07YW5pbWF0aW9uOnN3YWwyLXJvdGF0ZS1sb2FkaW5nIDEuNXMgbGluZWFyIDBzIGluZmluaXRlIG5vcm1hbDtib3JkZXItd2lkdGg6LjI1ZW07Ym9yZGVyLXN0eWxlOnNvbGlkO2JvcmRlci1yYWRpdXM6MTAwJTtib3JkZXItY29sb3I6IzI3NzhjNCByZ2JhKDAsMCwwLDApICMyNzc4YzQgcmdiYSgwLDAsMCwwKX0uc3dhbDItc3R5bGVke21hcmdpbjouMzEyNWVtO3BhZGRpbmc6LjYyNWVtIDEuMWVtO3RyYW5zaXRpb246Ym94LXNoYWRvdyAuMXM7Ym94LXNoYWRvdzowIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtmb250LXdlaWdodDo1MDB9LnN3YWwyLXN0eWxlZDpub3QoW2Rpc2FibGVkXSl7Y3Vyc29yOnBvaW50ZXJ9LnN3YWwyLXN0eWxlZC5zd2FsMi1jb25maXJte2JvcmRlcjowO2JvcmRlci1yYWRpdXM6LjI1ZW07YmFja2dyb3VuZDppbml0aWFsO2JhY2tncm91bmQtY29sb3I6IzcwNjZlMDtjb2xvcjojZmZmO2ZvbnQtc2l6ZToxZW19LnN3YWwyLXN0eWxlZC5zd2FsMi1jb25maXJtOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgM3B4IHJnYmEoMTEyLDEwMiwyMjQsLjUpfS5zd2FsMi1zdHlsZWQuc3dhbDItZGVueXtib3JkZXI6MDtib3JkZXItcmFkaXVzOi4yNWVtO2JhY2tncm91bmQ6aW5pdGlhbDtiYWNrZ3JvdW5kLWNvbG9yOiNkYzM3NDE7Y29sb3I6I2ZmZjtmb250LXNpemU6MWVtfS5zd2FsMi1zdHlsZWQuc3dhbDItZGVueTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDIyMCw1NSw2NSwuNSl9LnN3YWwyLXN0eWxlZC5zd2FsMi1jYW5jZWx7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czouMjVlbTtiYWNrZ3JvdW5kOmluaXRpYWw7YmFja2dyb3VuZC1jb2xvcjojNmU3ODgxO2NvbG9yOiNmZmY7Zm9udC1zaXplOjFlbX0uc3dhbDItc3R5bGVkLnN3YWwyLWNhbmNlbDpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDExMCwxMjAsMTI5LC41KX0uc3dhbDItc3R5bGVkLnN3YWwyLWRlZmF1bHQtb3V0bGluZTpmb2N1c3tib3gtc2hhZG93OjAgMCAwIDNweCByZ2JhKDEwMCwxNTAsMjAwLC41KX0uc3dhbDItc3R5bGVkOmZvY3Vze291dGxpbmU6bm9uZX0uc3dhbDItc3R5bGVkOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5zd2FsMi1mb290ZXJ7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIDAgMDtwYWRkaW5nOjFlbSAxZW0gMDtib3JkZXItdG9wOjFweCBzb2xpZCAjZWVlO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjFlbX0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFyLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO2JvdHRvbTowO2xlZnQ6MDtncmlkLWNvbHVtbjphdXRvICFpbXBvcnRhbnQ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjVweDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjVweH0uc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3dpZHRoOjEwMCU7aGVpZ2h0Oi4yNWVtO2JhY2tncm91bmQ6cmdiYSgwLDAsMCwuMil9LnN3YWwyLWltYWdle21heC13aWR0aDoxMDAlO21hcmdpbjoyZW0gYXV0byAxZW19LnN3YWwyLWNsb3Nle3otaW5kZXg6MjthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxLjJlbTtoZWlnaHQ6MS4yZW07bWFyZ2luLXRvcDowO21hcmdpbi1yaWdodDowO21hcmdpbi1ib3R0b206LTEuMmVtO3BhZGRpbmc6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjpjb2xvciAuMXMsYm94LXNoYWRvdyAuMXM7Ym9yZGVyOm5vbmU7Ym9yZGVyLXJhZGl1czo1cHg7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2NvbG9yOiNjY2M7Zm9udC1mYW1pbHk6c2VyaWY7Zm9udC1mYW1pbHk6bW9ub3NwYWNlO2ZvbnQtc2l6ZToyLjVlbTtjdXJzb3I6cG9pbnRlcjtqdXN0aWZ5LXNlbGY6ZW5kfS5zd2FsMi1jbG9zZTpob3Zlcnt0cmFuc2Zvcm06bm9uZTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Y29sb3I6I2YyNzQ3NH0uc3dhbDItY2xvc2U6Zm9jdXN7b3V0bGluZTpub25lO2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfS5zd2FsMi1jbG9zZTo6LW1vei1mb2N1cy1pbm5lcntib3JkZXI6MH0uc3dhbDItaHRtbC1jb250YWluZXJ7ei1pbmRleDoxO2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSAxLjZlbSAuM2VtO3BhZGRpbmc6MDtvdmVyZmxvdzphdXRvO2NvbG9yOmluaGVyaXQ7Zm9udC1zaXplOjEuMTI1ZW07Zm9udC13ZWlnaHQ6bm9ybWFsO2xpbmUtaGVpZ2h0Om5vcm1hbDt0ZXh0LWFsaWduOmNlbnRlcjt3b3JkLXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmR9LnN3YWwyLWlucHV0LC5zd2FsMi1maWxlLC5zd2FsMi10ZXh0YXJlYSwuc3dhbDItc2VsZWN0LC5zd2FsMi1yYWRpbywuc3dhbDItY2hlY2tib3h7bWFyZ2luOjFlbSAyZW0gM3B4fS5zd2FsMi1pbnB1dCwuc3dhbDItZmlsZSwuc3dhbDItdGV4dGFyZWF7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOmF1dG87dHJhbnNpdGlvbjpib3JkZXItY29sb3IgLjFzLGJveC1zaGFkb3cgLjFzO2JvcmRlcjoxcHggc29saWQgI2Q5ZDlkOTtib3JkZXItcmFkaXVzOi4xODc1ZW07YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2JveC1zaGFkb3c6aW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjA2KSwwIDAgMCAzcHggcmdiYSgwLDAsMCwwKTtjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi1pbnB1dC5zd2FsMi1pbnB1dGVycm9yLC5zd2FsMi1maWxlLnN3YWwyLWlucHV0ZXJyb3IsLnN3YWwyLXRleHRhcmVhLnN3YWwyLWlucHV0ZXJyb3J7Ym9yZGVyLWNvbG9yOiNmMjc0NzQgIWltcG9ydGFudDtib3gtc2hhZG93OjAgMCAycHggI2YyNzQ3NCAhaW1wb3J0YW50fS5zd2FsMi1pbnB1dDpmb2N1cywuc3dhbDItZmlsZTpmb2N1cywuc3dhbDItdGV4dGFyZWE6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjYjRkYmVkO291dGxpbmU6bm9uZTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDFweCByZ2JhKDAsMCwwLC4wNiksMCAwIDAgM3B4IHJnYmEoMTAwLDE1MCwyMDAsLjUpfS5zd2FsMi1pbnB1dDo6cGxhY2Vob2xkZXIsLnN3YWwyLWZpbGU6OnBsYWNlaG9sZGVyLC5zd2FsMi10ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7Y29sb3I6I2NjY30uc3dhbDItcmFuZ2V7bWFyZ2luOjFlbSAyZW0gM3B4O2JhY2tncm91bmQ6I2ZmZn0uc3dhbDItcmFuZ2UgaW5wdXR7d2lkdGg6ODAlfS5zd2FsMi1yYW5nZSBvdXRwdXR7d2lkdGg6MjAlO2NvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6NjAwO3RleHQtYWxpZ246Y2VudGVyfS5zd2FsMi1yYW5nZSBpbnB1dCwuc3dhbDItcmFuZ2Ugb3V0cHV0e2hlaWdodDoyLjYyNWVtO3BhZGRpbmc6MDtmb250LXNpemU6MS4xMjVlbTtsaW5lLWhlaWdodDoyLjYyNWVtfS5zd2FsMi1pbnB1dHtoZWlnaHQ6Mi42MjVlbTtwYWRkaW5nOjAgLjc1ZW19LnN3YWwyLWZpbGV7d2lkdGg6NzUlO21hcmdpbi1yaWdodDphdXRvO21hcmdpbi1sZWZ0OmF1dG87YmFja2dyb3VuZDpyZ2JhKDAsMCwwLDApO2ZvbnQtc2l6ZToxLjEyNWVtfS5zd2FsMi10ZXh0YXJlYXtoZWlnaHQ6Ni43NWVtO3BhZGRpbmc6Ljc1ZW19LnN3YWwyLXNlbGVjdHttaW4td2lkdGg6NTAlO21heC13aWR0aDoxMDAlO3BhZGRpbmc6LjM3NWVtIC42MjVlbTtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Y29sb3I6aW5oZXJpdDtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItcmFkaW8sLnN3YWwyLWNoZWNrYm94e2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2JhY2tncm91bmQ6I2ZmZjtjb2xvcjppbmhlcml0fS5zd2FsMi1yYWRpbyBsYWJlbCwuc3dhbDItY2hlY2tib3ggbGFiZWx7bWFyZ2luOjAgLjZlbTtmb250LXNpemU6MS4xMjVlbX0uc3dhbDItcmFkaW8gaW5wdXQsLnN3YWwyLWNoZWNrYm94IGlucHV0e2ZsZXgtc2hyaW5rOjA7bWFyZ2luOjAgLjRlbX0uc3dhbDItaW5wdXQtbGFiZWx7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7bWFyZ2luOjFlbSBhdXRvIDB9LnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZXthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MWVtIDAgMDtwYWRkaW5nOi42MjVlbTtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZDojZjBmMGYwO2NvbG9yOiM2NjY7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDozMDB9LnN3YWwyLXZhbGlkYXRpb24tbWVzc2FnZTo6YmVmb3Jle2NvbnRlbnQ6XFxcIiFcXFwiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNWVtO21pbi13aWR0aDoxLjVlbTtoZWlnaHQ6MS41ZW07bWFyZ2luOjAgLjYyNWVtO2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2YyNzQ3NDtjb2xvcjojZmZmO2ZvbnQtd2VpZ2h0OjYwMDtsaW5lLWhlaWdodDoxLjVlbTt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItaWNvbntwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6NWVtO2hlaWdodDo1ZW07bWFyZ2luOjIuNWVtIGF1dG8gLjZlbTtib3JkZXI6MC4yNWVtIHNvbGlkIHJnYmEoMCwwLDAsMCk7Ym9yZGVyLXJhZGl1czo1MCU7Ym9yZGVyLWNvbG9yOiMwMDA7Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDo1ZW07Y3Vyc29yOmRlZmF1bHQ7dXNlci1zZWxlY3Q6bm9uZX0uc3dhbDItaWNvbiAuc3dhbDItaWNvbi1jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOjMuNzVlbX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvcntib3JkZXItY29sb3I6I2YyNzQ3NDtjb2xvcjojZjI3NDc0fS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIC5zd2FsMi14LW1hcmt7cG9zaXRpb246cmVsYXRpdmU7ZmxleC1ncm93OjF9LnN3YWwyLWljb24uc3dhbDItZXJyb3IgW2NsYXNzXj1zd2FsMi14LW1hcmstbGluZV17ZGlzcGxheTpibG9jaztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6Mi4zMTI1ZW07d2lkdGg6Mi45Mzc1ZW07aGVpZ2h0Oi4zMTI1ZW07Ym9yZGVyLXJhZGl1czouMTI1ZW07YmFja2dyb3VuZC1jb2xvcjojZjI3NDc0fS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1sZWZ0XXtsZWZ0OjEuMDYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5zd2FsMi1pY29uLnN3YWwyLWVycm9yIFtjbGFzc149c3dhbDIteC1tYXJrLWxpbmVdW2NsYXNzJD1yaWdodF17cmlnaHQ6MWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1lcnJvci5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItZXJyb3Iuc3dhbDItaWNvbi1zaG93IC5zd2FsMi14LW1hcmt7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3IteC1tYXJrIC41c30uc3dhbDItaWNvbi5zd2FsMi13YXJuaW5ne2JvcmRlci1jb2xvcjojZmFjZWE4O2NvbG9yOiNmOGJiODZ9LnN3YWwyLWljb24uc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItd2FybmluZy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLWljb24tY29udGVudHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1pLW1hcmsgLjVzfS5zd2FsMi1pY29uLnN3YWwyLWluZm97Ym9yZGVyLWNvbG9yOiM5ZGUwZjY7Y29sb3I6IzNmYzNlZX0uc3dhbDItaWNvbi5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvd3thbmltYXRpb246c3dhbDItYW5pbWF0ZS1lcnJvci1pY29uIC41c30uc3dhbDItaWNvbi5zd2FsMi1pbmZvLnN3YWwyLWljb24tc2hvdyAuc3dhbDItaWNvbi1jb250ZW50e2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLWktbWFyayAuOHN9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb257Ym9yZGVyLWNvbG9yOiNjOWRhZTE7Y29sb3I6Izg3YWRiZH0uc3dhbDItaWNvbi5zd2FsMi1xdWVzdGlvbi5zd2FsMi1pY29uLXNob3d7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbiAuNXN9LnN3YWwyLWljb24uc3dhbDItcXVlc3Rpb24uc3dhbDItaWNvbi1zaG93IC5zd2FsMi1pY29uLWNvbnRlbnR7YW5pbWF0aW9uOnN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFyayAuOHN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzc3tib3JkZXItY29sb3I6I2E1ZGM4Njtjb2xvcjojYTVkYzg2fS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWNpcmN1bGFyLWxpbmVde3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjMuNzVlbTtoZWlnaHQ6Ny41ZW07dHJhbnNmb3JtOnJvdGF0ZSg0NWRlZyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZV1bY2xhc3MkPWxlZnRde3RvcDotMC40Mzc1ZW07bGVmdDotMi4wNjM1ZW07dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpO3RyYW5zZm9ybS1vcmlnaW46My43NWVtIDMuNzVlbTtib3JkZXItcmFkaXVzOjcuNWVtIDAgMCA3LjVlbX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1jaXJjdWxhci1saW5lXVtjbGFzcyQ9cmlnaHRde3RvcDotMC42ODc1ZW07bGVmdDoxLjg3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKTt0cmFuc2Zvcm0tb3JpZ2luOjAgMy43NWVtO2JvcmRlci1yYWRpdXM6MCA3LjVlbSA3LjVlbSAwfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgLnN3YWwyLXN1Y2Nlc3MtcmluZ3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjI7dG9wOi0wLjI1ZW07bGVmdDotMC4yNWVtO2JveC1zaXppbmc6Y29udGVudC1ib3g7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtib3JkZXI6LjI1ZW0gc29saWQgcmdiYSgxNjUsMjIwLDEzNCwuMyk7Ym9yZGVyLXJhZGl1czo1MCV9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyAuc3dhbDItc3VjY2Vzcy1maXh7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxO3RvcDouNWVtO2xlZnQ6MS42MjVlbTt3aWR0aDouNDM3NWVtO2hlaWdodDo1LjYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzIFtjbGFzc149c3dhbDItc3VjY2Vzcy1saW5lXXtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MjtoZWlnaHQ6LjMxMjVlbTtib3JkZXItcmFkaXVzOi4xMjVlbTtiYWNrZ3JvdW5kLWNvbG9yOiNhNWRjODZ9LnN3YWwyLWljb24uc3dhbDItc3VjY2VzcyBbY2xhc3NePXN3YWwyLXN1Y2Nlc3MtbGluZV1bY2xhc3MkPXRpcF17dG9wOjIuODc1ZW07bGVmdDouODEyNWVtO3dpZHRoOjEuNTYyNWVtO3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS5zd2FsMi1pY29uLnN3YWwyLXN1Y2Nlc3MgW2NsYXNzXj1zd2FsMi1zdWNjZXNzLWxpbmVdW2NsYXNzJD1sb25nXXt0b3A6Mi4zNzVlbTtyaWdodDouNWVtO3dpZHRoOjIuOTM3NWVtO3RyYW5zZm9ybTpyb3RhdGUoLTQ1ZGVnKX0uc3dhbDItaWNvbi5zd2FsMi1zdWNjZXNzLnN3YWwyLWljb24tc2hvdyAuc3dhbDItc3VjY2Vzcy1saW5lLXRpcHthbmltYXRpb246c3dhbDItYW5pbWF0ZS1zdWNjZXNzLWxpbmUtdGlwIC43NXN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtbGluZS1sb25ne2FuaW1hdGlvbjpzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nIC43NXN9LnN3YWwyLWljb24uc3dhbDItc3VjY2Vzcy5zd2FsMi1pY29uLXNob3cgLnN3YWwyLXN1Y2Nlc3MtY2lyY3VsYXItbGluZS1yaWdodHthbmltYXRpb246c3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZSA0LjI1cyBlYXNlLWlufS5zd2FsMi1wcm9ncmVzcy1zdGVwc3tmbGV4LXdyYXA6d3JhcDthbGlnbi1pdGVtczpjZW50ZXI7bWF4LXdpZHRoOjEwMCU7bWFyZ2luOjEuMjVlbSBhdXRvO3BhZGRpbmc6MDtiYWNrZ3JvdW5kOnJnYmEoMCwwLDAsMCk7Zm9udC13ZWlnaHQ6NjAwfS5zd2FsMi1wcm9ncmVzcy1zdGVwcyBsaXtkaXNwbGF5OmlubGluZS1ibG9jaztwb3NpdGlvbjpyZWxhdGl2ZX0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXB7ei1pbmRleDoyMDtmbGV4LXNocmluazowO3dpZHRoOjJlbTtoZWlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6MmVtO2JhY2tncm91bmQ6IzI3NzhjNDtjb2xvcjojZmZmO2xpbmUtaGVpZ2h0OjJlbTt0ZXh0LWFsaWduOmNlbnRlcn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB7YmFja2dyb3VuZDojMjc3OGM0fS5zd2FsMi1wcm9ncmVzcy1zdGVwcyAuc3dhbDItcHJvZ3Jlc3Mtc3RlcC5zd2FsMi1hY3RpdmUtcHJvZ3Jlc3Mtc3RlcH4uc3dhbDItcHJvZ3Jlc3Mtc3RlcHtiYWNrZ3JvdW5kOiNhZGQ4ZTY7Y29sb3I6I2ZmZn0uc3dhbDItcHJvZ3Jlc3Mtc3RlcHMgLnN3YWwyLXByb2dyZXNzLXN0ZXAuc3dhbDItYWN0aXZlLXByb2dyZXNzLXN0ZXB+LnN3YWwyLXByb2dyZXNzLXN0ZXAtbGluZXtiYWNrZ3JvdW5kOiNhZGQ4ZTZ9LnN3YWwyLXByb2dyZXNzLXN0ZXBzIC5zd2FsMi1wcm9ncmVzcy1zdGVwLWxpbmV7ei1pbmRleDoxMDtmbGV4LXNocmluazowO3dpZHRoOjIuNWVtO2hlaWdodDouNGVtO21hcmdpbjowIC0xcHg7YmFja2dyb3VuZDojMjc3OGM0fVtjbGFzc149c3dhbDJdey13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDAsMCwwLDApfS5zd2FsMi1zaG93e2FuaW1hdGlvbjpzd2FsMi1zaG93IC4zc30uc3dhbDItaGlkZXthbmltYXRpb246c3dhbDItaGlkZSAuMTVzIGZvcndhcmRzfS5zd2FsMi1ub2FuaW1hdGlvbnt0cmFuc2l0aW9uOm5vbmV9LnN3YWwyLXNjcm9sbGJhci1tZWFzdXJle3Bvc2l0aW9uOmFic29sdXRlO3RvcDotOTk5OXB4O3dpZHRoOjUwcHg7aGVpZ2h0OjUwcHg7b3ZlcmZsb3c6c2Nyb2xsfS5zd2FsMi1ydGwgLnN3YWwyLWNsb3Nle21hcmdpbi1yaWdodDppbml0aWFsO21hcmdpbi1sZWZ0OjB9LnN3YWwyLXJ0bCAuc3dhbDItdGltZXItcHJvZ3Jlc3MtYmFye3JpZ2h0OjA7bGVmdDphdXRvfUBrZXlmcmFtZXMgc3dhbDItdG9hc3Qtc2hvd3swJXt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMC42MjVlbSkgcm90YXRlWigyZGVnKX0zMyV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigtMmRlZyl9NjYle3RyYW5zZm9ybTp0cmFuc2xhdGVZKDAuMzEyNWVtKSByb3RhdGVaKDJkZWcpfTEwMCV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWigwZGVnKX19QGtleWZyYW1lcyBzd2FsMi10b2FzdC1oaWRlezEwMCV7dHJhbnNmb3JtOnJvdGF0ZVooMWRlZyk7b3BhY2l0eTowfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLXRpcHswJXt0b3A6LjU2MjVlbTtsZWZ0Oi4wNjI1ZW07d2lkdGg6MH01NCV7dG9wOi4xMjVlbTtsZWZ0Oi4xMjVlbTt3aWR0aDowfTcwJXt0b3A6LjYyNWVtO2xlZnQ6LTAuMjVlbTt3aWR0aDoxLjYyNWVtfTg0JXt0b3A6MS4wNjI1ZW07bGVmdDouNzVlbTt3aWR0aDouNWVtfTEwMCV7dG9wOjEuMTI1ZW07bGVmdDouMTg3NWVtO3dpZHRoOi43NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXRvYXN0LWFuaW1hdGUtc3VjY2Vzcy1saW5lLWxvbmd7MCV7dG9wOjEuNjI1ZW07cmlnaHQ6MS4zNzVlbTt3aWR0aDowfTY1JXt0b3A6MS4yNWVtO3JpZ2h0Oi45Mzc1ZW07d2lkdGg6MH04NCV7dG9wOi45Mzc1ZW07cmlnaHQ6MDt3aWR0aDoxLjEyNWVtfTEwMCV7dG9wOi45Mzc1ZW07cmlnaHQ6LjE4NzVlbTt3aWR0aDoxLjM3NWVtfX1Aa2V5ZnJhbWVzIHN3YWwyLXNob3d7MCV7dHJhbnNmb3JtOnNjYWxlKDAuNyl9NDUle3RyYW5zZm9ybTpzY2FsZSgxLjA1KX04MCV7dHJhbnNmb3JtOnNjYWxlKDAuOTUpfTEwMCV7dHJhbnNmb3JtOnNjYWxlKDEpfX1Aa2V5ZnJhbWVzIHN3YWwyLWhpZGV7MCV7dHJhbnNmb3JtOnNjYWxlKDEpO29wYWNpdHk6MX0xMDAle3RyYW5zZm9ybTpzY2FsZSgwLjUpO29wYWNpdHk6MH19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS10aXB7MCV7dG9wOjEuMTg3NWVtO2xlZnQ6LjA2MjVlbTt3aWR0aDowfTU0JXt0b3A6MS4wNjI1ZW07bGVmdDouMTI1ZW07d2lkdGg6MH03MCV7dG9wOjIuMTg3NWVtO2xlZnQ6LTAuMzc1ZW07d2lkdGg6My4xMjVlbX04NCV7dG9wOjNlbTtsZWZ0OjEuMzEyNWVtO3dpZHRoOjEuMDYyNWVtfTEwMCV7dG9wOjIuODEyNWVtO2xlZnQ6LjgxMjVlbTt3aWR0aDoxLjU2MjVlbX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLXN1Y2Nlc3MtbGluZS1sb25nezAle3RvcDozLjM3NWVtO3JpZ2h0OjIuODc1ZW07d2lkdGg6MH02NSV7dG9wOjMuMzc1ZW07cmlnaHQ6Mi44NzVlbTt3aWR0aDowfTg0JXt0b3A6Mi4xODc1ZW07cmlnaHQ6MDt3aWR0aDozLjQzNzVlbX0xMDAle3RvcDoyLjM3NWVtO3JpZ2h0Oi41ZW07d2lkdGg6Mi45Mzc1ZW19fUBrZXlmcmFtZXMgc3dhbDItcm90YXRlLXN1Y2Nlc3MtY2lyY3VsYXItbGluZXswJXt0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9NSV7dHJhbnNmb3JtOnJvdGF0ZSgtNDVkZWcpfTEyJXt0cmFuc2Zvcm06cm90YXRlKC00MDVkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgtNDA1ZGVnKX19QGtleWZyYW1lcyBzd2FsMi1hbmltYXRlLWVycm9yLXgtbWFya3swJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKDAuNCk7b3BhY2l0eTowfTUwJXttYXJnaW4tdG9wOjEuNjI1ZW07dHJhbnNmb3JtOnNjYWxlKDAuNCk7b3BhY2l0eTowfTgwJXttYXJnaW4tdG9wOi0wLjM3NWVtO3RyYW5zZm9ybTpzY2FsZSgxLjE1KX0xMDAle21hcmdpbi10b3A6MDt0cmFuc2Zvcm06c2NhbGUoMSk7b3BhY2l0eToxfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtZXJyb3ItaWNvbnswJXt0cmFuc2Zvcm06cm90YXRlWCgxMDBkZWcpO29wYWNpdHk6MH0xMDAle3RyYW5zZm9ybTpyb3RhdGVYKDBkZWcpO29wYWNpdHk6MX19QGtleWZyYW1lcyBzd2FsMi1yb3RhdGUtbG9hZGluZ3swJXt0cmFuc2Zvcm06cm90YXRlKDBkZWcpfTEwMCV7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtcXVlc3Rpb24tbWFya3swJXt0cmFuc2Zvcm06cm90YXRlWSgtMzYwZGVnKX0xMDAle3RyYW5zZm9ybTpyb3RhdGVZKDApfX1Aa2V5ZnJhbWVzIHN3YWwyLWFuaW1hdGUtaS1tYXJrezAle3RyYW5zZm9ybTpyb3RhdGVaKDQ1ZGVnKTtvcGFjaXR5OjB9MjUle3RyYW5zZm9ybTpyb3RhdGVaKC0yNWRlZyk7b3BhY2l0eTouNH01MCV7dHJhbnNmb3JtOnJvdGF0ZVooMTVkZWcpO29wYWNpdHk6Ljh9NzUle3RyYW5zZm9ybTpyb3RhdGVaKC01ZGVnKTtvcGFjaXR5OjF9MTAwJXt0cmFuc2Zvcm06cm90YXRlWCgwKTtvcGFjaXR5OjF9fWJvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3c6aGlkZGVufWJvZHkuc3dhbDItaGVpZ2h0LWF1dG97aGVpZ2h0OmF1dG8gIWltcG9ydGFudH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLDApICFpbXBvcnRhbnQ7cG9pbnRlci1ldmVudHM6bm9uZX1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLXBvcHVwe3BvaW50ZXItZXZlbnRzOmFsbH1ib2R5LnN3YWwyLW5vLWJhY2tkcm9wIC5zd2FsMi1jb250YWluZXIgLnN3YWwyLW1vZGFse2JveC1zaGFkb3c6MCAwIDEwcHggcmdiYSgwLDAsMCwuNCl9QG1lZGlhIHByaW50e2JvZHkuc3dhbDItc2hvd246bm90KC5zd2FsMi1uby1iYWNrZHJvcCk6bm90KC5zd2FsMi10b2FzdC1zaG93bil7b3ZlcmZsb3cteTpzY3JvbGwgIWltcG9ydGFudH1ib2R5LnN3YWwyLXNob3duOm5vdCguc3dhbDItbm8tYmFja2Ryb3ApOm5vdCguc3dhbDItdG9hc3Qtc2hvd24pPlthcmlhLWhpZGRlbj10cnVlXXtkaXNwbGF5Om5vbmV9Ym9keS5zd2FsMi1zaG93bjpub3QoLnN3YWwyLW5vLWJhY2tkcm9wKTpub3QoLnN3YWwyLXRvYXN0LXNob3duKSAuc3dhbDItY29udGFpbmVye3Bvc2l0aW9uOnN0YXRpYyAhaW1wb3J0YW50fX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXJ7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjM2MHB4O21heC13aWR0aDoxMDAlO2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwwKTtwb2ludGVyLWV2ZW50czpub25lfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3B7dG9wOjA7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItdG9wLXJpZ2h0e3RvcDowO3JpZ2h0OjA7Ym90dG9tOmF1dG87bGVmdDphdXRvfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi10b3Atc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLXRvcC1sZWZ0e3RvcDowO3JpZ2h0OmF1dG87Ym90dG9tOmF1dG87bGVmdDowfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1jZW50ZXItc3RhcnQsYm9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlci1sZWZ0e3RvcDo1MCU7cmlnaHQ6YXV0bztib3R0b206YXV0bztsZWZ0OjA7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWNlbnRlcnt0b3A6NTAlO3JpZ2h0OmF1dG87Ym90dG9tOmF1dG87bGVmdDo1MCU7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKX1ib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLWVuZCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItY2VudGVyLXJpZ2h0e3RvcDo1MCU7cmlnaHQ6MDtib3R0b206YXV0bztsZWZ0OmF1dG87dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbS1zdGFydCxib2R5LnN3YWwyLXRvYXN0LXNob3duIC5zd2FsMi1jb250YWluZXIuc3dhbDItYm90dG9tLWxlZnR7dG9wOmF1dG87cmlnaHQ6YXV0bztib3R0b206MDtsZWZ0OjB9Ym9keS5zd2FsMi10b2FzdC1zaG93biAuc3dhbDItY29udGFpbmVyLnN3YWwyLWJvdHRvbXt0b3A6YXV0bztyaWdodDphdXRvO2JvdHRvbTowO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfWJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tZW5kLGJvZHkuc3dhbDItdG9hc3Qtc2hvd24gLnN3YWwyLWNvbnRhaW5lci5zd2FsMi1ib3R0b20tcmlnaHR7dG9wOmF1dG87cmlnaHQ6MDtib3R0b206MDtsZWZ0OmF1dG99XCIpOyJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsImdsb2JhbFRoaXMiLCJzZWxmIiwiU3dlZXRhbGVydDIiLCJwcml2YXRlUHJvcHMiLCJhd2FpdGluZ1Byb21pc2UiLCJXZWFrTWFwIiwicHJvbWlzZSIsImlubmVyUGFyYW1zIiwiZG9tQ2FjaGUiLCJzd2FsUHJlZml4IiwicHJlZml4IiwiaXRlbXMiLCJyZXN1bHQiLCJpIiwic3dhbENsYXNzZXMiLCJpY29uVHlwZXMiLCJjb25zb2xlUHJlZml4IiwidW5pcXVlQXJyYXkiLCJhcnIiLCJsZW5ndGgiLCJpbmRleE9mIiwicHVzaCIsImNhcGl0YWxpemVGaXJzdExldHRlciIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ3YXJuIiwibWVzc2FnZSIsImNvbnNvbGUiLCJqb2luIiwiZXJyb3IiLCJwcmV2aW91c1dhcm5PbmNlTWVzc2FnZXMiLCJ3YXJuT25jZSIsImluY2x1ZGVzIiwid2FybkFib3V0RGVwcmVjYXRpb24iLCJkZXByZWNhdGVkUGFyYW0iLCJ1c2VJbnN0ZWFkIiwiY2FsbElmRnVuY3Rpb24iLCJhcmciLCJoYXNUb1Byb21pc2VGbiIsInRvUHJvbWlzZSIsImFzUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNQcm9taXNlIiwiZ2V0Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJib2R5IiwicXVlcnlTZWxlY3RvciIsImNvbnRhaW5lciIsImVsZW1lbnRCeVNlbGVjdG9yIiwic2VsZWN0b3JTdHJpbmciLCJlbGVtZW50QnlDbGFzcyIsImNsYXNzTmFtZSIsImdldFBvcHVwIiwicG9wdXAiLCJnZXRJY29uIiwiaWNvbiIsImdldEljb25Db250ZW50IiwiZ2V0VGl0bGUiLCJ0aXRsZSIsImdldEh0bWxDb250YWluZXIiLCJnZXRJbWFnZSIsImltYWdlIiwiZ2V0UHJvZ3Jlc3NTdGVwcyIsImdldFZhbGlkYXRpb25NZXNzYWdlIiwiZ2V0Q29uZmlybUJ1dHRvbiIsImFjdGlvbnMiLCJjb25maXJtIiwiZ2V0RGVueUJ1dHRvbiIsImRlbnkiLCJnZXRJbnB1dExhYmVsIiwiZ2V0TG9hZGVyIiwibG9hZGVyIiwiZ2V0Q2FuY2VsQnV0dG9uIiwiY2FuY2VsIiwiZ2V0QWN0aW9ucyIsImdldEZvb3RlciIsImZvb3RlciIsImdldFRpbWVyUHJvZ3Jlc3NCYXIiLCJnZXRDbG9zZUJ1dHRvbiIsImNsb3NlIiwiZm9jdXNhYmxlIiwiZ2V0Rm9jdXNhYmxlRWxlbWVudHMiLCJmb2N1c2FibGVFbGVtZW50c1dpdGhUYWJpbmRleCIsIkFycmF5IiwiZnJvbSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJzb3J0IiwiYSIsImIiLCJ0YWJpbmRleEEiLCJwYXJzZUludCIsImdldEF0dHJpYnV0ZSIsInRhYmluZGV4QiIsIm90aGVyRm9jdXNhYmxlRWxlbWVudHMiLCJmaWx0ZXIiLCJlbCIsImNvbmNhdCIsImlzVmlzaWJsZSQxIiwiaXNNb2RhbCIsImhhc0NsYXNzIiwic2hvd24iLCJpc1RvYXN0IiwidG9hc3QiLCJpc0xvYWRpbmciLCJoYXNBdHRyaWJ1dGUiLCJzdGF0ZXMiLCJwcmV2aW91c0JvZHlQYWRkaW5nIiwic2V0SW5uZXJIdG1sIiwiZWxlbSIsImh0bWwiLCJ0ZXh0Q29udGVudCIsInBhcnNlciIsIkRPTVBhcnNlciIsInBhcnNlZCIsInBhcnNlRnJvbVN0cmluZyIsImNoaWxkTm9kZXMiLCJmb3JFYWNoIiwiY2hpbGQiLCJhcHBlbmRDaGlsZCIsIkhUTUxWaWRlb0VsZW1lbnQiLCJIVE1MQXVkaW9FbGVtZW50IiwiY2xvbmVOb2RlIiwiY2xhc3NMaXN0Iiwic3BsaXQiLCJjb250YWlucyIsInJlbW92ZUN1c3RvbUNsYXNzZXMiLCJwYXJhbXMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJzaG93Q2xhc3MiLCJyZW1vdmUiLCJhcHBseUN1c3RvbUNsYXNzIiwiY3VzdG9tQ2xhc3MiLCJhZGRDbGFzcyIsImdldElucHV0JDEiLCJpbnB1dENsYXNzIiwiY2hlY2tib3giLCJyYWRpbyIsInJhbmdlIiwiaW5wdXQiLCJmb2N1c0lucHV0IiwiZm9jdXMiLCJ0eXBlIiwidmFsIiwidmFsdWUiLCJ0b2dnbGVDbGFzcyIsInRhcmdldCIsImNvbmRpdGlvbiIsIkJvb2xlYW4iLCJpc0FycmF5IiwiYWRkIiwicmVtb3ZlQ2xhc3MiLCJnZXREaXJlY3RDaGlsZEJ5Q2xhc3MiLCJjaGlsZHJlbiIsIkhUTUxFbGVtZW50IiwiYXBwbHlOdW1lcmljYWxTdHlsZSIsInByb3BlcnR5Iiwic3R5bGUiLCJyZW1vdmVQcm9wZXJ0eSIsInNob3ciLCJkaXNwbGF5IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwiaGlkZSIsInNldFN0eWxlIiwicGFyZW50Iiwic2VsZWN0b3IiLCJ0b2dnbGUiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImdldENsaWVudFJlY3RzIiwiYWxsQnV0dG9uc0FyZUhpZGRlbiIsImlzU2Nyb2xsYWJsZSIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImhhc0Nzc0FuaW1hdGlvbiIsIndpbmRvdyIsImdldENvbXB1dGVkU3R5bGUiLCJhbmltRHVyYXRpb24iLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInRyYW5zRHVyYXRpb24iLCJhbmltYXRlVGltZXJQcm9ncmVzc0JhciIsInRpbWVyIiwicmVzZXQiLCJ0aW1lclByb2dyZXNzQmFyIiwidHJhbnNpdGlvbiIsIndpZHRoIiwic2V0VGltZW91dCIsInN0b3BUaW1lclByb2dyZXNzQmFyIiwidGltZXJQcm9ncmVzc0JhcldpZHRoIiwidGltZXJQcm9ncmVzc0JhckZ1bGxXaWR0aCIsInRpbWVyUHJvZ3Jlc3NCYXJQZXJjZW50IiwiUkVTVE9SRV9GT0NVU19USU1FT1VUIiwiZ2xvYmFsU3RhdGUiLCJmb2N1c1ByZXZpb3VzQWN0aXZlRWxlbWVudCIsInByZXZpb3VzQWN0aXZlRWxlbWVudCIsInJlc3RvcmVBY3RpdmVFbGVtZW50IiwicmV0dXJuRm9jdXMiLCJ4Iiwic2Nyb2xsWCIsInkiLCJzY3JvbGxZIiwicmVzdG9yZUZvY3VzVGltZW91dCIsInNjcm9sbFRvIiwiaXNOb2RlRW52Iiwic3dlZXRIVE1MIiwiZmlsZSIsInNlbGVjdCIsImxhYmVsIiwidGV4dGFyZWEiLCJyZXBsYWNlIiwicmVzZXRPbGRDb250YWluZXIiLCJvbGRDb250YWluZXIiLCJkb2N1bWVudEVsZW1lbnQiLCJyZXNldFZhbGlkYXRpb25NZXNzYWdlJDEiLCJjdXJyZW50SW5zdGFuY2UiLCJyZXNldFZhbGlkYXRpb25NZXNzYWdlIiwiYWRkSW5wdXRDaGFuZ2VMaXN0ZW5lcnMiLCJyYW5nZU91dHB1dCIsIm9uaW5wdXQiLCJvbmNoYW5nZSIsImdldFRhcmdldCIsInNldHVwQWNjZXNzaWJpbGl0eSIsInNldEF0dHJpYnV0ZSIsInNldHVwUlRMIiwidGFyZ2V0RWxlbWVudCIsImRpcmVjdGlvbiIsInJ0bCIsImluaXQiLCJvbGRDb250YWluZXJFeGlzdGVkIiwiY3JlYXRlRWxlbWVudCIsInBhcnNlSHRtbFRvQ29udGFpbmVyIiwicGFyYW0iLCJoYW5kbGVPYmplY3QiLCJqcXVlcnkiLCJoYW5kbGVKcXVlcnlFbGVtIiwidG9TdHJpbmciLCJhbmltYXRpb25FbmRFdmVudCIsInRlc3RFbCIsInRyYW5zRW5kRXZlbnROYW1lcyIsIldlYmtpdEFuaW1hdGlvbiIsImFuaW1hdGlvbiIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm1lYXN1cmVTY3JvbGxiYXIiLCJzY3JvbGxEaXYiLCJzY3JvbGxiYXJXaWR0aCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFdpZHRoIiwicmVtb3ZlQ2hpbGQiLCJyZW5kZXJBY3Rpb25zIiwiaW5zdGFuY2UiLCJzaG93Q29uZmlybUJ1dHRvbiIsInNob3dEZW55QnV0dG9uIiwic2hvd0NhbmNlbEJ1dHRvbiIsInJlbmRlckJ1dHRvbnMiLCJsb2FkZXJIdG1sIiwiY29uZmlybUJ1dHRvbiIsImRlbnlCdXR0b24iLCJjYW5jZWxCdXR0b24iLCJyZW5kZXJCdXR0b24iLCJoYW5kbGVCdXR0b25zU3R5bGluZyIsInJldmVyc2VCdXR0b25zIiwiaW5zZXJ0QmVmb3JlIiwiYnV0dG9uc1N0eWxpbmciLCJzdHlsZWQiLCJjb25maXJtQnV0dG9uQ29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJkZW55QnV0dG9uQ29sb3IiLCJjYW5jZWxCdXR0b25Db2xvciIsImJ1dHRvbiIsImJ1dHRvblR5cGUiLCJyZW5kZXJDbG9zZUJ1dHRvbiIsImNsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25IdG1sIiwic2hvd0Nsb3NlQnV0dG9uIiwiY2xvc2VCdXR0b25BcmlhTGFiZWwiLCJyZW5kZXJDb250YWluZXIiLCJoYW5kbGVCYWNrZHJvcFBhcmFtIiwiYmFja2Ryb3AiLCJoYW5kbGVQb3NpdGlvblBhcmFtIiwicG9zaXRpb24iLCJoYW5kbGVHcm93UGFyYW0iLCJncm93IiwiYmFja2dyb3VuZCIsImNlbnRlciIsImdyb3dDbGFzcyIsImlucHV0Q2xhc3NlcyIsInJlbmRlcklucHV0IiwiZ2V0IiwicmVyZW5kZXIiLCJpbnB1dENvbnRhaW5lciIsInNldEF0dHJpYnV0ZXMiLCJpbnB1dEF0dHJpYnV0ZXMiLCJzaG93SW5wdXQiLCJzZXRDdXN0b21DbGFzcyIsInJlbmRlcklucHV0VHlwZSIsImdldElucHV0Q29udGFpbmVyIiwicmVtb3ZlQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJhdHRyTmFtZSIsIm5hbWUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyIiwic2V0SW5wdXRQbGFjZWhvbGRlciIsInBsYWNlaG9sZGVyIiwiaW5wdXRQbGFjZWhvbGRlciIsInNldElucHV0TGFiZWwiLCJwcmVwZW5kVG8iLCJpbnB1dExhYmVsIiwiaWQiLCJsYWJlbENsYXNzIiwiaW5uZXJUZXh0IiwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiaW5wdXRUeXBlIiwiY2hlY2tBbmRTZXRJbnB1dFZhbHVlIiwiaW5wdXRWYWx1ZSIsInRleHQiLCJlbWFpbCIsInBhc3N3b3JkIiwibnVtYmVyIiwidGVsIiwidXJsIiwicmFuZ2VJbnB1dCIsImRpc2FibGVkIiwic2VsZWN0ZWQiLCJjaGVja2JveENvbnRhaW5lciIsImNoZWNrZWQiLCJnZXRNYXJnaW4iLCJtYXJnaW5MZWZ0IiwibWFyZ2luUmlnaHQiLCJpbml0aWFsUG9wdXBXaWR0aCIsInRleHRhcmVhUmVzaXplSGFuZGxlciIsInRleHRhcmVhV2lkdGgiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImF0dHJpYnV0ZUZpbHRlciIsInJlbmRlckNvbnRlbnQiLCJodG1sQ29udGFpbmVyIiwicmVuZGVyRm9vdGVyIiwicmVuZGVySWNvbiIsInNldENvbnRlbnQiLCJhcHBseVN0eWxlcyIsImljb25IdG1sIiwia2V5cyIsImljb25UeXBlIiwic2V0Q29sb3IiLCJhZGp1c3RTdWNjZXNzSWNvbkJhY2tncm91bmRDb2xvciIsInBvcHVwQmFja2dyb3VuZENvbG9yIiwic3VjY2Vzc0ljb25QYXJ0cyIsInN1Y2Nlc3NJY29uSHRtbCIsImVycm9ySWNvbkh0bWwiLCJvbGRDb250ZW50IiwiaW5uZXJIVE1MIiwibmV3Q29udGVudCIsImljb25Db250ZW50IiwiZGVmYXVsdEljb25IdG1sIiwicXVlc3Rpb24iLCJ3YXJuaW5nIiwiaW5mbyIsInRyaW0iLCJpY29uQ29sb3IiLCJjb2xvciIsImJvcmRlckNvbG9yIiwic2VsIiwiY29udGVudCIsInJlbmRlckltYWdlIiwiaW1hZ2VVcmwiLCJpbWFnZUFsdCIsImltYWdlV2lkdGgiLCJpbWFnZUhlaWdodCIsInJlbmRlclBvcHVwIiwicGFkZGluZyIsImFkZENsYXNzZXMkMSIsIm1vZGFsIiwicmVuZGVyUHJvZ3Jlc3NTdGVwcyIsInByb2dyZXNzU3RlcHNDb250YWluZXIiLCJwcm9ncmVzc1N0ZXBzIiwiY3VycmVudFByb2dyZXNzU3RlcCIsInN0ZXAiLCJpbmRleCIsInN0ZXBFbCIsImNyZWF0ZVN0ZXBFbGVtZW50IiwibGluZUVsIiwiY3JlYXRlTGluZUVsZW1lbnQiLCJwcm9ncmVzc1N0ZXBzRGlzdGFuY2UiLCJyZW5kZXJUaXRsZSIsInRpdGxlVGV4dCIsInJlbmRlciIsImRpZFJlbmRlciIsImhpZGVMb2FkaW5nIiwic2hvd1JlbGF0ZWRCdXR0b24iLCJsb2FkaW5nIiwiYnV0dG9uVG9SZXBsYWNlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldElucHV0IiwiaXNWaXNpYmxlIiwiY2xpY2tDb25maXJtIiwiY2xpY2siLCJjbGlja0RlbnkiLCJjbGlja0NhbmNlbCIsIkRpc21pc3NSZWFzb24iLCJmcmVlemUiLCJlc2MiLCJyZW1vdmVLZXlkb3duSGFuZGxlciIsImtleWRvd25UYXJnZXQiLCJrZXlkb3duSGFuZGxlckFkZGVkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImtleWRvd25IYW5kbGVyIiwiY2FwdHVyZSIsImtleWRvd25MaXN0ZW5lckNhcHR1cmUiLCJhZGRLZXlkb3duSGFuZGxlciIsImRpc21pc3NXaXRoIiwiZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJzZXRGb2N1cyIsImluY3JlbWVudCIsImZvY3VzYWJsZUVsZW1lbnRzIiwiYXJyb3dLZXlzTmV4dEJ1dHRvbiIsImFycm93S2V5c1ByZXZpb3VzQnV0dG9uIiwiaXNDb21wb3NpbmciLCJrZXlDb2RlIiwic3RvcEtleWRvd25Qcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsImtleSIsImhhbmRsZUVudGVyIiwiaGFuZGxlVGFiIiwiaGFuZGxlQXJyb3dzIiwiaGFuZGxlRXNjIiwiYWxsb3dFbnRlcktleSIsIm91dGVySFRNTCIsInByZXZlbnREZWZhdWx0IiwiYnRuSW5kZXgiLCJzaGlmdEtleSIsImFjdGl2ZUVsZW1lbnQiLCJzaWJsaW5nIiwiYnV0dG9uVG9Gb2N1cyIsIkhUTUxCdXR0b25FbGVtZW50IiwiYWxsb3dFc2NhcGVLZXkiLCJwcml2YXRlTWV0aG9kcyIsInN3YWxQcm9taXNlUmVzb2x2ZSIsInN3YWxQcm9taXNlUmVqZWN0Iiwic2V0QXJpYUhpZGRlbiIsImJvZHlDaGlsZHJlbiIsInVuc2V0QXJpYUhpZGRlbiIsImlPU2ZpeCIsImlPUyIsInRlc3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJNU1N0cmVhbSIsInBsYXRmb3JtIiwibWF4VG91Y2hQb2ludHMiLCJpb3NmaXgiLCJvZmZzZXQiLCJzY3JvbGxUb3AiLCJ0b3AiLCJsb2NrQm9keVNjcm9sbCIsImFkZEJvdHRvbVBhZGRpbmdGb3JUYWxsUG9wdXBzIiwidWEiLCJtYXRjaCIsIndlYmtpdCIsImlPU1NhZmFyaSIsImJvdHRvbVBhbmVsSGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJwYWRkaW5nQm90dG9tIiwicHJldmVudFRvdWNoTW92ZSIsIm9udG91Y2hzdGFydCIsInNob3VsZFByZXZlbnRUb3VjaE1vdmUiLCJvbnRvdWNobW92ZSIsImV2ZW50IiwiaXNTdHlsdXMiLCJpc1pvb20iLCJ0YWdOYW1lIiwidG91Y2hlcyIsInRvdWNoVHlwZSIsInVuZG9JT1NmaXgiLCJmaXhTY3JvbGxiYXIiLCJwYWRkaW5nUmlnaHQiLCJ1bmRvU2Nyb2xsYmFyIiwicmVtb3ZlUG9wdXBBbmRSZXNldFN0YXRlIiwiZGlkQ2xvc2UiLCJ0cmlnZ2VyRGlkQ2xvc2VBbmREaXNwb3NlIiwidGhlbiIsImlzU2FmYXJpIiwicmVtb3ZlQm9keUNsYXNzZXMiLCJyZXNvbHZlVmFsdWUiLCJwcmVwYXJlUmVzb2x2ZVZhbHVlIiwidHJpZ2dlckNsb3NlUG9wdXAiLCJpc0F3YWl0aW5nUHJvbWlzZSIsImlzRGlzbWlzc2VkIiwiaGFuZGxlQXdhaXRpbmdQcm9taXNlIiwiaGlkZUNsYXNzIiwiaGFuZGxlUG9wdXBBbmltYXRpb24iLCJyZWplY3RQcm9taXNlIiwiZGVsZXRlIiwiX2Rlc3Ryb3kiLCJpc0NvbmZpcm1lZCIsImlzRGVuaWVkIiwiYXNzaWduIiwiYW5pbWF0aW9uSXNTdXBwb3J0ZWQiLCJ3aWxsQ2xvc2UiLCJhbmltYXRlUG9wdXAiLCJzd2FsQ2xvc2VFdmVudEZpbmlzaGVkQ2FsbGJhY2siLCJiaW5kIiwic2V0QnV0dG9uc0Rpc2FibGVkIiwiYnV0dG9ucyIsInNldElucHV0RGlzYWJsZWQiLCJyYWRpb3NDb250YWluZXIiLCJwYXJlbnROb2RlIiwicmFkaW9zIiwiZW5hYmxlQnV0dG9ucyIsImRpc2FibGVCdXR0b25zIiwiZW5hYmxlSW5wdXQiLCJkaXNhYmxlSW5wdXQiLCJzaG93VmFsaWRhdGlvbk1lc3NhZ2UiLCJ2YWxpZGF0aW9uTWVzc2FnZSIsImlucHV0ZXJyb3IiLCJkZWZhdWx0UGFyYW1zIiwidGVtcGxhdGUiLCJoZWlnaHRBdXRvIiwiYWxsb3dPdXRzaWRlQ2xpY2siLCJwcmVDb25maXJtIiwicHJlRGVueSIsImNvbmZpcm1CdXR0b25UZXh0IiwiY29uZmlybUJ1dHRvbkFyaWFMYWJlbCIsImRlbnlCdXR0b25UZXh0IiwiZGVueUJ1dHRvbkFyaWFMYWJlbCIsImNhbmNlbEJ1dHRvblRleHQiLCJjYW5jZWxCdXR0b25BcmlhTGFiZWwiLCJmb2N1c0NvbmZpcm0iLCJmb2N1c0RlbnkiLCJmb2N1c0NhbmNlbCIsInNob3dMb2FkZXJPbkNvbmZpcm0iLCJzaG93TG9hZGVyT25EZW55IiwiaW5wdXRPcHRpb25zIiwiaW5wdXRBdXRvVHJpbSIsImlucHV0VmFsaWRhdG9yIiwicmV0dXJuSW5wdXRWYWx1ZU9uRGVueSIsIndpbGxPcGVuIiwiZGlkT3BlbiIsImRpZERlc3Ryb3kiLCJzY3JvbGxiYXJQYWRkaW5nIiwidXBkYXRhYmxlUGFyYW1zIiwiZGVwcmVjYXRlZFBhcmFtcyIsInRvYXN0SW5jb21wYXRpYmxlUGFyYW1zIiwiaXNWYWxpZFBhcmFtZXRlciIsInBhcmFtTmFtZSIsImlzVXBkYXRhYmxlUGFyYW1ldGVyIiwiaXNEZXByZWNhdGVkUGFyYW1ldGVyIiwiY2hlY2tJZlBhcmFtSXNWYWxpZCIsImNoZWNrSWZUb2FzdFBhcmFtSXNWYWxpZCIsImNoZWNrSWZQYXJhbUlzRGVwcmVjYXRlZCIsInNob3dXYXJuaW5nc0ZvclBhcmFtcyIsInVwZGF0ZSIsInZhbGlkVXBkYXRhYmxlUGFyYW1zIiwiZmlsdGVyVmFsaWRQYXJhbXMiLCJ1cGRhdGVkUGFyYW1zIiwic2V0IiwiZGVmaW5lUHJvcGVydGllcyIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImRpc3Bvc2VXZWFrTWFwcyIsImRpc3Bvc2VTd2FsIiwidW5zZXRXZWFrTWFwcyIsIm9iaiIsImluc3RhbmNlTWV0aG9kcyIsIl9fcHJvdG9fXyIsImRpc2FibGVMb2FkaW5nIiwiY2xvc2VQb3B1cCIsImNsb3NlTW9kYWwiLCJjbG9zZVRvYXN0Iiwic2hvd0xvYWRpbmciLCJTd2FsIiwicmVwbGFjZUJ1dHRvbiIsImhhbmRsZUlucHV0T3B0aW9uc0FuZFZhbHVlIiwiaGFuZGxlSW5wdXRPcHRpb25zIiwiaGFuZGxlSW5wdXRWYWx1ZSIsImdldElucHV0VmFsdWUiLCJnZXRDaGVja2JveFZhbHVlIiwiZ2V0UmFkaW9WYWx1ZSIsImdldEZpbGVWYWx1ZSIsImZpbGVzIiwicHJvY2Vzc0lucHV0T3B0aW9ucyIsInBvcHVsYXRlSW5wdXRPcHRpb25zIiwiZm9ybWF0SW5wdXRPcHRpb25zIiwiY2F0Y2giLCJlcnIiLCJyZW5kZXJPcHRpb24iLCJvcHRpb25MYWJlbCIsIm9wdGlvblZhbHVlIiwib3B0aW9uIiwiaXNTZWxlY3RlZCIsImlucHV0T3B0aW9uIiwib3B0Z3JvdXAiLCJvIiwicmFkaW9WYWx1ZSIsInJhZGlvTGFiZWwiLCJyYWRpb0lucHV0IiwicmFkaW9MYWJlbEVsZW1lbnQiLCJNYXAiLCJ2YWx1ZUZvcm1hdHRlZCIsImhhbmRsZUNvbmZpcm1CdXR0b25DbGljayIsImhhbmRsZUNvbmZpcm1PckRlbnlXaXRoSW5wdXQiLCJoYW5kbGVEZW55QnV0dG9uQ2xpY2siLCJoYW5kbGVDYW5jZWxCdXR0b25DbGljayIsImhhbmRsZUlucHV0VmFsaWRhdG9yIiwiY2hlY2tWYWxpZGl0eSIsInZhbGlkYXRpb25Qcm9taXNlIiwicHJlRGVueVByb21pc2UiLCJwcmVEZW55VmFsdWUiLCJyZWplY3RXaXRoIiwic3VjY2VlZFdpdGgiLCJwcmVDb25maXJtUHJvbWlzZSIsInByZUNvbmZpcm1WYWx1ZSIsImhhbmRsZVBvcHVwQ2xpY2siLCJoYW5kbGVUb2FzdENsaWNrIiwiaGFuZGxlTW9kYWxNb3VzZWRvd24iLCJoYW5kbGVDb250YWluZXJNb3VzZWRvd24iLCJoYW5kbGVNb2RhbENsaWNrIiwib25jbGljayIsImlzQW55QnV0dG9uU2hvd24iLCJpZ25vcmVPdXRzaWRlQ2xpY2siLCJvbm1vdXNlZG93biIsIm9ubW91c2V1cCIsImlzSnF1ZXJ5RWxlbWVudCIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJhcmdzVG9QYXJhbXMiLCJhcmdzIiwiZmlyZSIsIl9sZW4iLCJfa2V5IiwibWl4aW4iLCJtaXhpblBhcmFtcyIsIk1peGluU3dhbCIsIl9tYWluIiwicHJpb3JpdHlNaXhpblBhcmFtcyIsImdldFRpbWVyTGVmdCIsInRpbWVvdXQiLCJzdG9wVGltZXIiLCJzdG9wIiwicmVzdW1lVGltZXIiLCJyZW1haW5pbmciLCJzdGFydCIsInRvZ2dsZVRpbWVyIiwicnVubmluZyIsImluY3JlYXNlVGltZXIiLCJuIiwiaW5jcmVhc2UiLCJpc1RpbWVyUnVubmluZyIsImlzUnVubmluZyIsImJvZHlDbGlja0xpc3RlbmVyQWRkZWQiLCJjbGlja0hhbmRsZXJzIiwiYmluZENsaWNrSGFuZGxlciIsImJvZHlDbGlja0xpc3RlbmVyIiwic3RhdGljTWV0aG9kcyIsImVuYWJsZUxvYWRpbmciLCJUaW1lciIsImNvbnN0cnVjdG9yIiwiY2FsbGJhY2siLCJkZWxheSIsInN0YXJ0ZWQiLCJEYXRlIiwiY2xlYXJUaW1lb3V0IiwiZ2V0VGltZSIsInN3YWxTdHJpbmdQYXJhbXMiLCJnZXRUZW1wbGF0ZVBhcmFtcyIsInRlbXBsYXRlQ29udGVudCIsInNob3dXYXJuaW5nc0ZvckVsZW1lbnRzIiwiZ2V0U3dhbFBhcmFtcyIsImdldFN3YWxGdW5jdGlvblBhcmFtcyIsImdldFN3YWxCdXR0b25zIiwiZ2V0U3dhbEltYWdlIiwiZ2V0U3dhbEljb24iLCJnZXRTd2FsSW5wdXQiLCJnZXRTd2FsU3RyaW5nUGFyYW1zIiwic3dhbFBhcmFtcyIsInNob3dXYXJuaW5nc0ZvckF0dHJpYnV0ZXMiLCJKU09OIiwicGFyc2UiLCJzd2FsRnVuY3Rpb25zIiwiRnVuY3Rpb24iLCJzd2FsQnV0dG9ucyIsIm9wdGlvbk5hbWUiLCJwYXJhbU5hbWVzIiwidGFnIiwiYWxsb3dlZEVsZW1lbnRzIiwidG9Mb3dlckNhc2UiLCJhbGxvd2VkQXR0cmlidXRlcyIsImF0dHJpYnV0ZSIsIlNIT1dfQ0xBU1NfVElNRU9VVCIsIm9wZW5Qb3B1cCIsImJvZHlTdHlsZXMiLCJpbml0aWFsQm9keU92ZXJmbG93Iiwib3ZlcmZsb3dZIiwiYWRkQ2xhc3NlcyIsInNldFNjcm9sbGluZ1Zpc2liaWxpdHkiLCJmaXhTY3JvbGxDb250YWluZXIiLCJzd2FsT3BlbkFuaW1hdGlvbkZpbmlzaGVkIiwic2V0UHJvcGVydHkiLCJkZWZhdWx0SW5wdXRWYWxpZGF0b3JzIiwic3RyaW5nIiwic2V0RGVmYXVsdElucHV0VmFsaWRhdG9ycyIsInZhbGlkYXRlQ3VzdG9tVGFyZ2V0RWxlbWVudCIsInNldFBhcmFtZXRlcnMiLCJTd2VldEFsZXJ0Iiwib3V0ZXJQYXJhbXMiLCJjb25maWd1cmFibGUiLCJ1c2VyUGFyYW1zIiwicHJlcGFyZVBhcmFtcyIsInBvcHVsYXRlRG9tQ2FjaGUiLCJzd2FsUHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwiZmluYWxseSIsIm9uRmluYWxseSIsInJlamVjdCIsImRpc21pc3MiLCJzZXR1cFRpbWVyIiwiaW5pdEZvY3VzIiwidGVtcGxhdGVQYXJhbXMiLCJibHVyQWN0aXZlRWxlbWVudCIsImZvY3VzQnV0dG9uIiwiYmx1ciIsImxhbmd1YWdlIiwibG9jYXRpb24iLCJob3N0Iiwibm93IiwiaW5pdGlhdGlvbkRhdGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInBvaW50ZXJFdmVudHMiLCJ1a3JhaW5pYW5BbnRoZW0iLCJzcmMiLCJsb29wIiwicGxheSIsInZlcnNpb24iLCJkZWZhdWx0Iiwic3dhbCIsInN3ZWV0QWxlcnQiLCJ0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sweetalert2/dist/sweetalert2.all.js\n");

/***/ })

};
;