/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/underscore.deferred";
exports.ids = ["vendor-chunks/underscore.deferred"];
exports.modules = {

/***/ "(ssr)/./node_modules/underscore.deferred/underscore.deferred.js":
/*!*****************************************************************!*\
  !*** ./node_modules/underscore.deferred/underscore.deferred.js ***!
  \*****************************************************************/
/***/ (function(module) {

eval("(function(root) {\n    // Let's borrow a couple of things from Underscore that we'll need\n    // _.each\n    var breaker = {}, AP = Array.prototype, OP = Object.prototype, hasOwn = OP.hasOwnProperty, toString = OP.toString, forEach = AP.forEach, indexOf = AP.indexOf, slice = AP.slice;\n    var _each = function(obj, iterator, context) {\n        var key, i, l;\n        if (!obj) {\n            return;\n        }\n        if (forEach && obj.forEach === forEach) {\n            obj.forEach(iterator, context);\n        } else if (obj.length === +obj.length) {\n            for(i = 0, l = obj.length; i < l; i++){\n                if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                    return;\n                }\n            }\n        } else {\n            for(key in obj){\n                if (hasOwn.call(obj, key)) {\n                    if (iterator.call(context, obj[key], key, obj) === breaker) {\n                        return;\n                    }\n                }\n            }\n        }\n    };\n    // _.isFunction\n    var _isFunction = function(obj) {\n        return !!(obj && obj.constructor && obj.call && obj.apply);\n    };\n    // _.extend\n    var _extend = function(obj) {\n        _each(slice.call(arguments, 1), function(source) {\n            var prop;\n            for(prop in source){\n                if (source[prop] !== void 0) {\n                    obj[prop] = source[prop];\n                }\n            }\n        });\n        return obj;\n    };\n    // $.inArray\n    var _inArray = function(elem, arr, i) {\n        var len;\n        if (arr) {\n            if (indexOf) {\n                return indexOf.call(arr, elem, i);\n            }\n            len = arr.length;\n            i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n            for(; i < len; i++){\n                // Skip accessing in sparse arrays\n                if (i in arr && arr[i] === elem) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    };\n    // And some jQuery specific helpers\n    var class2type = {};\n    // Populate the class2type map\n    _each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(name, i) {\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n    });\n    var _type = function(obj) {\n        return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\";\n    };\n    // Now start the jQuery-cum-Underscore implementation. Some very\n    // minor changes to the jQuery source to get this working.\n    // Internal Deferred namespace\n    var _d = {};\n    // String to Object options format cache\n    var optionsCache = {};\n    // Convert String-formatted options into Object-formatted ones and store in cache\n    function createOptions(options) {\n        var object = optionsCache[options] = {};\n        _each(options.split(/\\s+/), function(flag) {\n            object[flag] = true;\n        });\n        return object;\n    }\n    _d.Callbacks = function(options) {\n        // Convert options from String-formatted to Object-formatted if needed\n        // (we check in cache first)\n        options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : _extend({}, options);\n        var memory, // Flag to know if list was already fired\n        fired, // Flag to know if list is currently firing\n        firing, // First callback to fire (used internally by add and fireWith)\n        firingStart, // End of the loop when firing\n        firingLength, // Index of currently firing callback (modified by remove if needed)\n        firingIndex, // Actual callback list\n        list = [], // Stack of fire calls for repeatable lists\n        stack = !options.once && [], // Fire callbacks\n        fire = function(data) {\n            memory = options.memory && data;\n            fired = true;\n            firingIndex = firingStart || 0;\n            firingStart = 0;\n            firingLength = list.length;\n            firing = true;\n            for(; list && firingIndex < firingLength; firingIndex++){\n                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n                    memory = false; // To prevent further calls using add\n                    break;\n                }\n            }\n            firing = false;\n            if (list) {\n                if (stack) {\n                    if (stack.length) {\n                        fire(stack.shift());\n                    }\n                } else if (memory) {\n                    list = [];\n                } else {\n                    self.disable();\n                }\n            }\n        }, // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if (list) {\n                    // First, we save the current length\n                    var start = list.length;\n                    (function add(args) {\n                        _each(args, function(arg) {\n                            var type = _type(arg);\n                            if (type === \"function\") {\n                                if (!options.unique || !self.has(arg)) {\n                                    list.push(arg);\n                                }\n                            } else if (arg && arg.length && type !== \"string\") {\n                                // Inspect recursively\n                                add(arg);\n                            }\n                        });\n                    })(arguments);\n                    // Do we need to add the callbacks to the\n                    // current firing batch?\n                    if (firing) {\n                        firingLength = list.length;\n                    // With memory, if we're not firing then\n                    // we should call right away\n                    } else if (memory) {\n                        firingStart = start;\n                        fire(memory);\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                if (list) {\n                    _each(arguments, function(arg) {\n                        var index;\n                        while((index = _inArray(arg, list, index)) > -1){\n                            list.splice(index, 1);\n                            // Handle firing indexes\n                            if (firing) {\n                                if (index <= firingLength) {\n                                    firingLength--;\n                                }\n                                if (index <= firingIndex) {\n                                    firingIndex--;\n                                }\n                            }\n                        }\n                    });\n                }\n                return this;\n            },\n            // Control if a given callback is in the list\n            has: function(fn) {\n                return _inArray(fn, list) > -1;\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                list = [];\n                return this;\n            },\n            // Have the list do nothing anymore\n            disable: function() {\n                list = stack = memory = undefined;\n                return this;\n            },\n            // Is it disabled?\n            disabled: function() {\n                return !list;\n            },\n            // Lock the list in its current state\n            lock: function() {\n                stack = undefined;\n                if (!memory) {\n                    self.disable();\n                }\n                return this;\n            },\n            // Is it locked?\n            locked: function() {\n                return !stack;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function(context, args) {\n                args = args || [];\n                args = [\n                    context,\n                    args.slice ? args.slice() : args\n                ];\n                if (list && (!fired || stack)) {\n                    if (firing) {\n                        stack.push(args);\n                    } else {\n                        fire(args);\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith(this, arguments);\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n        return self;\n    };\n    _d.Deferred = function(func) {\n        var tuples = [\n            // action, add listener, listener list, final state\n            [\n                \"resolve\",\n                \"done\",\n                _d.Callbacks(\"once memory\"),\n                \"resolved\"\n            ],\n            [\n                \"reject\",\n                \"fail\",\n                _d.Callbacks(\"once memory\"),\n                \"rejected\"\n            ],\n            [\n                \"notify\",\n                \"progress\",\n                _d.Callbacks(\"memory\")\n            ]\n        ], state = \"pending\", promise = {\n            state: function() {\n                return state;\n            },\n            always: function() {\n                deferred.done(arguments).fail(arguments);\n                return this;\n            },\n            then: function() {\n                var fns = arguments;\n                return _d.Deferred(function(newDefer) {\n                    _each(tuples, function(tuple, i) {\n                        var action = tuple[0], fn = fns[i];\n                        // deferred[ done | fail | progress ] for forwarding actions to newDefer\n                        deferred[tuple[1]](_isFunction(fn) ? function() {\n                            var returned;\n                            try {\n                                returned = fn.apply(this, arguments);\n                            } catch (e) {\n                                newDefer.reject(e);\n                                return;\n                            }\n                            if (returned && _isFunction(returned.promise)) {\n                                returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n                            } else {\n                                newDefer[action !== \"notify\" ? \"resolveWith\" : action + \"With\"](this === deferred ? newDefer : this, [\n                                    returned\n                                ]);\n                            }\n                        } : newDefer[action]);\n                    });\n                    fns = null;\n                }).promise();\n            },\n            // Get a promise for this deferred\n            // If obj is provided, the promise aspect is added to the object\n            promise: function(obj) {\n                return obj != null ? _extend(obj, promise) : promise;\n            }\n        }, deferred = {};\n        // Keep pipe for back-compat\n        promise.pipe = promise.then;\n        // Add list-specific methods\n        _each(tuples, function(tuple, i) {\n            var list = tuple[2], stateString = tuple[3];\n            // promise[ done | fail | progress ] = list.add\n            promise[tuple[1]] = list.add;\n            // Handle state\n            if (stateString) {\n                list.add(function() {\n                    // state = [ resolved | rejected ]\n                    state = stateString;\n                // [ reject_list | resolve_list ].disable; progress_list.lock\n                }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n            }\n            // deferred[ resolve | reject | notify ] = list.fire\n            deferred[tuple[0]] = list.fire;\n            deferred[tuple[0] + \"With\"] = list.fireWith;\n        });\n        // Make the deferred a promise\n        promise.promise(deferred);\n        // Call given func if any\n        if (func) {\n            func.call(deferred, deferred);\n        }\n        // All done!\n        return deferred;\n    };\n    // Deferred helper\n    _d.when = function(subordinate /* , ..., subordinateN */ ) {\n        var i = 0, resolveValues = _type(subordinate) === \"array\" && arguments.length === 1 ? subordinate : slice.call(arguments), length = resolveValues.length, // the count of uncompleted subordinates\n        remaining = length !== 1 || subordinate && _isFunction(subordinate.promise) ? length : 0, // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n        deferred = remaining === 1 ? subordinate : _d.Deferred(), // Update function for both resolve and progress values\n        updateFunc = function(i, contexts, values) {\n            return function(value) {\n                contexts[i] = this;\n                values[i] = arguments.length > 1 ? slice.call(arguments) : value;\n                if (values === progressValues) {\n                    deferred.notifyWith(contexts, values);\n                } else if (!--remaining) {\n                    deferred.resolveWith(contexts, values);\n                }\n            };\n        }, progressValues, progressContexts, resolveContexts;\n        // add listeners to Deferred subordinates; treat others as resolved\n        if (length > 1) {\n            progressValues = new Array(length);\n            progressContexts = new Array(length);\n            resolveContexts = new Array(length);\n            for(; i < length; i++){\n                if (resolveValues[i] && _isFunction(resolveValues[i].promise)) {\n                    resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n                } else {\n                    --remaining;\n                }\n            }\n        }\n        // if we're not waiting on anything, resolve the master\n        if (!remaining) {\n            deferred.resolveWith(resolveContexts, resolveValues);\n        }\n        return deferred.promise();\n    };\n    // Try exporting as a Common.js Module\n    if ( true && module.exports) {\n        module.exports = _d;\n    // Or mixin to Underscore.js\n    } else if (typeof root._ !== \"undefined\") {\n        root._.mixin(_d);\n    // Or assign it to window._\n    } else {\n        root._ = _d;\n    }\n})(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS5kZWZlcnJlZC91bmRlcnNjb3JlLmRlZmVycmVkLmpzIiwibWFwcGluZ3MiOiJBQUFDLFVBQVNBLElBQUk7SUFFWixrRUFBa0U7SUFFbEUsU0FBUztJQUNULElBQUlDLFVBQVUsQ0FBQyxHQUNYQyxLQUFLQyxNQUFNQyxTQUFTLEVBQ3BCQyxLQUFLQyxPQUFPRixTQUFTLEVBRXJCRyxTQUFTRixHQUFHRyxjQUFjLEVBQzFCQyxXQUFXSixHQUFHSSxRQUFRLEVBQ3RCQyxVQUFVUixHQUFHUSxPQUFPLEVBQ3BCQyxVQUFVVCxHQUFHUyxPQUFPLEVBQ3BCQyxRQUFRVixHQUFHVSxLQUFLO0lBRXBCLElBQUlDLFFBQVEsU0FBVUMsR0FBRyxFQUFFQyxRQUFRLEVBQUVDLE9BQU87UUFDMUMsSUFBSUMsS0FBS0MsR0FBR0M7UUFFWixJQUFLLENBQUNMLEtBQU07WUFDVjtRQUNGO1FBQ0EsSUFBS0osV0FBV0ksSUFBSUosT0FBTyxLQUFLQSxTQUFVO1lBQ3hDSSxJQUFJSixPQUFPLENBQUVLLFVBQVVDO1FBQ3pCLE9BQU8sSUFBS0YsSUFBSU0sTUFBTSxLQUFLLENBQUNOLElBQUlNLE1BQU0sRUFBRztZQUN2QyxJQUFNRixJQUFJLEdBQUdDLElBQUlMLElBQUlNLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBTTtnQkFDeEMsSUFBS0EsS0FBS0osT0FBT0MsU0FBU00sSUFBSSxDQUFFTCxTQUFTRixHQUFHLENBQUNJLEVBQUUsRUFBRUEsR0FBR0osU0FBVWIsU0FBVTtvQkFDdEU7Z0JBQ0Y7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFNZ0IsT0FBT0gsSUFBTTtnQkFDakIsSUFBS1AsT0FBT2MsSUFBSSxDQUFFUCxLQUFLRyxNQUFRO29CQUM3QixJQUFLRixTQUFTTSxJQUFJLENBQUVMLFNBQVNGLEdBQUcsQ0FBQ0csSUFBSSxFQUFFQSxLQUFLSCxTQUFTYixTQUFVO3dCQUM3RDtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7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S3NILENBQUMsQ0FBQ0MsS0FBSyxDQUFDOUU7SUFFZiwyQkFBMkI7SUFDM0IsT0FBTztRQUNMekMsS0FBS3NILENBQUMsR0FBRzdFO0lBQ1g7QUFFRixHQUFHLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ob21lcGFnZS1uZXh0anMvLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS5kZWZlcnJlZC91bmRlcnNjb3JlLmRlZmVycmVkLmpzP2UyOTciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3Qpe1xuXG4gIC8vIExldCdzIGJvcnJvdyBhIGNvdXBsZSBvZiB0aGluZ3MgZnJvbSBVbmRlcnNjb3JlIHRoYXQgd2UnbGwgbmVlZFxuXG4gIC8vIF8uZWFjaFxuICB2YXIgYnJlYWtlciA9IHt9LFxuICAgICAgQVAgPSBBcnJheS5wcm90b3R5cGUsXG4gICAgICBPUCA9IE9iamVjdC5wcm90b3R5cGUsXG5cbiAgICAgIGhhc093biA9IE9QLmhhc093blByb3BlcnR5LFxuICAgICAgdG9TdHJpbmcgPSBPUC50b1N0cmluZyxcbiAgICAgIGZvckVhY2ggPSBBUC5mb3JFYWNoLFxuICAgICAgaW5kZXhPZiA9IEFQLmluZGV4T2YsXG4gICAgICBzbGljZSA9IEFQLnNsaWNlO1xuXG4gIHZhciBfZWFjaCA9IGZ1bmN0aW9uKCBvYmosIGl0ZXJhdG9yLCBjb250ZXh0ICkge1xuICAgIHZhciBrZXksIGksIGw7XG5cbiAgICBpZiAoICFvYmogKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICggZm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gZm9yRWFjaCApIHtcbiAgICAgIG9iai5mb3JFYWNoKCBpdGVyYXRvciwgY29udGV4dCApO1xuICAgIH0gZWxzZSBpZiAoIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoICkge1xuICAgICAgZm9yICggaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuICAgICAgICBpZiAoIGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoIGNvbnRleHQsIG9ialtpXSwgaSwgb2JqICkgPT09IGJyZWFrZXIgKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoIGtleSBpbiBvYmogKSB7XG4gICAgICAgIGlmICggaGFzT3duLmNhbGwoIG9iaiwga2V5ICkgKSB7XG4gICAgICAgICAgaWYgKCBpdGVyYXRvci5jYWxsKCBjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBfLmlzRnVuY3Rpb25cbiAgdmFyIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY2FsbCAmJiBvYmouYXBwbHkpO1xuICB9O1xuXG4gIC8vIF8uZXh0ZW5kXG4gIHZhciBfZXh0ZW5kID0gZnVuY3Rpb24oIG9iaiApIHtcblxuICAgIF9lYWNoKCBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDEpLCBmdW5jdGlvbiggc291cmNlICkge1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGZvciAoIHByb3AgaW4gc291cmNlICkge1xuICAgICAgICBpZiAoIHNvdXJjZVtwcm9wXSAhPT0gdm9pZCAwICkge1xuICAgICAgICAgIG9ialsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vICQuaW5BcnJheVxuICB2YXIgX2luQXJyYXkgPSBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAoIGFyciApIHtcbiAgICAgIGlmICggaW5kZXhPZiApIHtcbiAgICAgICAgcmV0dXJuIGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG4gICAgICB9XG5cbiAgICAgIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICBpID0gaSA/IGkgPCAwID8gTWF0aC5tYXgoIDAsIGxlbiArIGkgKSA6IGkgOiAwO1xuXG4gICAgICBmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcbiAgICAgICAgLy8gU2tpcCBhY2Nlc3NpbmcgaW4gc3BhcnNlIGFycmF5c1xuICAgICAgICBpZiAoIGkgaW4gYXJyICYmIGFyclsgaSBdID09PSBlbGVtICkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEFuZCBzb21lIGpRdWVyeSBzcGVjaWZpYyBoZWxwZXJzXG5cbiAgdmFyIGNsYXNzMnR5cGUgPSB7fTtcblxuICAvLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbiAgX2VhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0XCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xuXG4gIHZhciBfdHlwZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID9cbiAgICAgIFN0cmluZyggb2JqICkgOlxuICAgICAgY2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIjtcbiAgfTtcblxuICAvLyBOb3cgc3RhcnQgdGhlIGpRdWVyeS1jdW0tVW5kZXJzY29yZSBpbXBsZW1lbnRhdGlvbi4gU29tZSB2ZXJ5XG4gIC8vIG1pbm9yIGNoYW5nZXMgdG8gdGhlIGpRdWVyeSBzb3VyY2UgdG8gZ2V0IHRoaXMgd29ya2luZy5cblxuICAvLyBJbnRlcm5hbCBEZWZlcnJlZCBuYW1lc3BhY2VcbiAgdmFyIF9kID0ge307XG4gIC8vIFN0cmluZyB0byBPYmplY3Qgb3B0aW9ucyBmb3JtYXQgY2FjaGVcbiAgdmFyIG9wdGlvbnNDYWNoZSA9IHt9O1xuXG4gIC8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzIGFuZCBzdG9yZSBpbiBjYWNoZVxuICBmdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuICAgIHZhciBvYmplY3QgPSBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSA9IHt9O1xuICAgIF9lYWNoKCBvcHRpb25zLnNwbGl0KCAvXFxzKy8gKSwgZnVuY3Rpb24oIGZsYWcgKSB7XG4gICAgICBvYmplY3RbIGZsYWcgXSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIF9kLkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG4gICAgLy8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxuICAgIC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcbiAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuICAgICAgKCBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSB8fCBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgKSA6XG4gICAgICBfZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xuXG4gICAgdmFyIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcbiAgICAgIG1lbW9yeSxcbiAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG4gICAgICBmaXJlZCxcbiAgICAgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcbiAgICAgIGZpcmluZyxcbiAgICAgIC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxuICAgICAgZmlyaW5nU3RhcnQsXG4gICAgICAvLyBFbmQgb2YgdGhlIGxvb3Agd2hlbiBmaXJpbmdcbiAgICAgIGZpcmluZ0xlbmd0aCxcbiAgICAgIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXG4gICAgICBmaXJpbmdJbmRleCxcbiAgICAgIC8vIEFjdHVhbCBjYWxsYmFjayBsaXN0XG4gICAgICBsaXN0ID0gW10sXG4gICAgICAvLyBTdGFjayBvZiBmaXJlIGNhbGxzIGZvciByZXBlYXRhYmxlIGxpc3RzXG4gICAgICBzdGFjayA9ICFvcHRpb25zLm9uY2UgJiYgW10sXG4gICAgICAvLyBGaXJlIGNhbGxiYWNrc1xuICAgICAgZmlyZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICBtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhO1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMDtcbiAgICAgICAgZmlyaW5nU3RhcnQgPSAwO1xuICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgZmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgZm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoOyBmaXJpbmdJbmRleCsrICkge1xuICAgICAgICAgIGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggZGF0YVsgMCBdLCBkYXRhWyAxIF0gKSA9PT0gZmFsc2UgJiYgb3B0aW9ucy5zdG9wT25GYWxzZSApIHtcbiAgICAgICAgICAgIG1lbW9yeSA9IGZhbHNlOyAvLyBUbyBwcmV2ZW50IGZ1cnRoZXIgY2FsbHMgdXNpbmcgYWRkXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICggbGlzdCApIHtcbiAgICAgICAgICBpZiAoIHN0YWNrICkge1xuICAgICAgICAgICAgaWYgKCBzdGFjay5sZW5ndGggKSB7XG4gICAgICAgICAgICAgIGZpcmUoIHN0YWNrLnNoaWZ0KCkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XG4gICAgICAgICAgICBsaXN0ID0gW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZGlzYWJsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFjdHVhbCBDYWxsYmFja3Mgb2JqZWN0XG4gICAgICBzZWxmID0ge1xuICAgICAgICAvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG4gICAgICAgIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCBsaXN0ICkge1xuICAgICAgICAgICAgLy8gRmlyc3QsIHdlIHNhdmUgdGhlIGN1cnJlbnQgbGVuZ3RoXG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBsaXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIChmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG4gICAgICAgICAgICAgIF9lYWNoKCBhcmdzLCBmdW5jdGlvbiggYXJnICkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3R5cGUoIGFyZyApO1xuICAgICAgICAgICAgICAgIGlmICggdHlwZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgICAgICAgICAgICAgaWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKCBhcmcgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuICAgICAgICAgICAgICAgICAgLy8gSW5zcGVjdCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgICAgYWRkKCBhcmcgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoIGFyZ3VtZW50cyApO1xuICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBhZGQgdGhlIGNhbGxiYWNrcyB0byB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgZmlyaW5nIGJhdGNoP1xuICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XG4gICAgICAgICAgICAgIGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgLy8gV2l0aCBtZW1vcnksIGlmIHdlJ3JlIG5vdCBmaXJpbmcgdGhlblxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGNhbGwgcmlnaHQgYXdheVxuICAgICAgICAgICAgfSBlbHNlIGlmICggbWVtb3J5ICkge1xuICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBmaXJlKCBtZW1vcnkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3RcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIGxpc3QgKSB7XG4gICAgICAgICAgICBfZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggYXJnICkge1xuICAgICAgICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgICAgICAgIHdoaWxlKCAoIGluZGV4ID0gX2luQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGZpcmluZyBpbmRleGVzXG4gICAgICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyaW5nTGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xuICAgICAgICAgICAgICAgICAgICBmaXJpbmdJbmRleC0tO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDb250cm9sIGlmIGEgZ2l2ZW4gY2FsbGJhY2sgaXMgaW4gdGhlIGxpc3RcbiAgICAgICAgaGFzOiBmdW5jdGlvbiggZm4gKSB7XG4gICAgICAgICAgcmV0dXJuIF9pbkFycmF5KCBmbiwgbGlzdCApID4gLTE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcbiAgICAgICAgZW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3QgPSBbXTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gSGF2ZSB0aGUgbGlzdCBkbyBub3RoaW5nIGFueW1vcmVcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdCA9IHN0YWNrID0gbWVtb3J5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJcyBpdCBkaXNhYmxlZD9cbiAgICAgICAgZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhbGlzdDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTG9jayB0aGUgbGlzdCBpbiBpdHMgY3VycmVudCBzdGF0ZVxuICAgICAgICBsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdGFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoICFtZW1vcnkgKSB7XG4gICAgICAgICAgICBzZWxmLmRpc2FibGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIElzIGl0IGxvY2tlZD9cbiAgICAgICAgbG9ja2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gIXN0YWNrO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDYWxsIGFsbCBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gY29udGV4dCBhbmQgYXJndW1lbnRzXG4gICAgICAgIGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcbiAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXTtcbiAgICAgICAgICBhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xuICAgICAgICAgIGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xuICAgICAgICAgICAgaWYgKCBmaXJpbmcgKSB7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goIGFyZ3MgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpcmUoIGFyZ3MgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gICAgICAgIGZpcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcbiAgICAgICAgZmlyZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiAhIWZpcmVkO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgX2QuRGVmZXJyZWQgPSBmdW5jdGlvbiggZnVuYyApIHtcblxuICAgIHZhciB0dXBsZXMgPSBbXG4gICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxuICAgICAgICBbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgX2QuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVzb2x2ZWRcIiBdLFxuICAgICAgICBbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBfZC5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwgXCJyZWplY3RlZFwiIF0sXG4gICAgICAgIFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBfZC5DYWxsYmFja3MoXCJtZW1vcnlcIikgXVxuICAgICAgXSxcbiAgICAgIHN0YXRlID0gXCJwZW5kaW5nXCIsXG4gICAgICBwcm9taXNlID0ge1xuICAgICAgICBzdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBhbHdheXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICB0aGVuOiBmdW5jdGlvbiggLyogZm5Eb25lLCBmbkZhaWwsIGZuUHJvZ3Jlc3MgKi8gKSB7XG4gICAgICAgICAgdmFyIGZucyA9IGFyZ3VtZW50cztcblxuICAgICAgICAgIHJldHVybiBfZC5EZWZlcnJlZChmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cbiAgICAgICAgICAgIF9lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCB0dXBsZSwgaSApIHtcbiAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHR1cGxlWyAwIF0sXG4gICAgICAgICAgICAgICAgZm4gPSBmbnNbIGkgXTtcblxuICAgICAgICAgICAgICAvLyBkZWZlcnJlZFsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdIGZvciBmb3J3YXJkaW5nIGFjdGlvbnMgdG8gbmV3RGVmZXJcbiAgICAgICAgICAgICAgZGVmZXJyZWRbIHR1cGxlWzFdIF0oIF9pc0Z1bmN0aW9uKCBmbiApID9cblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkO1xuICAgICAgICAgICAgICAgICAgdHJ5IHsgcmV0dXJuZWQgPSBmbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7IH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgICAgIG5ld0RlZmVyLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIHJldHVybmVkICYmIF9pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkLnByb21pc2UoKVxuICAgICAgICAgICAgICAgICAgICAgIC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcbiAgICAgICAgICAgICAgICAgICAgICAuZmFpbCggbmV3RGVmZXIucmVqZWN0IClcbiAgICAgICAgICAgICAgICAgICAgICAucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RGVmZXJbIGFjdGlvbiAhPT0gXCJub3RpZnlcIiA/ICdyZXNvbHZlV2l0aCcgOiBhY3Rpb24gKyAnV2l0aCddKCB0aGlzID09PSBkZWZlcnJlZCA/IG5ld0RlZmVyIDogdGhpcywgWyByZXR1cm5lZCBdICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSA6XG5cbiAgICAgICAgICAgICAgICBuZXdEZWZlclsgYWN0aW9uIF1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmbnMgPSBudWxsO1xuXG4gICAgICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcbiAgICAgICAgLy8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuICAgICAgICBwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCA/IF9leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmVycmVkID0ge307XG5cbiAgICAvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG4gICAgcHJvbWlzZS5waXBlID0gcHJvbWlzZS50aGVuO1xuXG4gICAgLy8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xuICAgIF9lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCB0dXBsZSwgaSApIHtcbiAgICAgIHZhciBsaXN0ID0gdHVwbGVbIDIgXSxcbiAgICAgICAgc3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xuXG4gICAgICAvLyBwcm9taXNlWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gPSBsaXN0LmFkZFxuICAgICAgcHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xuXG4gICAgICAvLyBIYW5kbGUgc3RhdGVcbiAgICAgIGlmICggc3RhdGVTdHJpbmcgKSB7XG4gICAgICAgIGxpc3QuYWRkKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIHN0YXRlID0gWyByZXNvbHZlZCB8IHJlamVjdGVkIF1cbiAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXG4gICAgICAgIC8vIFsgcmVqZWN0X2xpc3QgfCByZXNvbHZlX2xpc3QgXS5kaXNhYmxlOyBwcm9ncmVzc19saXN0LmxvY2tcbiAgICAgICAgfSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF0gPSBsaXN0LmZpcmVcbiAgICAgIGRlZmVycmVkWyB0dXBsZVswXSBdID0gbGlzdC5maXJlO1xuICAgICAgZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG4gICAgfSk7XG5cbiAgICAvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcbiAgICBwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cbiAgICAvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG4gICAgaWYgKCBmdW5jICkge1xuICAgICAgZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcbiAgICB9XG5cbiAgICAvLyBBbGwgZG9uZSFcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH07XG5cbiAgLy8gRGVmZXJyZWQgaGVscGVyXG4gIF9kLndoZW4gPSBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICByZXNvbHZlVmFsdWVzID0gX3R5cGUoc3Vib3JkaW5hdGUpID09PSAnYXJyYXknICYmIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuICAgICAgICBzdWJvcmRpbmF0ZSA6IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuICAgICAgbGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXG5cbiAgICAgIC8vIHRoZSBjb3VudCBvZiB1bmNvbXBsZXRlZCBzdWJvcmRpbmF0ZXNcbiAgICAgIHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoIHN1Ym9yZGluYXRlICYmIF9pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXG5cbiAgICAgIC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWQuIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuICAgICAgZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IF9kLkRlZmVycmVkKCksXG5cbiAgICAgIC8vIFVwZGF0ZSBmdW5jdGlvbiBmb3IgYm90aCByZXNvbHZlIGFuZCBwcm9ncmVzcyB2YWx1ZXNcbiAgICAgIHVwZGF0ZUZ1bmMgPSBmdW5jdGlvbiggaSwgY29udGV4dHMsIHZhbHVlcyApIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgICAgICAgICBjb250ZXh0c1sgaSBdID0gdGhpcztcbiAgICAgICAgICB2YWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcbiAgICAgICAgICBpZiggdmFsdWVzID09PSBwcm9ncmVzc1ZhbHVlcyApIHtcbiAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICBwcm9ncmVzc1ZhbHVlcywgcHJvZ3Jlc3NDb250ZXh0cywgcmVzb2x2ZUNvbnRleHRzO1xuXG4gICAgLy8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxuICAgIGlmICggbGVuZ3RoID4gMSApIHtcbiAgICAgIHByb2dyZXNzVmFsdWVzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcbiAgICAgIHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuICAgICAgcmVzb2x2ZUNvbnRleHRzID0gbmV3IEFycmF5KCBsZW5ndGggKTtcbiAgICAgIGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBfaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcbiAgICAgICAgICByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSgpXG4gICAgICAgICAgICAuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuICAgICAgICAgICAgLmZhaWwoIGRlZmVycmVkLnJlamVjdCApXG4gICAgICAgICAgICAucHJvZ3Jlc3MoIHVwZGF0ZUZ1bmMoIGksIHByb2dyZXNzQ29udGV4dHMsIHByb2dyZXNzVmFsdWVzICkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAtLXJlbWFpbmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIG5vdCB3YWl0aW5nIG9uIGFueXRoaW5nLCByZXNvbHZlIHRoZSBtYXN0ZXJcbiAgICBpZiAoICFyZW1haW5pbmcgKSB7XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aCggcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgfTtcblxuICAvLyBUcnkgZXhwb3J0aW5nIGFzIGEgQ29tbW9uLmpzIE1vZHVsZVxuICBpZiAoIHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfZDtcblxuICAvLyBPciBtaXhpbiB0byBVbmRlcnNjb3JlLmpzXG4gIH0gZWxzZSBpZiAoIHR5cGVvZiByb290Ll8gIT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgcm9vdC5fLm1peGluKF9kKTtcblxuICAvLyBPciBhc3NpZ24gaXQgdG8gd2luZG93Ll9cbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfZDtcbiAgfVxuXG59KSh0aGlzKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiYnJlYWtlciIsIkFQIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJPUCIsIk9iamVjdCIsImhhc093biIsImhhc093blByb3BlcnR5IiwidG9TdHJpbmciLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNsaWNlIiwiX2VhY2giLCJvYmoiLCJpdGVyYXRvciIsImNvbnRleHQiLCJrZXkiLCJpIiwibCIsImxlbmd0aCIsImNhbGwiLCJfaXNGdW5jdGlvbiIsImNvbnN0cnVjdG9yIiwiYXBwbHkiLCJfZXh0ZW5kIiwiYXJndW1lbnRzIiwic291cmNlIiwicHJvcCIsIl9pbkFycmF5IiwiZWxlbSIsImFyciIsImxlbiIsIk1hdGgiLCJtYXgiLCJjbGFzczJ0eXBlIiwic3BsaXQiLCJuYW1lIiwidG9Mb3dlckNhc2UiLCJfdHlwZSIsIlN0cmluZyIsIl9kIiwib3B0aW9uc0NhY2hlIiwiY3JlYXRlT3B0aW9ucyIsIm9wdGlvbnMiLCJvYmplY3QiLCJmbGFnIiwiQ2FsbGJhY2tzIiwibWVtb3J5IiwiZmlyZWQiLCJmaXJpbmciLCJmaXJpbmdTdGFydCIsImZpcmluZ0xlbmd0aCIsImZpcmluZ0luZGV4IiwibGlzdCIsInN0YWNrIiwib25jZSIsImZpcmUiLCJkYXRhIiwic3RvcE9uRmFsc2UiLCJzaGlmdCIsInNlbGYiLCJkaXNhYmxlIiwiYWRkIiwic3RhcnQiLCJhcmdzIiwiYXJnIiwidHlwZSIsInVuaXF1ZSIsImhhcyIsInB1c2giLCJyZW1vdmUiLCJpbmRleCIsInNwbGljZSIsImZuIiwiZW1wdHkiLCJ1bmRlZmluZWQiLCJkaXNhYmxlZCIsImxvY2siLCJsb2NrZWQiLCJmaXJlV2l0aCIsIkRlZmVycmVkIiwiZnVuYyIsInR1cGxlcyIsInN0YXRlIiwicHJvbWlzZSIsImFsd2F5cyIsImRlZmVycmVkIiwiZG9uZSIsImZhaWwiLCJ0aGVuIiwiZm5zIiwibmV3RGVmZXIiLCJ0dXBsZSIsImFjdGlvbiIsInJldHVybmVkIiwiZSIsInJlamVjdCIsInJlc29sdmUiLCJwcm9ncmVzcyIsIm5vdGlmeSIsInBpcGUiLCJzdGF0ZVN0cmluZyIsIndoZW4iLCJzdWJvcmRpbmF0ZSIsInJlc29sdmVWYWx1ZXMiLCJyZW1haW5pbmciLCJ1cGRhdGVGdW5jIiwiY29udGV4dHMiLCJ2YWx1ZXMiLCJ2YWx1ZSIsInByb2dyZXNzVmFsdWVzIiwibm90aWZ5V2l0aCIsInJlc29sdmVXaXRoIiwicHJvZ3Jlc3NDb250ZXh0cyIsInJlc29sdmVDb250ZXh0cyIsIm1vZHVsZSIsImV4cG9ydHMiLCJfIiwibWl4aW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/underscore.deferred/underscore.deferred.js\n");

/***/ })

};
;